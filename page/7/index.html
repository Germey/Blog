<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
  <meta name="theme-color" content="#222">
  <meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>
  <script id="hexo-configurations">
    var NexT = window.NexT ||
    {};
    var CONFIG = {
      "hostname": "cuiqingcai.com",
      "root": "/",
      "scheme": "Pisces",
      "version": "7.8.0",
      "exturl": false,
      "sidebar":
      {
        "position": "right",
        "width": 360,
        "display": "post",
        "padding": 18,
        "offset": 12,
        "onmobile": false,
        "widgets": [
          {
            "type": "image",
            "name": "阿布云",
            "enable": false,
            "url": "https://www.abuyun.com/http-proxy/introduce.html",
            "src": "https://cdn.cuiqingcai.com/88au8.jpg",
            "width": "100%"
      },
          {
            "type": "image",
            "name": "爬虫书",
            "url": "https://item.jd.com/13527222.html",
            "src": "https://cdn.cuiqingcai.com/ei5og.jpg",
            "width": "100%",
            "enable": true
      },
          {
            "type": "categories",
            "name": "分类",
            "enable": true
      },
          {
            "type": "image",
            "name": "IPIDEA",
            "url": "http://www.ipidea.net/?utm-source=cqc&utm-keyword=?cqc",
            "src": "https://cdn.cuiqingcai.com/0ywun.png",
            "width": "100%",
            "enable": false
      },
          {
            "type": "image",
            "name": "Storm Proxies",
            "src": "https://cdn.cuiqingcai.com/a2zad8.png",
            "url": "https://www.stormproxies.cn/?keyword=jingmi",
            "width": "100%",
            "enable": false
      },
          {
            "type": "friends",
            "name": "友情链接",
            "enable": true
      },
          {
            "type": "hot",
            "name": "猜你喜欢",
            "enable": true
      },
          {
            "type": "tags",
            "name": "标签云",
            "enable": true
      }]
      },
      "copycode":
      {
        "enable": true,
        "show_result": true,
        "style": "mac"
      },
      "back2top":
      {
        "enable": true,
        "sidebar": false,
        "scrollpercent": true
      },
      "bookmark":
      {
        "enable": false,
        "color": "#222",
        "save": "auto"
      },
      "fancybox": false,
      "mediumzoom": false,
      "lazyload": false,
      "pangu": true,
      "comments":
      {
        "style": "tabs",
        "active": "gitalk",
        "storage": true,
        "lazyload": false,
        "nav": null,
        "activeClass": "gitalk"
      },
      "algolia":
      {
        "hits":
        {
          "per_page": 10
        },
        "labels":
        {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      },
      "localsearch":
      {
        "enable": true,
        "trigger": "auto",
        "top_n_per_article": 10,
        "unescape": false,
        "preload": false
      },
      "motion":
      {
        "enable": false,
        "async": false,
        "transition":
        {
          "post_block": "bounceDownIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      "path": "search.xml"
    };

  </script>
  <meta name="keywords" content="爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书,静觅,崔庆才">
  <meta name="robots" content="index,follow">
  <meta name="GOOGLEBOT" content="index,follow">
  <meta name="author" content="静觅丨崔庆才的个人站点">
  <meta name="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
  <meta property="og:type" content="website">
  <meta property="og:title" content="静觅">
  <meta property="og:url" content="https://cuiqingcai.com/page/7/index.html">
  <meta property="og:site_name" content="静觅">
  <meta property="og:description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
  <meta property="og:locale" content="zh_CN">
  <meta property="article:author" content="崔庆才">
  <meta property="article:tag" content="爬虫教程">
  <meta property="article:tag" content="爬虫">
  <meta property="article:tag" content="Python">
  <meta property="article:tag" content="Python爬虫">
  <meta property="article:tag" content="Python爬虫教程">
  <meta property="article:tag" content="爬虫书">
  <meta property="article:tag" content="静觅">
  <meta property="article:tag" content="崔庆才">
  <meta name="twitter:card" content="summary">
  <link rel="canonical" href="https://cuiqingcai.com/page/7/">
  <script id="page-configurations">
    // https://hexo.io/docs/variables.html
    CONFIG.page = {
      sidebar: "",
      isHome: true,
      isPost: false,
      lang: 'zh-CN'
    };

  </script>
  <title>静觅丨崔庆才的个人站点 - Python爬虫教程</title>
  <meta name="google-site-verification" content="p_bIcnvirkFzG2dYKuNDivKD8-STet5W7D-01woA2fc" />
  <meta name="sogou_site_verification" content="kBOV53NQqT" />
  <noscript>
    <style>
      .use-motion .brand,
      .use-motion .menu-item,
      .sidebar-inner,
      .use-motion .post-block,
      .use-motion .pagination,
      .use-motion .comments,
      .use-motion .post-header,
      .use-motion .post-body,
      .use-motion .collection-header
      {
        opacity: initial;
      }

      .use-motion .site-title,
      .use-motion .site-subtitle
      {
        opacity: initial;
        top: initial;
      }

      .use-motion .logo-line-before i
      {
        left: initial;
      }

      .use-motion .logo-line-after i
      {
        right: initial;
      }

    </style>
  </noscript>
  <link rel="alternate" href="/atom.xml" title="静觅" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-container">
          <div class="site-nav-toggle">
            <div class="toggle" aria-label="切换导航栏">
              <span class="toggle-line toggle-line-first"></span>
              <span class="toggle-line toggle-line-middle"></span>
              <span class="toggle-line toggle-line-last"></span>
            </div>
          </div>
          <div class="site-meta">
            <a href="/" class="brand" rel="start">
              <span class="logo-line-before"><i></i></span>
              <h1 class="site-title">静觅 <span class="site-subtitle"> 崔庆才的个人站点 - Python爬虫教程 </span>
              </h1>
              <span class="logo-line-after"><i></i></span>
            </a>
          </div>
          <div class="site-nav-right">
            <div class="toggle popup-trigger">
              <i class="fa fa-search fa-fw fa-lg"></i>
            </div>
          </div>
        </div>
        <nav class="site-nav">
          <ul id="menu" class="main-menu menu">
            <li class="menu-item menu-item-home">
              <a href="/" rel="section">首页</a>
            </li>
            <li class="menu-item menu-item-archives">
              <a href="/archives/" rel="section">文章列表</a>
            </li>
            <li class="menu-item menu-item-tags">
              <a href="/tags/" rel="section">文章标签</a>
            </li>
            <li class="menu-item menu-item-categories">
              <a href="/categories/" rel="section">文章分类</a>
            </li>
            <li class="menu-item menu-item-about">
              <a href="/about/" rel="section">关于博主</a>
            </li>
            <li class="menu-item menu-item-message">
              <a href="/message/" rel="section">给我留言</a>
            </li>
            <li class="menu-item menu-item-search">
              <a role="button" class="popup-trigger">搜索 </a>
            </li>
          </ul>
        </nav>
        <div class="search-pop-overlay">
          <div class="popup search-popup">
            <div class="search-header">
              <span class="search-icon">
                <i class="fa fa-search"></i>
              </span>
              <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
              </div>
              <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
              </span>
            </div>
            <div id="search-result">
              <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span>0%</span>
    </div>
    <div class="reading-progress-bar"></div>
    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content index posts-expand">
            <div class="carousel">
              <div id="wowslider-container">
                <div class="ws_images">
                  <ul>
                    <li><a target="_blank" href="https://item.jd.com/13527222.html"><img title="Python3网络爬虫开发实战（第二版）上市了！" src="https://cdn.cuiqingcai.com/prwgs.png" /></a></li>
                    <li><a target="_blank" href="https://t.lagou.com/fRCBRsRCSN6FA"><img title="52讲轻松搞定网络爬虫" src="https://cdn.cuiqingcai.com/fqq5e.png" /></a></li>
                    <li><a target="_blank" href="https://cuiqingcai.com/4320.html"><img title="Python3网络爬虫开发视频教程" src="https://cdn.cuiqingcai.com/bjrny.jpg" /></a></li>
                    <li><a target="_blank" href="https://cuiqingcai.com/5094.html"><img title="爬虫代理哪家强？十大付费代理详细对比评测出炉！" src="https://cdn.cuiqingcai.com/nifs6.jpg" /></a></li>
                  </ul>
                </div>
                <div class="ws_thumbs">
                  <div>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/prwgs.png" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/fqq5e.png" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/bjrny.jpg" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/nifs6.jpg" /></a>
                  </div>
                </div>
                <div class="ws_shadow"></div>
              </div>
            </div>
            <link rel="stylesheet" href="/lib/wowslide/slide.css">
            <script src="/lib/wowslide/jquery.min.js"></script>
            <script src="/lib/wowslide/slider.js"></script>
            <script>
              jQuery("#wowslider-container").wowSlider(
              {
                effect: "cube",
                prev: "",
                next: "",
                duration: 20 * 100,
                delay: 100 * 100,
                width: 716,
                height: 297,
                autoPlay: true,
                playPause: true,
                stopOnHover: false,
                loop: false,
                bullets: 0,
                caption: true,
                captionEffect: "slide",
                controls: true,
                onBeforeStep: 0,
                images: 0
              });

            </script>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8943.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8943.html" class="post-title-link" itemprop="url">Python 序列化和反序列化库 MarshMallow 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>在很多情况下，我们会有把 Python 对象进行序列化或反序列化的需求，比如开发 REST API，比如一些面向对象化的数据加载和保存，都会应用到这个功能。 比如这里看一个最基本的例子，这里给到一个 User 的 Class 定义，再给到一个 data 数据，像这样：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name, age)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line"></span><br><span class="line">data = [&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">23</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>现在我要把这个 data 快速转成 User 组成的数组，变成这样：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[User(<span class="attribute">name</span>=<span class="string">'Germey'</span>, <span class="attribute">age</span>=23), User(<span class="attribute">name</span>=<span class="string">'Mike'</span>, <span class="attribute">age</span>=20)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>你会怎么来实现？ 或者我有了上面的列表内容，想要转成一个 JSON 字符串，变成这样：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#123;<span class="attr">"name"</span>: <span class="string">"Germey"</span>, <span class="attr">"age"</span>: <span class="number">23</span>&#125;, &#123;<span class="attr">"name"</span>: <span class="string">"Mike"</span>, <span class="attr">"age"</span>: <span class="number">20</span>&#125;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>你又会怎么操作呢？ 另外如果 JSON 数据里面有各种各样的脏数据，你需要在初始化时验证这些字段是否合法，另外 User 这个对象里面 name、age 的数据类型不同，如何针对不同的数据类型进行针对性的类型转换，这个你有更好的实现方案吗？</p>
                  <h2 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h2>
                  <p>之前我写过一篇文章介绍过 attrs 和 cattrs 这两个库，它们二者的组合可以非常方便地实现对象的序列化和反序列化。 譬如这样：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> attr <span class="keyword">import</span> attrs, attrib</span><br><span class="line"><span class="keyword">from</span> cattr <span class="keyword">import</span> structure, unstructure</span><br><span class="line"></span><br><span class="line">@attrs</span><br><span class="line"><span class="keyword">class</span> <span class="keyword">User</span>(<span class="keyword">object</span>):</span><br><span class="line">    <span class="type">name</span> = attrib()</span><br><span class="line">    age = attrib()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">user</span> = structure(data, <span class="keyword">User</span>)</span><br><span class="line">print(<span class="string">'user'</span>, <span class="keyword">user</span>)</span><br><span class="line"><span class="type">json</span> = unstructure(<span class="keyword">user</span>)</span><br><span class="line">print(<span class="string">'json'</span>, <span class="type">json</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">user</span> <span class="keyword">User</span>(<span class="type">name</span>=<span class="string">'Germey'</span>, age=<span class="number">23</span>)</span><br><span class="line"><span class="type">json</span> &#123;<span class="string">'name'</span>: <span class="string">'Germey'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>好，这里我们通过 attrs 和 cattrs 这两个库来实现了单个对象的转换。 首先我们要肯定一下 attrs 这个库，它可以极大地简化 Python 类的定义，同时每个字段可以定义多种数据类型。 但 cattrs 这个库就相对弱一些了，如果把 data 换成数组，用 cattrs 还是不怎么好转换的，另外它的 structure 和 unstructure 在某些情景下容错能力较差，所以对于上面的需求，用这两个库搭配起来并不是一个最优的解决方案。 另外数据的校验也是一个问题，attrs 虽然提供了 validator 的参数，但对于多种类型的数据处理的支持并没有那么强大。 所以，我们想要寻求一个更优的解决方案。</p>
                  <h2 id="更优雅的方案"><a href="#更优雅的方案" class="headerlink" title="更优雅的方案"></a>更优雅的方案</h2>
                  <p>这里推荐一个库，叫做 marshmallow，它是专门用来支持 Python 对象和原生数据相互转换的库，如实现 object -&gt; dict，objects -&gt; list, string -&gt; dict, string -&gt; list 等的转换功能，另外它还提供了非常丰富的数据类型转换和校验 API，帮助我们快速实现数据的转换。 要使用 marshmallow 这个库，需要先安装下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> marshmallow</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>好了之后，我们在之前的基础上定义一个 Schema，如下：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span>(<span class="title">Schema</span>):</span></span><br><span class="line">    name = fields.Str()</span><br><span class="line">    age = fields.Integer()</span><br><span class="line"></span><br><span class="line">    @post_load</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(<span class="keyword">self</span>, data, **kwargs)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> User(**data)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>还是之前的数据：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">data</span> = [&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">23</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候我们只需要调用 Schema 的 load 事件就好了：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">schema = UserSchema()</span><br><span class="line">users = schema.load(data, <span class="attribute">many</span>=<span class="literal">True</span>)</span><br><span class="line"><span class="builtin-name">print</span>(users)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[User(<span class="attribute">name</span>=<span class="string">'Germey'</span>, <span class="attribute">age</span>=23), User(<span class="attribute">name</span>=<span class="string">'Mike'</span>, <span class="attribute">age</span>=20)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样，我们非常轻松地完成了 JSON 到 User List 的转换。 有人说，如果是单个数据怎么办呢，只需要把 load 方法的 many 参数去掉即可：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: 23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">schema = UserSchema()</span><br><span class="line">user = schema.load(data)</span><br><span class="line"><span class="builtin-name">print</span>(user)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User(<span class="attribute">name</span>=<span class="string">'Germey'</span>, <span class="attribute">age</span>=23)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，这仅仅是一个反序列化操作，我们还可以正向进行序列化，以及使用各种各样的验证条件。 下面我们再来看看吧。</p>
                  <h2 id="更方便的序列化"><a href="#更方便的序列化" class="headerlink" title="更方便的序列化"></a>更方便的序列化</h2>
                  <p>上面的例子我们实现了序列化操作，输出了 users 为：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[User(<span class="attribute">name</span>=<span class="string">'Germey'</span>, <span class="attribute">age</span>=23), User(<span class="attribute">name</span>=<span class="string">'Mike'</span>, <span class="attribute">age</span>=20)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>有了这个数据，我们也能轻松实现序列化操作。 序列化操作，使用 dump 方法即可</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = schema.dump(users, <span class="attribute">many</span>=<span class="literal">True</span>)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'result'</span>, result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">result</span> <span class="selector-attr">[&#123;<span class="string">'age'</span>: 23, <span class="string">'name'</span>: <span class="string">'Germey'</span>&#125;, &#123;<span class="string">'age'</span>: 20, <span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于是 List，所以 dump 方法需要加一个参数 many 为 True。 当然对于单个对象，直接使用 dump 同样是可以的：</p>
                  <figure class="highlight stylus">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = schema.dump(user)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'result'</span>, result)</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight puppet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">result</span> &#123;<span class="string">'name'</span>: <span class="string">'Germey'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样的话，单个、多个对象的序列化也不再是难事。 经过上面的操作，我们完成了 object 到 dict 或 list 的转换，即：</p>
                  <figure class="highlight ocaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">object</span> &lt;-&gt; dict</span><br><span class="line">objects &lt;-&gt; <span class="built_in">list</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2>
                  <p>当然，上面的功能其实并不足以让你觉得 marshmallow 有多么了不起，其实就是一个对象到基本数据的转换嘛。但肯定不止这些，marshmallow 还提供了更加强大啊功能，比如说验证，Validation。 比如这里我们将 age 这个字段设置为 hello，它无法被转换成数值类型，所以肯定会报错，样例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    schema = UserSchema()</span><br><span class="line">    user, errors = schema.load(data)</span><br><span class="line">    print(user, errors)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'e.message'</span>, e.messages)</span><br><span class="line">    print(<span class="string">'e.valid_data'</span>, e.valid_data)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里如果加载报错，我们可以直接拿到 Error 的 messages 和 valid_data 对象，它包含了错误的信息和正确的字段结果，运行结果如下：</p>
                  <figure class="highlight puppet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">e.<span class="keyword">message</span> &#123;<span class="string">'age'</span>: [<span class="string">'Not a valid integer.'</span>]&#125;</span><br><span class="line"><span class="keyword">e</span>.<span class="keyword">valid_data</span> &#123;<span class="string">'name'</span>: <span class="string">'Germey'</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>因此，比如我们想要开发一个功能，比如用户注册，表单信息就是提交过来的 data，我们只需要过一遍 Validation，就可以轻松得知哪些数据符合要求，哪些不符合要求，接着再进一步进行处理。 当然验证功能肯定不止这一些，我们再来感受一下另一个示例：</p>
                  <figure class="highlight xquery">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from pprint <span class="keyword">import</span> pprint</span><br><span class="line">from marshmallow <span class="keyword">import</span> Schema, fields, <span class="keyword">validate</span>, ValidationError</span><br><span class="line"></span><br><span class="line">class UserSchema(Schema):</span><br><span class="line">   <span class="built_in"> name</span> = fields.Str(<span class="keyword">validate</span>=<span class="keyword">validate</span>.Length<span class="built_in">(min</span>=<span class="number">1</span>))</span><br><span class="line">    permission = fields.Str(<span class="keyword">validate</span>=<span class="keyword">validate</span>.OneOf([<span class="string">'read'</span>, <span class="string">'write'</span>, <span class="string">'admin'</span>]))</span><br><span class="line">    age = fields.Int(<span class="keyword">validate</span>=<span class="keyword">validate</span>.Range<span class="built_in">(min</span>=<span class="number">18</span>,<span class="built_in"> max</span>=<span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">in_data = &#123;<span class="string">'name'</span>: <span class="string">''</span>, <span class="string">'permission'</span>: <span class="string">'invalid'</span>, <span class="string">'age'</span>: <span class="number">71</span>&#125;</span><br><span class="line">try:</span><br><span class="line">    UserSchema().load(in_data)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> err:</span><br><span class="line">    pprint(err.messages)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>比如这里的 validate 字段，我们分别校验了 name、permission、age 三个字段，校验方式各不相同。 如 name 我们要判断其最小值为 1，则使用了 Length 对象。permission 必须要是几个字符串之一，这里又使用了 OneOf 对象，age 又必须是介于某个范围之间，这里就使用了 Range 对象。 下面我们故意传入一些错误的数据，看下运行结果：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;'age': ['Must be <span class="keyword">greater than</span> <span class="keyword">or</span> <span class="keyword">equal</span> <span class="keyword">to</span> <span class="number">18</span> <span class="keyword">and</span> <span class="keyword">less than or equal</span> <span class="keyword">to</span> <span class="number">40.</span>'],</span><br><span class="line"> '<span class="built_in">name</span>': ['Shorter than minimum <span class="built_in">length</span> <span class="number">1.</span>'],</span><br><span class="line"> 'permission': ['Must be one <span class="keyword">of</span>: <span class="built_in">read</span>, <span class="built_in">write</span>, admin.']&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里也返回了数据验证的结果，对于不符合条件的字段，一一进行说明。 另外我们也可以自定义验证方法：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from marshmallow import Schema, fields, ValidationError</span><br><span class="line"></span><br><span class="line">def validate<span class="constructor">_quantity(<span class="params">n</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        raise <span class="constructor">ValidationError('Quantity <span class="params">must</span> <span class="params">be</span> <span class="params">greater</span> <span class="params">than</span> 0.')</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">30</span>:</span><br><span class="line">        raise <span class="constructor">ValidationError('Quantity <span class="params">must</span> <span class="params">not</span> <span class="params">be</span> <span class="params">greater</span> <span class="params">than</span> 30.')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="constructor">ItemSchema(Schema)</span>:</span><br><span class="line">    quantity = fields.<span class="constructor">Integer(<span class="params">validate</span>=<span class="params">validate_quantity</span>)</span></span><br><span class="line"></span><br><span class="line">in_data = &#123;'quantity': <span class="number">31</span>&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="constructor">ItemSchema()</span>.load(in_data)</span><br><span class="line">except ValidationError <span class="keyword">as</span> err:</span><br><span class="line">    print(err.messages)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过自定义方法，同样可以实现更灵活的验证，运行结果：</p>
                  <figure class="highlight prolog">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'quantity'</span>: [<span class="string">'Quantity must not be greater than 30.'</span>]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>对于上面的例子，还有更优雅的写法：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from marshmallow import fields, Schema, validates, ValidationError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="constructor">ItemSchema(Schema)</span>:</span><br><span class="line">    quantity = fields.<span class="constructor">Integer()</span></span><br><span class="line"></span><br><span class="line">    @validates('quantity')</span><br><span class="line">    def validate<span class="constructor">_quantity(<span class="params">self</span>, <span class="params">value</span>)</span>:</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            raise <span class="constructor">ValidationError('Quantity <span class="params">must</span> <span class="params">be</span> <span class="params">greater</span> <span class="params">than</span> 0.')</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">30</span>:</span><br><span class="line">            raise <span class="constructor">ValidationError('Quantity <span class="params">must</span> <span class="params">not</span> <span class="params">be</span> <span class="params">greater</span> <span class="params">than</span> 30.')</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过定义方法并用 validates 修饰符，使得代码的书写更加简洁。</p>
                  <h2 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h2>
                  <p>如果要想定义必填字段，只需要在 fields 里面加入 required 参数并设置为 True 即可，另外我们还可以自定义错误信息，使用 error_messages 即可，例如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> marshmallow <span class="keyword">import</span> Schema, fields, ValidationError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span><span class="params">(Schema)</span>:</span></span><br><span class="line">    name = fields.String(required=<span class="literal">True</span>)</span><br><span class="line">    age = fields.Integer(required=<span class="literal">True</span>, error_messages=&#123;<span class="string">'required'</span>: <span class="string">'Age is required.'</span>&#125;)</span><br><span class="line">    city = fields.String(</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        error_messages=&#123;<span class="string">'required'</span>: &#123;<span class="string">'message'</span>: <span class="string">'City required'</span>, <span class="string">'code'</span>: <span class="number">400</span>&#125;&#125;,</span><br><span class="line">    )</span><br><span class="line">    email = fields.Email()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = UserSchema().load(&#123;<span class="string">'email'</span>: <span class="string">'foo@bar.com'</span>&#125;)</span><br><span class="line"><span class="keyword">except</span> ValidationError <span class="keyword">as</span> err:</span><br><span class="line">    pprint(err.messages)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="默认字段"><a href="#默认字段" class="headerlink" title="默认字段"></a>默认字段</h2>
                  <p>对于序列化和反序列化字段，marshmallow 还提供了默认值，而且区分得非常清楚！如 missing 则是在反序列化时自动填充的数据，default 则是在序列化时自动填充的数据。 例如：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="title">from</span> marshmallow <span class="keyword">import</span> Schema, fields</span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">UserSchema</span>(<span class="type">Schema</span>):</span></span><br><span class="line"><span class="class">    id = fields.<span class="type">UUID</span>(<span class="title">missing</span>=<span class="title">uuid</span>.<span class="title">uuid1</span>)</span></span><br><span class="line"><span class="class">    birthdate = fields.<span class="type">DateTime</span>(<span class="title">default</span>=<span class="title">dt</span>.<span class="title">datetime</span>(2017, 9, 29))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">print(<span class="type">UserSchema</span>().load(&#123;&#125;))</span></span><br><span class="line"><span class="class">print(<span class="type">UserSchema</span>().dump(&#123;&#125;))</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们都是定义的空数据，分别进行序列化和反序列化，运行结果如下：</p>
                  <figure class="highlight 1c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;'id': UUID('06aa384a-570c-11ea-<span class="number">9869</span>-a<span class="number">0999</span>b0d<span class="number">6843</span>')&#125;</span><br><span class="line">&#123;'birthdate': '<span class="number">2017-09-29</span>T00:00:00'&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，在没有真实值的情况下，序列化和反序列化都是用了默认值。 这个真的是解决了我之前在 cattrs 序列化和反序列化时候的痛点啊！</p>
                  <h2 id="指定属性名"><a href="#指定属性名" class="headerlink" title="指定属性名"></a>指定属性名</h2>
                  <p>在序列化时，Schema 对象会默认使用和自身定义相同的 fields 属性名，当然也可以自定义，如：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">class UserSchema(Schema):</span><br><span class="line">    name = fields.String()</span><br><span class="line">    email_addr = fields.String(<span class="attribute">attribute</span>=<span class="string">'email'</span>)</span><br><span class="line">    date_created = fields.DateTime(<span class="attribute">attribute</span>=<span class="string">'created_at'</span>)</span><br><span class="line"></span><br><span class="line">user = User(<span class="string">'Keith'</span>, <span class="attribute">email</span>=<span class="string">'keith@stones.com'</span>)</span><br><span class="line">ser = UserSchema()</span><br><span class="line">result, errors = ser.dump(user)</span><br><span class="line">pprint(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight 1c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;'name': 'Keith',</span><br><span class="line"> 'email_addr': 'keith@stones.com',</span><br><span class="line"> 'date_created': '<span class="number">2014-08-17</span>T14:58:57.<span class="number">600623</span>+00:00'&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>反序列化也是一样，例如：</p>
                  <figure class="highlight kotlin">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSchema</span></span>(Schema):</span><br><span class="line">    name = fields.String()</span><br><span class="line">    email = fields.Email(load_from=<span class="string">'emailAddress'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'emailAddress'</span>: <span class="string">'foo@bar.com'</span></span><br><span class="line">&#125;</span><br><span class="line">s = UserSchema()</span><br><span class="line">result, errors = s.load(<span class="keyword">data</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'name'</span>: <span class="string">u'Mike'</span>,</span><br><span class="line"> <span class="string">'email'</span>: <span class="string">'foo@bar.com'</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h2>
                  <p>对于嵌套属性，marshmallow 当然也不在话下，这也是让我觉得 marshmallow 非常好用的地方，例如：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="title">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="title">from</span> marshmallow <span class="keyword">import</span> Schema, fields, pprint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ArtistSchema</span>(<span class="type">Schema</span>):</span></span><br><span class="line"><span class="class">    name = fields.<span class="type">Str</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">AlbumSchema</span>(<span class="type">Schema</span>):</span></span><br><span class="line"><span class="class">    title = fields.<span class="type">Str</span>()</span></span><br><span class="line"><span class="class">    release_date = fields.<span class="type">Date</span>()</span></span><br><span class="line"><span class="class">    artist = fields.<span class="type">Nested</span>(<span class="type">ArtistSchema</span>())</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">bowie = dict(<span class="title">name</span>='<span class="type">David</span> <span class="type">Bowie</span>')</span></span><br><span class="line"><span class="class">album = dict(<span class="title">artist</span>=<span class="title">bowie</span>, <span class="title">title</span>='<span class="type">Hunky</span> <span class="type">Dory</span>', <span class="title">release_date</span>=<span class="title">date</span>(1971, 12, 17))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">schema = <span class="type">AlbumSchema</span>()</span></span><br><span class="line"><span class="class">result = schema.dump(<span class="title">album</span>)</span></span><br><span class="line"><span class="class">pprint(<span class="title">result</span>, <span class="title">indent</span>=2)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就能充分利用好对象关联外键来方便地实现很多关联功能。 以上介绍的内容基本算在日常的使用中是够用了，当然以上都是一些基本的示例，对于更多功能，可以参考 marchmallow 的官方文档：<a href="https://marshmallow.readthedocs.io/en/stable/，强烈推荐大家用起来" target="_blank" rel="noopener">https://marshmallow.readthedocs.io/en/stable/，强烈推荐大家用起来</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-02-25 01:21:41" itemprop="dateCreated datePublished" datetime="2020-02-25T01:21:41+08:00">2020-02-25</time>
                </span>
                <span id="/8943.html" class="post-meta-item leancloud_visitors" data-flag-title="Python 序列化和反序列化库 MarshMallow 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>7.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>7 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8939.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 福利专区 <i class="label-arrow"></i>
                  </a>
                  <a href="/8939.html" class="post-title-link" itemprop="url">东鸽送3台｜做开发没有云服务器怎么行？</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>随着云计算和虚拟技术的发展，主机业务从虚拟主机逐步发展到独享云服务器。我们 IT 人对服务器的需求是很强烈的，无论你是后端研发、前端开发、云计算、大数据、架构、数据存储、运维还是产品经理，每个人手上多多少少都会有几台云服务器。 <img src="http://can.sfhfpc.com/sfhfpc/20200220191443.jpg" alt=""> 这些云服务器被用做测试用机、学习用机或者正式生产用机，有些朋友会在上面搭建博客，有些朋友在上面搭建 API。东鸽自己也手握几台服务器： <img src="http://can.sfhfpc.com/sfhfpc/20200220182953.jpg" alt=""> 其中有 3 台用作实际的生产，新书《<a href="https://item.jd.com/12794078.html" target="_blank" rel="noopener">Python3 反爬虫原理与绕过实战</a>》的<a href="http://www.porters.vip/" target="_blank" rel="noopener">在线练习平台</a>、<a href="https://bbs.nightteam.cn/" target="_blank" rel="noopener">夜幕爬虫安全论坛</a>和我的<a href="http://www.sfhfpc.com/" target="_blank" rel="noopener">个人博客</a>。另外几台用来做测试、数据合作和练习。 练习的话，像平时学习 MongoDB 数据库、Redis 数据库和 Mysql 数据库的时候，我会在服务器上安装对应的应用，启动服务后在自己的电脑上连接，这样能得到与生产环境一样的体验。学习 Linux 和 Shell 脚本的时候也会用云服务器进行练习，这样既能够确保练习效果，又避免了对本机电脑的干扰。 <strong>你总不能在自己的电脑上折腾来折腾去吧，万一搞坏了，工作咋办？</strong> 数据合作，那是个人业务上的事了。数据用云端数据库的方式交付给客户，不需要其他传输媒介，轻便快捷，没有延时风险。我这边把数据存储到服务器，客户从服务器上拉取数据。 <img src="https://www.rabbitmq.com/img/tutorials/python-one.png" alt=""> <strong>一个普通的生产者消费者模式就诞生了。</strong>如果数据业务体量比较大，或者说数据业务的出口比较多，那我可能会借用消息中间件来进行调节。 <img src="https://www.rabbitmq.com/img/tutorials/python-four.png" alt=""> 为了保证数据的完整性和可用性，我可能会对服务器进行镜像，那么我就需要 2～3 台服务器。假设每台服务器的成本是 300元/年，数据合作业务的收入是 3W/年，那真是四两拨千斤了。 要合理利用资源，让资源为我们生<strong>小钱钱</strong>！ 服务器配置跟具体业务需求有关，用于测试的服务器通常是 1 核 2G 1M；博客和论坛的服务器带宽稍大一些，带宽通常是 3M ；用于数据合作的服务器内存较大，一般需要为 4G～8G； 除了服务器之外，<strong>华为云</strong>还有很多<strong>神奇的业务</strong>。我觉得<strong>黑科技</strong>真的是太多了。 <img src="https://www.huaweicloud.com/content/dam/cloudbu-site/archive/china/zh-cn/product/enterprise_intelligence/modelarts/images/modelarts-learn-slide1.png" alt=""> 上次我用华为云的深度学习一体化服务 ModelArts 在线实现了图像深度学习中的图片标注、图片分类预测和模型部署+生成 API，感觉很流畅。 <img src="http://can.sfhfpc.com/sfhfpc/20200221172409.jpg" alt=""> 鼠标点点点，配置一丢丢参数，也不用自己写代码，也不用弄 Web 框架，唰唰唰地几下，就可以调用了。 崔庆才崔哥用 ModelArts 实现了爬虫工程师常用到的拼图验证码缺口识别 API。 <img src="http://can.sfhfpc.com/sfhfpc/20200221172230.jpg" alt=""> 样本准备了小小几十个，训练完成后的识别准确率很高，这样我们就不用担心缺口位置定位的问题了。 <img src="http://can.sfhfpc.com/sfhfpc/20200221172556.jpg" alt=""> 服务器数量多，开销自然就大。如无必要，通常我是不会购买服务器的，但每当云服务器厂商有活动时我都会做一些购买计划。例如我今年打算增加数据业务，并且学习架构方面的知识，那我至少得再买 5 台服务器。趁着华为开年采购季活动，购买一台服务器的成本最低 79元/年。除此之外，华为云还有数据库专场活动、域名建站专场活动、云安全专场活动在等着我们，买买买！ <img src="http://can.sfhfpc.com/sfhfpc/20200220185546.jpeg" alt=""> 大家相识已久，东鸽感谢大家关注和支持，这次华为云开年采购季活动我自掏腰包购买 3 台 1 核 2G 1M 的服务器（1年期）送给各位粉丝。大家扫码即可参与抽奖，到期自动开奖。 <strong>参与要求</strong>：参与活动时必须转发上方华为云开年采购季海报，领奖时小编会检查的哦。 <img src="http://can.sfhfpc.com/sfhfpc/20200220190807.jpeg" alt=""></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/韦世东学算法和反爬虫" class="author" itemprop="url" rel="index">韦世东学算法和反爬虫</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-02-24 10:06:03" itemprop="dateCreated datePublished" datetime="2020-02-24T10:06:03+08:00">2020-02-24</time>
                </span>
                <span id="/8939.html" class="post-meta-item leancloud_visitors" data-flag-title="东鸽送3台｜做开发没有云服务器怎么行？" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8893.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8893.html" class="post-title-link" itemprop="url">推荐个好用的书签工具</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>今天刚发现了一个我觉得不错的工具，介绍给大家，不是打广告哈，是真心推荐。 在推荐之前，问大家一个问题：</p>
                  <ul>
                    <li>大家平常遇到不错的网站或文章，会用什么方式收藏？Chrome 书签？</li>
                    <li>现在你们 Chrome 书签里面啥样子？乱不乱？</li>
                    <li>如果我让你们快速从书签里面找出一个曾经收藏过网站，你要花多久？</li>
                    <li>如果你在手机上用其他的浏览器，比如 Safari、微博上看到了一个不错的网站，怎么存？</li>
                    <li>存到了 Safari 上面，又怎么和电脑上的 Chrome 书签合并？之后还能找到吗？</li>
                  </ul>
                  <p>在这个终身学习的时代，我们需要保存和收藏的东西太多太多了。好的网站，好的博文，好的软件，都需要存下来。那么怎么存？这是个问题。 我最早也用过 Chrome 书签，但是这有个毛病，怎么全平台同步？我想在手机（iPhone）上看我的书签内容，难道我还要专门下个 Chrome？另外书签的整理和搜索也是个问题，实在是让我喜欢不起来。 我在选择软件都会追求全平台云同步。比如时间规划软件，我会用「滴答清单」；SSH 软件，我会用「Termius」；翅膀软件我会用「Surge」，为的都是解决一些跨终端问题，它们都是 iPhone、iPad、Mac、Windows、Web 全部平台同步的，有的甚至还支持浏览器插件或者 Apple Watch 等等，这样我们不论切换到哪个终端，都会非常方便地同步数据。</p>
                  <h2 id="Pocket"><a href="#Pocket" class="headerlink" title="Pocket"></a>Pocket</h2>
                  <p>所以，对于上面说的这个问题，怎么来收藏链接，有什么好用的 App 呢？这个最初是选择了「Pocket」。 <img src="https://cdn.cuiqingcai.com/2020-02-03-142941.png" alt="image-20200203222939945"> 「Pocket」这个软件有一个不错的特性，那就是跨平台，我可以在浏览器、Mac、iPhone、iPad 上使用，看到不错的网站，调出插件或者点击「分享到 Pocket」就可以存进去了，这样就解决了多平台同步问题，另外 「Pocket」还能设置一些标签等等，然后每周或定期我再翻出来整理整理。 说实话，我用「Pocket」好几年了，但总觉得一直达不到我心中完美的标准，怎么说呢？下面总结一下：</p>
                  <h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3>
                  <p>跨平台的支持确实挺好的，这也是我选择「Pocket」的重要原因，支持 Web、Mac、Windows、iPhone、iPad 、Android 各大平台，另外还提供了多款浏览器插件，全平台同步。 光这一点就干倒了很多竞争者了。 然而，不好的也有很多。</p>
                  <h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3>
                  <p>首先，Mac 的界面太丑了，多少年了，我一直盼着能改好看点，结果界面一直没有大的改观。这谁受得住啊？ 截图看看： <img src="https://cdn.cuiqingcai.com/2020-02-03-113030.png" alt="image-20200203193029173"> 哎，一眼难尽啊，左边浓浓的拟物化风格，右边自作聪明出了个阅读模式，也就是自动提取正文内容，结果把文章格式整的这么乱。</p>
                  <h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3>
                  <p>怎么说呢？其实不能追求太多，我最初也只是想找一个存书签的软件。但它的一些分类和标签做的体验并不友好。另外如果我想存文件、存图片，那几乎是不可能的了。 另外这个页面布局吧，实在是让我难以恭维。我不能一目了然地看到我的所有分类和分类层级、标签等等内容。 另外「Pocket」里面还增加了「发现」、「活动」、「资料」三个选项卡，总体来说有点社交性质，它让我去关注点别人，然后看到别人的收藏动态，其中两个选项卡几乎都是常年没啥有效内容的，觉得这些功能有点鸡肋，不足以上升到能和我的收藏列表一个级别。所以我基本上就只开第一个选项卡「我的列表」，只有这里才是我真正想要的收藏列表。 看下图吧，只有第一个选项卡才是收藏列表，第二个就是「发现」，第三个「活动」，最后一个「资料」，后三个基本上没啥卵用，没关注几个人，第三个基本上是常年空着的状态。 <img src="https://cdn.cuiqingcai.com/2020-02-03-144032.png" alt="IMG_2326"> 所以说，这软件的界面、操作和功能，只能说我不喜欢。不喜欢就不要将就，我将就了这么久，最后还是要放弃它。</p>
                  <h2 id="Raindrop-io"><a href="#Raindrop-io" class="headerlink" title="Raindrop.io"></a>Raindrop.io</h2>
                  <p>所以近期我就一直在找一款能替换掉「Pocket」的纯粹的内容收集软件，这么几个原则吧：</p>
                  <ul>
                    <li>跨平台，必须支持所有终端，包括 Windows、Mac、iPhone、iPad、Android、Web 并提供各个浏览器插件。</li>
                    <li>功能明确，能方便地管理分类、标签、收藏等内容，且不要有一些其他鸡肋的功能。</li>
                    <li>好看，好看，好看！我还是很注重界面和美观的，不论是图标还是内页，不优雅的界面会让我觉得很不爽。（之前找软件的时候因为某些软件的图标设计得不好看而被我 Pass 了）。</li>
                  </ul>
                  <p>好了，搜啊搜，找到这么一款软件—— Raindrop.io，感觉不错，看到首页的介绍，被吸引到了！ <img src="https://cdn.cuiqingcai.com/2020-02-03-143755.png" alt=""> 大家可以看视频来感受一下：<a href="https://up.raindrop.io/web/marketing/intro.mp4" target="_blank" rel="noopener">https://up.raindrop.io/web/marketing/intro.mp4</a> 可以说首先界面真的吸引到我了，而且左侧的导航分类、收藏夹的管理非常清晰，页面布局也很清晰，甚至支持文件、图片等格式的收藏！另外它同样也支持全平台，完全符合我的需求。 然后我就下载下来了各个平台都试了试，首先试了试它的一些基础功能，比如收藏夹的管理，然后添加上一些不错的内容。 初步整理成下图这么个样子： <img src="https://cdn.cuiqingcai.com/2020-02-03-141955.png" alt="image-20200203221953942"> 另外内容还支持各种其他的布局，如列表式： <img src="https://cdn.cuiqingcai.com/2020-02-03-142113.png" alt="image-20200203222112657"> 瀑布流式： <img src="https://cdn.cuiqingcai.com/2020-02-03-135545.png" alt="image-20200203215543721"> 舒服了。 说回功能，这里我先分了几个分组，为「网站」、「代码」、「图片」，我估计我用到的最多的肯定是「网站」这个分组，用来存各种链接的，「代码」和「图片」是为了测试它的上传文件和图片功能而加的，可以用来存代码文件和图片。 分组建好之后，我们可以在分组里面添加收藏夹，看图里面每行前面有个小图标的就是一个收藏夹。没错，每个收藏夹都可以自定义它的小图标，这个功能真的是增色不少！ 它提供了非常多的小图标，看： <img src="https://cdn.cuiqingcai.com/2020-02-03-140212.png" alt="image-20200203220210879"> 这个功能，我觉得简直不能更赞！另外这些小图标还可以自己上传，所以你看图里面的 GitHub 图标、Python 图标，都是我从 icons8 上面找到并上传的，毫无违和感！ 另外每一个收藏它都会自动生成一张封面图，会自动截取网站当前页面的内容，或者也可以自定义上传图片或者自定义截屏，最后每个收藏项都会变成一张张卡片。 当然添加标签页不在话下。 <img src="https://cdn.cuiqingcai.com/2020-02-03-143951.png" alt="image-20200203220829929"> 另外浏览器的插件也做的很精致，提供了 Mini Application 和极简模式，收藏一个页面只需要点一下这个图标就收藏好了。如果是高级版的账号，还支持自动分类。 <img src="https://cdn.cuiqingcai.com/2020-02-03-141017.png" alt="image-20200203221016017"> 手机和 iPad 上面的软件我也试了，功能基本类似。怎么保存呢？比如我的 iPhone 上可以把这个软件放到分享的 App 列表里面，这样在浏览器里面点击「分享」，然后选「Raindrop.io」就好了，它会自动弹出一个窗口，让我们选择分类或加标签，体验很不错。 <img src="https://cdn.cuiqingcai.com/2020-02-03-141751.png" alt="IMG_2327"> 嗯，总之整体体验下来，非常好用。 另外它还支持自动导入书签或从其他的收藏软件里面迁移，大家如果一些网站保存在书签里面的话，如果用了这个，可以快速导入进来，非常方便！ <img src="https://cdn.cuiqingcai.com/2020-02-03-142317.png" alt="image-20200203222316105"> 另外还有一些高级的功能大家再探索吧。怎么感觉越写越像个广告文了，但确实这不是广告文，它确实很好用，在这强推给大家！希望它能帮助大家方便管理各种资源，什么博客、公众号、干货、微博、图片、文件统统可以保存到这里并明确清晰地归类啦！</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-02-10 01:37:28" itemprop="dateCreated datePublished" datetime="2020-02-10T01:37:28+08:00">2020-02-10</time>
                </span>
                <span id="/8893.html" class="post-meta-item leancloud_visitors" data-flag-title="推荐个好用的书签工具" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8891.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 个人随笔 <i class="label-arrow"></i>
                  </a>
                  <a href="/8891.html" class="post-title-link" itemprop="url">关于开会的一些思考</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>今天一个偶然的机会，在群里看到了一个推送，是来自一个软件「飞书」的公开课，它讲如何使用飞书，以及如何提高团队的协作效率，我就去听了一下。 头条是飞书开发的，整个 Talk 其实讲了挺多的关于飞书的使用，其实和很多软件的功能大体上是相同的，如文件共享、文档协作、任务分配、聊天沟通等等，像行业内挺多软件，如 Worktile、TAPD、Teambition 等等也都比较完善了，所以一些类似的功能我就不展开说了。 不过其中有一个点，让我听了之后深受启发，那就是如何提高开会效率。 我也参加过很多会议了，包括研究生期间跟着导师出去汇报、开实验室小组会或者公司内部开大会。其中有的内容是讨论具体的实施方案，有的一些时候是单纯的分享或者 sync 进度。对于后者的话，其实没什么问题，就是一个人分享或者快速跟其他人沟通，我想大部分情况下大家都是类似的。但是对于前者，我就觉得一些会议效率太低了，甚至说价值并不高，那么这里就主要说说这种会议。 比如有些会议，尤其是大会，比如十几二十人围在一起开会讨论方案，参与的人很多很杂，有的人甚至还是和会议相关度不高的人或者本身对会议主题完全不了解的人。这时候可能有一个人主持会先说说这个会是干嘛的，开这个会要讨论点什么，说了十分钟之后，一些人才大体上明白这个会在做什么。然后后面就是后面开始讨论方案了，大家也没有整个的时间把控，不知道一共可能讨论多久，大家你一句我一句，有时候扯着扯着扯远了，最后一个会能开上一个半甚至两个多小时，然后会议结束了之后，大家又接着去干活去了。过了一阵子或者几天，想回想一下当时会上到底是怎么说的或者讨论了什么方案，很可能就忘了。如果当时会上有专门做会议纪要的人，那还 OK，如果没有，那这么多人过了一段时间，具体会上说了那些有用的东西或者最后采取了什么方案具体怎么实施呢？很可能就是两个字：忘了。另外，有些人可能整个会上一句话也没说，完全感觉不到任何参与感，所以他也就越来越觉得这个会议没有什么意义，甚至可能就在会上就睡着了。 我想工作的各位难免会遇到这样的问题，或者甚至大家的会议现状就是这样子的。我之前也一直觉得，这种会议模式其实挺病态的，在时间这么宝贵的今天，到底有没有一个比较好的开会方式呢？ 今天听了这个分享之后，我确实被其中所讲的一个会议模式吸引到了。 怎么个方式呢？这里我就根据自己的理解大体概括一下。</p>
                  <h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2>
                  <p>会议的组织者，在开会之前，根据会议的适用场景，列好这个会议想要讨论的内容，以文档的形式写下来。比如要开发一个软件，那么可能就列出来其中的交互或实现方案。如果是要讨论一个解决方案，那就把已经想到的解决方案写下来。 然后呢，很重要的，在开会之前，把文档都发给大家，比如附在邮件链接里面，大家都可以下载或者在线查看。这样可以让大家提前对会议的内容有所了解，如果是对会议毫不了解的人，也能对会议的主题有个整体的把握。 这样就不会出现这样的情况了： 咦，来了一个会啊，咋叫上我了？这个会到底干嘛的？写的这个主题到底啥意思？我去了能干啥？ 这就是其一，提前准备，让所有人都有所了解。 另外，每个人知道主题和讨论内容了，也就知道自己需要准备什么东西，哪些需要演示，哪些需要重点讲解。</p>
                  <h2 id="阅读及评论"><a href="#阅读及评论" class="headerlink" title="阅读及评论"></a>阅读及评论</h2>
                  <p>这个环节也很新颖和高效。 在会议开始的时候，前 15 分钟（时间视情况而定），没有任何人讲话！注意是没有任何人讲话！ 那么大家做什么？看文档！ 大家会在这前 15 分钟里面仔细阅读文档和思考。由于文档是共享的，可以在线协作编辑的，每个人都可以在上面写 Comments，比如提意见或者提想法。由于大家都登录了自己的账户，所以谁提的 Comments，所有人都一清二楚，而且可以实时看到。 就类似下图的这种感觉，见图右侧的 Comments。 <img src="https://cdn.cuiqingcai.com/2020-02-05-151914.png" alt="image-20200205231912431"> 然后 15 分钟过后，大家会针对大家疑虑的点进行讨论。 注意，由于有了 Comments，大家就知道一共有多少需要讨论的点，这个会还剩余多久，每个 Comment 可以讨论多长时间，这样又避免了开会时间无节制的问题。 然后还有一个重要的点，就是每讨论完一个 Comment，就在对应的地方写上解决方案或者附上 Todo List，即具体的实施措施，做到当场讨论问题、当场提出解决方案、当场分配任务计划。 OK，然后整个会就很有目标地开完了，很有侧重点，而且大家都清除的就不需要讨论了。 另外还有一个优点就是，每个人都可以提 Comments，这样每个人都会感到极强的参与感，再也不会出现会上一言不发事不关己高高挂起的状态了。</p>
                  <h2 id="会后"><a href="#会后" class="headerlink" title="会后"></a>会后</h2>
                  <p>由于采取了前面的两步措施，所以会后也就更方便了。 整个会议的纪要在哪里？就是之前的文档里。 整个会议关键的点在哪里？都在 Comments 和对应的回复里。 整个会议讨论出了什么计划？当场也已经分配好了，大家会后直接根据会上分配的 Todo 去做就好了，分配的任务会自动加到每个人的 Todo List 里面。 过了几天，我想复盘整个会议或者回想下这个会议说了些啥，怎么办？直接打开会议文档就好了。 还需要专门写会议纪要的吗？会上大家共同协作会议文档，已经都写好了。 嗯，这就是整个会议的模式。 节省了多少时间或者避免了什么问题呢？我们数数吧。</p>
                  <ul>
                    <li>每个人在会前都可以对会议提前了解和准备，每个人的了解和准备都会更充分。</li>
                    <li>开会前半段每个人都会有单独的时间去理解和思考并做评论。</li>
                    <li>每个人都会有极强的参与感。</li>
                    <li>根据大家评论的数量来把握整个开会的节奏，减少了拖延的概率。</li>
                    <li>会上当场确定好解决方案和人员，自动同步到每个人的 Todo 列表。</li>
                    <li>会后随时查看，随时复盘。</li>
                    <li>文档记录，永不丢失遗忘。</li>
                  </ul>
                  <p>真的可以说，这个模式我觉得非常好，大幅提高了开会的效率，节省了时间。 这个模式我听 Talk 里面说已经在诸如头条的公司里面用了很久了，很多人都反馈很不错。飞书在这方面的支持已经做得挺好了，但可能很多公司不用飞书，不过现在还有很不错的在线协作文档，比如 石墨文档、Pages、Worktile、OneNote 等等也都可以成为候选方案，这个模式还是完全可以借鉴的。 以上仅是我的一点总结和思考，希望对大家有所启发，谢谢！</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-02-10 01:34:12" itemprop="dateCreated datePublished" datetime="2020-02-10T01:34:12+08:00">2020-02-10</time>
                </span>
                <span id="/8891.html" class="post-meta-item leancloud_visitors" data-flag-title="关于开会的一些思考" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.4k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8889.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 个人随笔 <i class="label-arrow"></i>
                  </a>
                  <a href="/8889.html" class="post-title-link" itemprop="url">2020 才过去了一个多月，世界都发生了些什么</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>有人说：2019 年可能是过去十年里最坏的一年，但可能是未来十年里最好的一年。 的确 2019 整个大环境确实比较差，很多人可能在 2020，这个新的一个十年的开端，许愿接下来的日子能慢慢好起来。但目前的状况，大家可能都看到了，新型冠状病毒的肆虐，让全国都变成了什么样子。在国内，新型冠状病毒相关的态势一直最近的头条，但可能大家并没有注意到，其实世界各地都似乎不怎么太平，如。而看看时间，2020 才过去了一个多月而已。</p>
                  <h2 id="中国"><a href="#中国" class="headerlink" title="中国"></a>中国</h2>
                  <p>不知道大家是不是和我一样，起床醒来的第一件事就是去查一查现在国内新型冠状病毒的确诊人数。 <img src="https://cdn.cuiqingcai.com/2020-02-09-131059.png" alt="image-20200209211057573"> 截止今天（2 月 9 日）晚上 9 点，全国确诊病例达到 37289 例，疑似病例 28942 例，每天还以好几千的数量增加，估计明天早上能突破 4 万。 全国 31 个省区均早已经启动了一级响应，这在过去是从未有过的，随着病毒的传播蔓延，事态的严重性远远超出人们最大胆的想象。现在国家正在举全国之力支援灾区，前线的医疗人员一直在全力以赴救治患者。全国各个地区也在采取可以说是历史上最严格的防疫措施，全国范围内的商场、餐厅、娱乐场所几乎都被关停，各家各户的居民也都在家隔离，企业也延迟复工或者到现在还有很多企业都没有正式复工，口罩物资都已经全网脱销，一罩难求。但没有办法，在这个非常时刻，只要我们每个人都尽上自己的所能，相信疫情肯定会慢慢控制下来，请相信我们的国家。 观察了几天，从数据上来看，可能有这么两个好消息： <img src="https://cdn.cuiqingcai.com/2020-02-09-133307.png" alt="image-20200209213305882"></p>
                  <ul>
                    <li>一个是现在总的治愈人数已经超过死亡人数接近三倍，而且治愈人数的每日增长速度已经远超过死亡人数，比如今天的治愈人数就已经是死亡人数的大约 10 倍（891：90）。而且现在疫苗已经投入临床试验，相信接下来的治愈数据的增长液会越来越快。</li>
                    <li>新增的确诊和疑似人数出现缓和和下降迹象，至少从最近四天的数据上来看，能看出新增数量整体呈现下降的态势，今天刚刚也有新闻报道说全国除湖北外其他省份每日报告的确诊病例数从 2 月 3 日 890 例下降到 2 月 8 日的 509 例，下降幅度达到 42.8%，这表明各地联防联控机制以及严格管理等防控措施正在发挥作用。希望前几天数据最高的点，就是那个拐点吧。</li>
                  </ul>
                  <p>加油武汉，加油中国！💪</p>
                  <h2 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h2>
                  <p>可能我们大多数人关注更多的是国内的新型冠状病毒。但现在，美国其实也不太平。美国正在遭受近 10 年来最严重的流感疫情。 看图，这是美国疾病控制与预防中心网站上的流感活动地图，现在是 2 月 9 日周日，数据的统计是每周一次更新，当前更新到 2 月 1 日，数据来源链接见文末。 <img src="https://cdn.cuiqingcai.com/2020-02-09-135555.png" alt="image-20200209215553293"> CDC 称，在其流感活动地图上，美国大部分地区为深红色，表明「流感样疾病」活动水平达到最高级。由于美国的流感季还要持续一段时间，因此这一数据可能会继续上升。从地区上看，目前全美 50 个州里，有 48 个州出现流感疫情，其中 32 个州流感活动水平维持高位，人口稠密的纽约、华盛顿和加州无一幸免，纷纷中招。此次流感季将是 10 年来美国最严重的流感季之一，2019 - 2020 流感季中，美国 1900 万人感染流感，至少 1 万人死亡，包括 68 名儿童。预计流感季将持续至 5 月，而 2 月是高峰期。 我有几个亲戚朋友现在就住在美国，因为流感的问题，每天他们也是和我们一样，待在家里不敢出门，同样体会出来了 ”隔离“ 的滋味。</p>
                  <h2 id="澳洲"><a href="#澳洲" class="headerlink" title="澳洲"></a>澳洲</h2>
                  <p>澳洲最近同样也不太平。 之前大家可能有听说澳洲大火的消息，其实关于澳洲大火的报道，去年 10 月份开始就有了，本来大家以为只是一场普通的森林火灾，扑灭就完事了。我看最近有报道澳洲大火的消息的时候，很多人在底下评论，大火一直在烧啊？没错，这大火一直烧，四个月了，烧的时候澳洲的卫星地图状况就是这个样子： <img src="https://cdn.cuiqingcai.com/2020-02-09-141721.jpg" alt="img"> 这场火，不仅造成人命伤亡及经济损失，也对自然生态带来毁灭性破坏，使数亿动物遭遇灭顶之灾。已有近 5 亿只动物死于澳洲山火，并据相关报道显示考拉或将功能性灭绝。悉尼大学发布报告，全国约有 10 亿动物被大火波及，其中仅在澳大利亚袋鼠岛的大火中就有超 2 万只考拉死亡，考拉将被列为濒危动物。澳大利亚全境被烧毁的森林面积约 1120 万 公顷，而去年震惊世界的亚马孙雨林大火烧毁森林面积才约 180 万公顷。此外，有 1400 多公里的海岸线都在燃烧，相当从东北烧到了江浙沪。 慢慢地，前几天，山火逐渐逼近了堪培拉。1 月 31 日，因为山火的步步紧逼，澳大利亚政府宣布堪培拉进入紧急状态，这是自 2003 年山火危机之后 17 年以来，堪培拉首次进入紧急状态。2 月 2 日整天，堪培拉均处于高度戒备状态。堪培拉和周边地区的气温一度超过 42 摄氏度。 当时堪培拉就是这么一个状态： <img src="https://cdn.cuiqingcai.com/2020-02-09-142308.png" alt="image-20200209222306881"> 其他的地区山火基本是这么一个状态： <img src="https://cdn.cuiqingcai.com/2020-02-09-142602.jpg" alt="img"> 以及那些被烧死的无辜的动物们： <img src="https://cdn.cuiqingcai.com/2020-02-09-142729.jpg" alt="img"> 澳大利亚的这场大火也对全球造成了影响。欧洲哥白尼大气监测服务发表数据：澳大利亚已经向大气排放约 4 亿吨二氧化碳，这个数据比全球 116 个二氧化碳排放量最低国家年排放量总和还要高。 不过，就在最近几天，现在澳洲的山火由于一场暴雨的到来，很多地区的火已经灭了。但，这还没完，由于雨过大，洪水又来了。 据《每日邮报》2 月 9 日报道，近日，澳大利亚遭遇了十年来最大降雨，东海岸被大规模破坏，悉尼正在全力应对洪水爆发，火车站都变成了游泳池。澳大利亚气象局预计，在新南威尔士州北部的一些气象站在 48 小时内录得超过 300 毫米的降雨后，降雨将持续到周日。 据报道，周六，在新南威尔士州北部，67 岁的吉尔·萨瑟兰和她 30 岁的侄女汉娜驱车前往位于新南威尔士州北部河流地区的宁宾，途中他们穿过了一条被洪水淹没的道路。然而，他们很快就失去了对汽车的控制，车子灌满了水，沉了下去，完全从视线中消失了。 <img src="https://cdn.cuiqingcai.com/2020-02-09-143813.png" alt="image-20200209223811908"> 但好在，大火已经基本停了，但愿这次洪水也能尽快过去，祝好！</p>
                  <h2 id="巴西"><a href="#巴西" class="headerlink" title="巴西"></a>巴西</h2>
                  <p>当地时间 1 月 26 日，巴西东南部因受强风暴雨影响，正在遭遇百年不遇的泥石流灾害。 暴雨接连两日肆虐米纳斯吉拉斯州，导致多处房屋倒塌，道路摧毁，很多生命瞬间流逝。到目前为主，此次灾情至少已造成 46 人死亡，超过 25000 人流离失所。巴西国家气象研究所表示，这是自 110 年前开始有纪录以来，本地区降下的最猛烈暴雨。 <img src="https://cdn.cuiqingcai.com/2020-02-09-144450.png" alt="image-20200209224448748"> 军队现已对山区的村镇与交通设施展开全力救助，巴西政府也声称将努力建立一个全国性的灾害预防和早期预警系统。</p>
                  <h2 id="波兰、丹麦"><a href="#波兰、丹麦" class="headerlink" title="波兰、丹麦"></a>波兰、丹麦</h2>
                  <p>1 月 23 日，波兰海关总署发布消息。1 月 7 日，波兰官方向世界动物卫生组织通报，2019 年 12 月 31 日至 2020 年 1 月 4 日，该国卢布林省和大波兰省发生 8 起 H5N8 亚型高致病性禽流感。波兰是欧洲最大的家禽生产国，自 2017 年以来从未爆发过禽流感。 1 月 30 日，丹麦环境和食品部向 OIE 紧急报告称，丹麦发生一起 H5N1 型低致病性禽流感疫情。本次疫情于 1 月 29 日得到确认，此次疫情可能导致多达 4 万只禽类被宰杀，方圆 3 公里多达 35 万只家禽受到威胁。 <img src="https://cdn.cuiqingcai.com/2020-02-09-145504.jpg" alt="img"></p>
                  <h2 id="法国、西班牙"><a href="#法国、西班牙" class="headerlink" title="法国、西班牙"></a>法国、西班牙</h2>
                  <p>1 月 21 日，西班牙东北部地区遭强暴风和大雪袭击，供电中断，几十万人无电可用，暴风和大雪至少已造成 4 人死亡。阿联酋《宣言报》22 日报道称，由于暴风和降大雪，能见度很低，气温急速下降，达到结冰的程度，地中海沿岸海浪急剧上升。 西班牙紧急部门的报告表示，虽然与法国之间的供给线得到了修复，但因为积雪覆盖了 2600 多公里的道路，交通受阻，供电难以解决，位于东北部的吉罗纳省 22 万居民仍然没有电可用。 <img src="https://cdn.cuiqingcai.com/2020-02-09-145710.png" alt="image-20200209225709188"></p>
                  <h2 id="土耳其"><a href="#土耳其" class="headerlink" title="土耳其"></a>土耳其</h2>
                  <p>土耳其内政部 1 月 25 日消息称，24 日晚发生在该国东部埃拉泽省的 6.8 级地震已经造成 22 人死亡，超过 1000 人受伤。 据土耳其阿纳多卢通讯社报道，土耳其内政部部长索伊卢 25 日在新闻发布会上表示，埃拉泽省在地震中的死亡人数为 18 人，其邻省马拉提亚省死亡人数为 4 人。政府派出的救援队已从倒塌的房屋和建筑物的废墟中救出 39 人。 <img src="https://cdn.cuiqingcai.com/2020-02-09-150519.png" alt="image-20200209230517249"></p>
                  <h2 id="利比亚"><a href="#利比亚" class="headerlink" title="利比亚"></a>利比亚</h2>
                  <p>根据俄罗斯卫星通讯社开罗 1 月 14 日的报道，利比亚冲突各方停火问题谈判 13 日在莫斯科举行，俄土两国代表参加了谈判。 然而利比亚战火和谈失败，双方陷入了僵局。土耳其出兵面临全面内战永久分裂风险。 <img src="https://cdn.cuiqingcai.com/2020-02-09-150608.png" alt="image-20200209230607701"></p>
                  <h2 id="苏丹"><a href="#苏丹" class="headerlink" title="苏丹"></a>苏丹</h2>
                  <p>1 月 14 日下午，苏丹发生政变，安全部门和军方在首都喀土穆机场附近发生激烈对峙，并伴有阵阵枪声。 <img src="https://cdn.cuiqingcai.com/2020-02-09-150849.png" alt="image-20200209230847784"> 军方戒严了城区主要街道，喀土穆国际机场已关闭。中国驻苏丹使馆发出安全警告，提醒中国公民不要靠近机场区域。</p>
                  <h2 id="也门"><a href="#也门" class="headerlink" title="也门"></a>也门</h2>
                  <p>1 月 19 日，也门西部一个军事训练营遭遇袭击，造成数十名也门政府军士兵死亡，至少 100 人受伤，胡塞武装在马里布市发动了大规模伤亡袭击，命令也门军队必须保持高度戒备，做好战斗准备。 <img src="https://cdn.cuiqingcai.com/2020-02-09-150959.png" alt="image-20200209230958809"></p>
                  <h2 id="印尼"><a href="#印尼" class="headerlink" title="印尼"></a>印尼</h2>
                  <p>印尼国家抗灾署 6 号通报，首都雅加达和周边地区日前遭遇的洪灾，已造成 67 人死亡。 <img src="https://cdn.cuiqingcai.com/2020-02-09-151243.jpg" alt="img"> 印尼国家抗灾署发言人阿古斯在一份声明中说，截至当地时间 6 日下午，灾害还造成 1 人失踪，另有 3.6 万人居住在临时避难所。由于强降雨引发洪灾、山体滑坡等灾害，雅加达周边的 12 个县市已陆续宣布进入为期一到两周的紧急状态，以便救援和物资运输工作展开。</p>
                  <h2 id="东非"><a href="#东非" class="headerlink" title="东非"></a>东非</h2>
                  <p>东非近期爆发蝗灾，这被称为 70 年来最严重的沙漠蝗灾，其中肯尼亚受灾最为严重，数亿只蝗虫在肯尼亚境内肆虐。 据联合国估计此次蝗虫数量达 3600 亿只，且数量可能在数月后暴增 500 倍。非常令人惊恐的是沙漠蝗群一天内可以吃掉能养活 2500 人的粮食，这也令当地出现了严重的粮食危机。蝗群密度一般达到每平方公里 1.5 亿只，蝗群一天可以随风飞行 100 至 150 公里，破坏范围及力量惊人。 <img src="https://cdn.cuiqingcai.com/2020-02-09-152055.png" alt="image-20200209232054576"> 联合国粮食及农业组织已经发出警告，蝗灾将会造成近年来罕见的粮食危机，1900 万人将面临危及生命的饥荒。 这个确实非常严重的，一些更详细的报道大家可以了解澎湃新闻报道的视频：<a href="https://www.thepaper.cn/newsDetail_forward_5758503，真的难以想象" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_5758503，真的难以想象</a>。</p>
                  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
                  <p>总的来说，全世界的 2020 开局的确可以说是不怎么太平。仔细想想，这些现象的发生有天灾，有人祸。除了一些政治上的问题，这些灾难其实来源于人们对大自然的过渡攫取，或者说是对野生动物的滥杀和捕食。 多难兴邦，天灾无情人有情。在大自然的面前，我们显得非常渺小，在灾难的面前，我们都是受害者。这时候就需要我们团结一心，站在一个战线上去把这些困难渡过去，而不是在这个节骨眼上发国难财，造谣传谣。像我们之前非典、汶川地震一样，众志成城，再难我们也能挺过去的。 相信我们的国家，相信世界的人们。 加油武汉，加油中国，加油全世界！</p>
                  <h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2>
                  <ul>
                    <li>本文选题和主要参考来源：2020 年只过去了一个月，全世界正在发生什么？<a href="https://mp.weixin.qq.com/s/V1iioQsuYITpFfRijZkQHw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/V1iioQsuYITpFfRijZkQHw</a></li>
                    <li>卫健委：全国除湖北外其他省份确诊病例下降超 40% <a href="http://news.sina.com.cn/c/2020-02-09/doc-iimxxstf0048640.shtml" target="_blank" rel="noopener">http://news.sina.com.cn/c/2020-02-09/doc-iimxxstf0048640.shtml</a></li>
                    <li>美国 4 个月近 2000 万人感染流感 今年或是 10 年来最严重 <a href="https://www.codingsky.com/news/2020-02-08/11567.html" target="_blank" rel="noopener">https://www.codingsky.com/news/2020-02-08/11567.html</a></li>
                    <li>Weekly U.S. Influenza Surveillance Report <a href="https://www.cdc.gov/flu/weekly/index.htm#ILIActivityMap" target="_blank" rel="noopener">https://www.cdc.gov/flu/weekly/index.htm#ILIActivityMap</a></li>
                    <li>澳洲遭十年最大暴雨，悉尼全力应对洪水爆发 <a href="https://new.qq.com/rain/a/20200209A06URA" target="_blank" rel="noopener">https://new.qq.com/rain/a/20200209A06URA</a></li>
                    <li>巴西遭创纪录暴雨肆虐 泥石流冲毁房屋 <a href="http://www.chinanews.com/m/tp/hd/2020/0126/134972.shtml" target="_blank" rel="noopener">http://www.chinanews.com/m/tp/hd/2020/0126/134972.shtml</a></li>
                    <li>也门政府军遭胡塞武装导弹袭击至少 40 人死亡 <a href="http://www.xinhuanet.com/mil/2020-01/19/c_1210444134.htm" target="_blank" rel="noopener">http://www.xinhuanet.com/mil/2020-01/19/c_1210444134.htm</a></li>
                    <li>苏丹安全部门和军方在喀土穆机场附近激烈对峙 <a href="https://news.sina.cn/gj/2020-01-15/detail-iihnzhha2484546.d.html" target="_blank" rel="noopener">https://news.sina.cn/gj/2020-01-15/detail-iihnzhha2484546.d.html</a></li>
                    <li>67 人死亡 1 人失踪 印尼洪水灾情严重 <a href="http://news.cri.cn/20200107/235b849d-523f-b512-c6d4-4feacd8347f4.html" target="_blank" rel="noopener">http://news.cri.cn/20200107/235b849d-523f-b512-c6d4-4feacd8347f4.html</a></li>
                    <li>东非遭 70 年来最严重蝗灾，情况或将恶化 <a href="https://www.thepaper.cn/newsDetail_forward_5758503" target="_blank" rel="noopener">https://www.thepaper.cn/newsDetail_forward_5758503</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-02-10 01:33:41" itemprop="dateCreated datePublished" datetime="2020-02-10T01:33:41+08:00">2020-02-10</time>
                </span>
                <span id="/8889.html" class="post-meta-item leancloud_visitors" data-flag-title="2020 才过去了一个多月，世界都发生了些什么" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>4.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>4 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8811.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8811.html" class="post-title-link" itemprop="url">Kubernetes 批量部署 Splash 服务</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>做爬虫的小伙伴可能听说过 Splash，它可以提供动态页面渲染服务，如果我们要爬的某些页面是 JavaScript 渲染而成的，此时我们直接用 requests 或 Scrapy 来爬是没法直接爬到的，此时我们可以借助于 Splash 来帮我们把 JavaScript 渲染后的真实页面结果拿下来。 不过 Splash 在大批量爬虫使用的时候坑不少，Splash 可能用着用着可能就内存炸了，如果只是单纯启 Docker 服务又不好 Scale，另外也不方便当前服务的使用状态，比如内存占用、CPU 消耗等等。 最近把 Splash 迁移到了 Kubernetes 上面，正好上面的问题就一带解决了。 我们既可以方便地扩容，又可以设置超额重启，又可以方便地观察到当前服务使用情况。 下面简单记录一下我把 Splash 迁移到 Kubernetes 上面的过程，真的迁移过来之后省了很多麻烦，推荐大家也可以试试。 好，下面正式开始介绍。</p>
                  <h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2>
                  <p>首先，我们需要有一个 Kubernetes 集群，可以自己搭建，也可以使用 Minikube 或者用阿里云、腾讯云、Azure 等服务商直接提供的 Kubernetes 服务。 另外我们需要能使用 <code>kubectl</code> 连接和控制当前的集群，同时需要安装好 <code>helm</code> 并配置好 stable 版本的 Charts，在这里我使用的是 Helm 2.x。 在这里列一些参考资料：</p>
                  <ul>
                    <li>搭建 Kubernetes 集群：<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a></li>
                    <li>Minikube：<a href="https://kubernetes.io/zh/docs/setup/learning-environment/minikube/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/setup/learning-environment/minikube/</a></li>
                    <li>Helm V2 安装和使用：<a href="https://v2.helm.sh/docs/" target="_blank" rel="noopener">https://v2.helm.sh/docs/</a></li>
                    <li>Charts：<a href="https://github.com/helm/charts" target="_blank" rel="noopener">https://github.com/helm/charts</a></li>
                  </ul>
                  <p>上面的内容准备就绪之后，我们就可以开始 Kubernetes 搭建 Splash 服务的流程了。</p>
                  <h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2>
                  <ul>
                    <li>创建 NameSpace</li>
                    <li>创建 Service</li>
                    <li>创建 Deployment</li>
                    <li>安装 Ingress Controller</li>
                    <li>配置域名解析</li>
                    <li>配置 Authentication</li>
                    <li>配置 HTTPS</li>
                  </ul>
                  <p>上面就是本节所要介绍的基本内容，下面我们开始吧。</p>
                  <h2 id="创建-NameSpace"><a href="#创建-NameSpace" class="headerlink" title="创建 NameSpace"></a>创建 NameSpace</h2>
                  <p>首先我们将 Splash 安装在一个独立的 Namespace 下面，名字就叫做 splash 吧。 yaml 内容如下：</p>
                  <figure class="highlight dts">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">apiVersion:</span> v1</span><br><span class="line"><span class="symbol">kind:</span> Namespace</span><br><span class="line"><span class="symbol">metadata:</span></span><br><span class="line"><span class="symbol">  name:</span> splash</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就声明了一个 NameSpace，名字叫做 splash。</p>
                  <h2 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h2>
                  <p>Service 的创建也很简单，我们注意声明好 namespace 和端口等信息即可：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">splash</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">splash</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">splash</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"8050"</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8050</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8050</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">splash</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> <span class="string">&#123;&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里选择了端口号 port 8050，即服务运行的端口为 8050。targetPort 也是 8050，这个代表 Pod 里面容器的运行端口。另外声明了 labels 和 selector 的内容，大家可以稍作了解。</p>
                  <h2 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h2>
                  <p>接下来，就是最关键的了，我们使用 scrapinghub/splash 这个 Docker 镜像来创建一个 Deployment，yaml 文件如下：</p>
                  <figure class="highlight less">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">apiVersion</span>: apps/v1</span><br><span class="line"><span class="attribute">kind</span>: Deployment</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">app</span>: splash</span><br><span class="line">  <span class="attribute">name</span>: splash</span><br><span class="line">  <span class="attribute">namespace</span>: splash</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">replicas</span>: <span class="number">3</span></span><br><span class="line">  <span class="attribute">selector</span>:</span><br><span class="line">    <span class="attribute">matchLabels</span>:</span><br><span class="line">      <span class="attribute">app</span>: splash</span><br><span class="line">  <span class="attribute">revisionHistoryLimit</span>: <span class="number">1</span></span><br><span class="line">  <span class="attribute">strategy</span>: &#123;&#125;</span><br><span class="line">  <span class="attribute">template</span>:</span><br><span class="line">    <span class="attribute">metadata</span>:</span><br><span class="line">      <span class="attribute">labels</span>:</span><br><span class="line">        <span class="attribute">app</span>: splash</span><br><span class="line">    <span class="attribute">spec</span>:</span><br><span class="line">      <span class="attribute">containers</span>:</span><br><span class="line">        - <span class="attribute">image</span>: scrapinghub/splash</span><br><span class="line">          <span class="attribute">name</span>: splash</span><br><span class="line">          <span class="attribute">ports</span>:</span><br><span class="line">            - <span class="attribute">containerPort</span>: <span class="number">8050</span></span><br><span class="line">          <span class="attribute">resources</span>:</span><br><span class="line">            <span class="attribute">requests</span>:</span><br><span class="line">              <span class="attribute">memory</span>: <span class="string">"1Gi"</span></span><br><span class="line">              <span class="attribute">cpu</span>: <span class="string">"1"</span></span><br><span class="line">            <span class="attribute">limits</span>:</span><br><span class="line">              <span class="attribute">memory</span>: <span class="string">"4Gi"</span></span><br><span class="line">              <span class="attribute">cpu</span>: <span class="string">"4"</span></span><br><span class="line">      <span class="attribute">restartPolicy</span>: Always</span><br><span class="line"><span class="attribute">status</span>: &#123;&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里也有几个比较关键的点：</p>
                  <ul>
                    <li><code>metadata.labels</code>：这里需要和 Service 里面的 selector 对应起来。</li>
                    <li><code>spec.template.spec.containers[]</code>：这里声明 splash 的镜像，用的是 latest 镜像 scrapinghub/splash；端口地址用的 8050；restartPolicy 使用的是 Always，这样 Splash 如果崩溃了会自动重启；resources 设置了使用的内存和 CPU 的请求和限制值，这里大家可以根据机器和爬取需求自行修改。</li>
                    <li><code>spec.replicas</code>：运行的实例个数，这里设置为了 3，这样就会启动 3 个 Splash ，Service 会对其负载均衡。</li>
                  </ul>
                  <p>好了，写了上面三个 yaml，我们可以将其合并到一个 yaml 文件里面，如 <code>deployment.yml</code>，然后执行：</p>
                  <figure class="highlight coq">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">kubectl <span class="built_in">apply</span> -f deployment.yml</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以观察到 NameSpace、Service、Deployment 都创建成功了，Pod 随之也创建成功了。 <img src="https://cdn.cuiqingcai.com/2020-01-29-131028.png" alt="image-20200129211026981"></p>
                  <h2 id="安装-Ingress-Controller"><a href="#安装-Ingress-Controller" class="headerlink" title="安装 Ingress Controller"></a>安装 Ingress Controller</h2>
                  <p>接下来我们想要配置一个域名解析，并配置好 HTTPS。 首先我们需要安装 Ingress，这里我们使用 Helm 2.x 安装，使用的 Charts 为：<a href="https://github.com/helm/charts/tree/master/stable/nginx-ingress" target="_blank" rel="noopener">https://github.com/helm/charts/tree/master/stable/nginx-ingress</a>。 这里我们稍作修改，指定 NameSpace 和镜像即可：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">helm install --name ingress-splash --namespace splash --<span class="builtin-name">set</span> defaultBackend.image.<span class="attribute">repository</span>=mirrorgooglecontainers/defaultbackend-amd64 stable/nginx-ingress</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们将镜像修改了一下，避免国内 Kubernetes 无法拉取镜像的问题。 OK，安装好了之后，可以看到 Ingress Controller 就安装成功了。</p>
                  <h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2>
                  <p>域名解析就好配置了，直接将域名配置到 Ingress Controller Service 的 External IP 上面即可。 <img src="https://cdn.cuiqingcai.com/2020-01-29-131156.png" alt="image-20200129211154610"></p>
                  <h2 id="配置-Authentication"><a href="#配置-Authentication" class="headerlink" title="配置 Authentication"></a>配置 Authentication</h2>
                  <p>Splash 部署完了之后，默认是没有 Authentication 的，如果直接暴露在公网中，是可以被他人直接使用的。 所以我们需要对其配置 Authentication，并配置 Ingress 域名解析。 这里 Authentication 我们使用 HTTP Basic Auth 就好了，要配置这个，我们需要先新建一个 Secret。 那么 Secret 怎么创建呢，我们先用 htpasswd 生成一个秘钥文件，用户名为 splash：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">htpasswd -c auth splash</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>执行完了之后本地会生成一个 auth 文件，我们用这个 auth 文件创建一个 Secret 即可：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">kubectl create<span class="built_in"> secret </span>generic basic-auth <span class="attribute">--from-file</span>=auth --namespace splash</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样 Secret 就创建好啦，用户名就是 splash，密码就是刚才创建秘钥文件时输入的密码。 上面更详细的介绍参见：<a href="https://kubernetes.github.io/ingress-nginx/examples/auth/basic/" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx/examples/auth/basic/</a> 好，然后我们创建 Ingress。 新建 ingress.yml 文件内容如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-splash</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">splash</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-type:</span> <span class="string">basic</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-secret:</span> <span class="string">basic-auth</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-realm:</span> <span class="string">'Authentication Required'</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&lt;domain&gt;</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">splash</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">8050</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 <code>metadata.annotations</code> 里面声明了三个选项，就是设定 HTTP Basic Auth 的。 注意这里 <code>spec.rules[].host</code> 的内容换成自己的域名。 好，然后执行即可：</p>
                  <figure class="highlight coq">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">kubectl <span class="built_in">apply</span> -f ingress.yml</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>OK，这样 Ingress 也创建好啦。 现在我们只需要访问 <code>http://&lt;domain&gt;</code> 即可访问到 Splash 服务啦。 初次访问需要输入用户名和密码，如图所示。 <img src="https://cdn.cuiqingcai.com/2020-01-29-133031.png" alt="image-20200129213029854"> 登录完成之后就可以看到 Splash 的界面了，如图所示。 <img src="https://cdn.cuiqingcai.com/2020-01-29-132037.png" alt="image-20200129212035193"></p>
                  <h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2>
                  <p>这时候整个 Endpoint 是 HTTP 协议，会被提示不安全，如果我们想要配置 HTTPS，还需要申请一个证书。 证书可以到阿里云、腾讯云等等服务商申请即可。 申请完了，我们可以得到 crt 和 key 两个文件。 接下来我们首先需要配置一个 tls 类型的 Secret，命令如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">kubectl create<span class="built_in"> secret </span>tls tls-splash -n splash --cert &lt;cert_name&gt;.crt --key &lt;cert_name&gt;.key</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 <code>&lt;cert_name&gt;</code> 替换成你申请的证书文件名即可。 这样我们就创建了一个名字为 tls-splash 的 Secret，下面我们开始使用。 修改 ingress.yml 文件如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-splash</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">splash</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-type:</span> <span class="string">basic</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-secret:</span> <span class="string">basic-auth</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-realm:</span> <span class="string">'Authentication Required'</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&lt;domain&gt;</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-splash</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&lt;domain&gt;</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">splash</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">8050</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里主要修改的点有两个，一个是增加了 ssl 重定向，这样如果我们以 HTTP 访问过去，就会被跳转到 HTTPS 的地址。另外就是 <code>spec.tls</code> 字段了，这里声明 hosts 和 secretName 即可。 OK，重新应用：</p>
                  <figure class="highlight coq">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">kubectl <span class="built_in">apply</span> -f ingress.yml</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>大功告成，现在我们就可以使用 <code>https://&lt;domain&gt;</code> 来访问我们的 Splash 服务了。</p>
                  <h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>
                  <p>最后，输入个网址测试下吧，如百度，渲染成功，如图所示。 <img src="https://cdn.cuiqingcai.com/2020-01-29-133132.png" alt="image-20200129213130109"> 以上，便是 Kubernetes 搭建 Splash 的方法。 希望对大家有帮助。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-01-29 23:54:06" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:06+08:00">2020-01-29</time>
                </span>
                <span id="/8811.html" class="post-meta-item leancloud_visitors" data-flag-title="Kubernetes 批量部署 Splash 服务" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>5.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>5 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8808.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8808.html" class="post-title-link" itemprop="url">2019 年终总结：新生活、新探索</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>2020 年的新年过去了，去年也是在春节期间写的年终总结，今年也是时候再总结和反思一下我的 2019 年了。 总的来说，2019 我给自己的一句话总结为：新生活、新探索。 今年是我从学生时代正式迈入职场的第一年，也是体验了新的生活环境的第一年，没有预想到的变化有很多，接触的新的挑战也很多。这一年，我也在努力调整自己，去适应新的工作环境和生活节奏。但今年自己达成的面上的成就不算多，更多的时间在于学习、自我适应和调整，同时一年里我也有了一些新的感悟。 所以，在此把我这一年的变化、思考和新一年的目标做一下总结，希望来年可以继续加油。</p>
                  <h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2>
                  <h3 id="第一次正式工作"><a href="#第一次正式工作" class="headerlink" title="第一次正式工作"></a>第一次正式工作</h3>
                  <p>2019 年 1 月份，我硕士毕业了，接下来就正式开始工作了。2019 年 3 月 1 日，我正式入职微软，在微软小冰部门，我换了一个新的小组，有了一群 Nice 的新同事。 我的工作的内容属于 AI Creation，不过偏全栈一点，会涉及到自然语言处理、图像处理、前端、后端等各个方面的技术。正式入职之后，我负责小组的这一个全新的探索方向。 怎么说呢？刚开始我接手这个项目的时候，基本上整个项目还是在实验阶段，我要做的就是把整个项目规范化、搭建一套完整的 End2End 的 Pipeline、检测模型、管理平台和服务器。我之前在实习阶段的时候没有接触过线上代码，不了解现在代码的一些逻辑和架构。所以刚开始的时候面对一些杂乱的实验数据、设计草稿、线上代码，面对这些一些需求，一段时间内真的是感觉不知道怎么办才好。那会儿我记得一直在梳理思路，在一点点 Debug 现有的代码的一些逻辑，然后和我的 Manager 和同事一起讨论实现的思路。 慢慢地，我逐渐也清楚了现有的代码和架构，知道了我可以具体怎么实现，期间我把自己的一些设计思路改了好几次，比如我记得有好几个 Pipeline 拆了又拆，有一些设计 Schema 改了好几次，最后慢慢稳定下来了，渐渐地，我把一些模型、Pipeline、管理平台、服务器慢慢搭建好了，现在我做的一些东西也上线并正式投入使用了。回想起来，刚开始真的挺难的，不过现在做成了，还是很有成就感的。 在这里真的要好好感谢我的 Manager 和同事们，他们对我的帮助很大。在讨论项目实现的过程中，我收获了很多新的想法。我承认我自己这个人并不是特别喜欢与人合作，倾向于坚持自己的想法，倾向于自己去把一件事去做完，所以我最开始可能更偏己见一点。但在讨论整个项目的过程中，我学到了，有些思路原来还可以这么想，原来还可以这么实现。真的，有些设计思路和想法我确实一开始没有想到，但经过讨论之后，确实学习到了很多技巧和方法，慢慢地，我的一些编程的思想也有了变化，我会有自己的想法，同时也倾向于把我的一些思路说给别人，看看别人怎么想的，在大多数情况下，我会想到更优的解决思路，即使没有，我也学到了一些新的思考方法或者知识点。另外在这期间，我的小组队伍也壮大了起来，我自己也作为小组长（算是）指导了几位新同事一起参与整个项目，在这期间我也悟到了一些合作或指导的一些经验，大家都非常给力，目前来说还是很不错的。 要说这一年的工作压力和强度的话，整个走下来其实还是不小的。在前期阶段，其实更多来自于项目本身的压力，因为有太多的东西需要做，同时需要学习和了解的新东西也有很多，当时也没有找到适合自己的工作节奏，算是“摸爬滚打”了好一阵。在后期阶段，也有一些新的挑战，比如要去思考哪些方向是对的，怎样和同事更好地协作一起优化一些功能点，当然也一直有新的技术需要学习。整体感觉上来，比我的实习期的工作强度大了非常非常多，可以说和实习期的工作强度是没法比的。 现在想想，实习的时候，我差不多半年时间写完了一本爬虫书，晚上还能和我的小伙伴们聚众开黑王者荣耀。现在？功能实现了吗？Bug 修完了吗？好了，滚去撸代码了。写书？开黑？一天，一晃就这么过去了。</p>
                  <h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3>
                  <p>正式工作之后，发现自己打理公众号的时间比我预想中的要紧张许多，没错就是这个「进击的Coder」。 对于公众号的运营，我也慢慢地佛系了，在 2019 快年底的时候，我把我的公众号转给我的女朋友小马来运营了，不得不说她运营得非常好，会找一些很不错的技术文章帮我排版，帮我发布，我有原创文章我也会交给她帮我发一下，的确减轻了我不少的压力。她也有很多想法，写了一些原创，也会策划一些活动，后来，不少公众号的粉丝居然渐渐转成她的粉丝了？！我回来后，你们还认识我吗？ 说一下数据吧，写文章时，公众号粉丝数量为 <strong>57420</strong>，常读用户是 <strong>9857</strong>，平均阅读 <strong>3000</strong> 左右，算是技术号中比较普通的水平了，常读用户比例也不怎么高，而且对于我 2019 年的 Flag 10 万，还有挺大的差距，这个后文会详细说。 说说公众号这件事吧，为什么我这次单独把「常读用户」数据放出来了呢？因为现在其实粉丝数并不是那么重要的，常读用户才是更重要的。公众号在 2019 年做了一次大的改动，「信息流」是其一，「在看」是其二，另一个大的改动就是有了「常读的订阅号」这个功能，大家应该也都注意到了，它会出现在最上端，几个圆形的公众号头像，如果公众号有了消息，它会有一个绿色的小点，大多数情况下，然后我们就会点开看了，可以说对阅读量的帮助是很大的。对于信息流来说，如果我们发文的时机把握不好的话，很可能文章就会被冲淡在信息流里面再也找不见了。所以，常读用户的多少和阅读量有着很大的关系。这也是有一些公众号虽然粉丝很多，但是阅读量并不高的很大原因；同时也是一些公众号虽然粉丝少，但是阅读量一直很高的很大原因。 「在看」功能也是很重要的，当然这取决于文章质量了，如果文章质量高，「在看」多，大家从「朋友在看」入口进入到文章的的人也越多，阅读量自然也会高。 另外还有原创，大家可以看到很多原创率高的号主，阅读量都是很高的，因为原创，内容独特，见解到位，他们的公众号常读用户量和常读用户比率一般都是非常高的，阅读量自然就高了。另外公众平台对于原创也有一定的鼓励和推荐机制，帮助原创号主获得更多的流量。另外现在我观察到技术公众号的一个趋势，就是很多文章都转来转去，大多数公众号的原创率都是很低的，另外广告现在也越来越多（我也参与了），读者又不是傻子，在筛选一篇优质公众号文章越来越难的今天，读者会倾向于阅读原创率高或内容优质的公众号。那些没有原创能力或者内容质量不高的公众号，阅读量增长会非常困难，甚至于淹没于越来越大的公众号海洋之中。 所以，现在运营公众号，最重要的数据是什么？最直接的当然是平均阅读量，这可能直接关乎一个公众号值多少钱或者接到的广告值多少钱。平均阅读量更多取决于什么？「常读用户」和「在看」。所以一方面，我在运营的时候会更注意公众号的发文质量和频率，一定不能长时间不更新，否则万一公众号从「常读的订阅号」列表里面掉出去，就很难找回来了。另外我对于粉丝量其实并没有那么看重了，所以我也很少去参与互推的一些活动。 2019 年我发的文章一部分是原创的技术文，要写的话我会写好，把一些来龙去脉和原理都说清楚，保证文章的质量，但由于时间紧张，原创个人感觉发的并不多。另一部分是转载的一些觉得有价值的技术文，我会和小马一起去挑选一些我们认为还不错的技术文或时效新闻发给大家，希望读者能有所收获。最后就是广告了，2019 年接的广告其实说实话不少，当然接广告也基本上是为了恰口饭，如果大家看到了是广告标题，能帮着戳一戳进去加点阅读量我就非常感激不尽了。其他的互推或者抽奖送书等等活动，我很少很少参与了，一方面觉得意义并没有那么大，对读者也不友好。 我觉得公众号专注于提供优质的内容、见解和想法，这才是好的发展路子，我的涨粉速度肯定没有互推来得快，而且确实也因为我的个人原因对公众号精力投入不够，导致阅读量增长比较慢，但我觉得这是适合我的初衷的发展路子，也是我比较舒服的运营方式。所以，接下来我还是秉承的之前的运营理念，公众号的方向还会专注于技术，致力去提供优质的内容给大家。 另外我也有一些新的运营想法。我一直有关注一个公众号叫做「未闻Code」，公号主是「青南」，他是做网络爬虫方向的，也著有很不错的技术书籍，也在维护一个开源项目 GNE，即新闻网页正文通用抽取器，项目地址：<a href="https://github.com/kingname/GeneralNewsExtractor，可以实现新闻页面的自动化抽取，目前已经有" target="_blank" rel="noopener">https://github.com/kingname/GeneralNewsExtractor，可以实现新闻页面的自动化抽取，目前已经有</a> 1k 多个 Star，推荐大家关注下。他的公众号有一个我觉得很不错的运营模式，那就是「一日一技」，他会把一些总结或新学到的技能整理出来发到公众号上，有的文章内容可能并不长，可能就是记录自己学习或踩坑的过程，甚至可能就是一个个小的零碎的知识点，但我感觉还是很有价值的，读者反响也不错。而我之前在写文章的时候，我会必须要把一个知识点扩得很大，把知识点或项目的来龙去脉或者完整的使用流程写一篇长文再发出来，因此大家可以看到我的技术原创文一般都会显得比较完整甚至叫啰嗦，为写这篇文章，我可能要去搜罗各种资料，可能也去新学一些新的东西，这样也致使我写一篇文章耗费的时间也会比较长。所以，我想寻求一个转变，我想，比如某天我在工作中解决了一个什么问题，或者我学到了一个小的骚操作，或者我就学到了一个小的知识点，我想也把它写下来，把这件事稍微说明白就行，暂时不去把所有的涉及这个知识点的的东西完整总结。比如我今天刚学到了 Kubernetes 在部署时动态替换环境变量的骚操作，我就只把这个记录下来，分享给大家，不再去展开讲。这样可以提高我的产量，同时把我今天学到的或想法写下来与大家分享，可能文章比较短，可能知识点描述得不够全，但我觉得是一个不错的路子。后面我会尝试下这个方案，如果得到的反响不错的话，我会继续坚持。</p>
                  <h3 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h3>
                  <p>作为一名程序猿，比起刷抖音，我更喜欢逛 GitHub，同时自己也会喜欢写一些开源项目并发到 GitHub 上面，如果能收获一些 Star，心里会有很大的成就感。 先说一下目前的数据吧，我的 GitHub 地址是：<a href="https://github.com/Germey，目前粉丝数" target="_blank" rel="noopener">https://github.com/Germey，目前粉丝数</a> 4.9k，收获 Star 数约 4k，2019 年 Commits 数量 1053 次，目前主要维护了 Gerapy 和 ModelZoo 两个项目，还有一些其他的项目如 ProxyPool、CookiesPool 也有一些人在使用。 由于时间问题，2019 年我在开源这一方面的贡献并不好，Gerapy 和 ModelZoo 两个项目也有一段时间的停更，导致现在也一直不瘟不火，Star 数也一直不多。 我觉得能够有自己拿得出手的开源项目确实是一件很有成就感的事情，新的一年，我会投入更多的精力参与到上面来，目前还是会专注于 Gerapy 和 ModelZoo 两个项目上面来。同时随着学习和积累，可能还会酝酿出新的项目。新的一年，继续加油。</p>
                  <h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3>
                  <p>关注我的读者可能知道我在 2018 年 4 月出版了一本《Python3网络爬虫开发实战》，这也是我写的第一本书，其目前销量已经远远超过我的预期，到现在为止不到两年时间，累积印刷 15 次，印刷量 7w 多，豆瓣评分 9.0 分，也已经被很多学校或培训机构当做教材或辅导书，这些都是我之前没有预料到的，同时这本书也为我带来了一笔可观的收入。 但免不了的，讲爬虫，网站不会是一成不变的，网站一改版，整个案例就跑不通了。这本书，现在挺多案例已经过期了，书稿的内容不好直接修改，我只能在 GitHub 上尽量去跟进修改，但对于一些初学者来说，是很不友好的。另外，爬虫技术日新月异，很多技术或框架已经过时了，另外也出现了一些新的技术和知识点，当时在写书的时候并没有提及到。 所以，我去年就跟编辑策划了《Python3网络爬虫开发实战》第二版的撰写。本次第二版相对于第一版来说，修订了过期的案例，补充了新的知识点。第二版为每个知识点的实战项目对接了针对性的练习平台，避免了案例过期的问题。另外主要增加了异步爬虫、JavaScript 逆向、App 逆向、智能网页解析、深度学习识别验证码、Kubernetes 运维及部署等知识点，同时各个爬虫知识点涉及到的请求、存储、解析、测试等工具也进行了丰富和更新。 到现在算是基本完稿了，现在已经在审稿了，但我还想修改和增加一部分内容。比如最近提议出来的修订过期案例的问题，这个问题很重要，不然不知道啥时候我书里的案例就又过期了，为此我自建了爬虫案例平台，项目在这里：<a href="https://github.com/Germey/Scrape，最近忙着迁移和开发，现在正在把一些案例修改到案例平台上面。其他的稿子差不多了，正在审核中。所以基本上我现在是边改边审的状态，也希望能提前出版的时间。我知道有些读者很急，也盼着第二版的出版" target="_blank" rel="noopener">https://github.com/Germey/Scrape，最近忙着迁移和开发，现在正在把一些案例修改到案例平台上面。其他的稿子差不多了，正在审核中。所以基本上我现在是边改边审的状态，也希望能提前出版的时间。我知道有些读者很急，也盼着第二版的出版</a>。 现在没几天就会有读者问我第二版什么时候出版呀？情况，就是上面这个样子，已经开始审稿了，可能还得几个月吧，争取 2020 上半年可以出来，如有消息，我一定第一时间通知大家。 当然写作也不仅仅是写书，也包括日常的积累。 我自己在平时的工作和学习的过程中也会记一些笔记。我现在把我所有的笔记都用 Typora 这个 MarkDown 编辑工具写下来，然后整理和同步到 GitHub 和 GitBook 上面，我分了好几个记事本，有技术类、生活类、书稿类、开源文档类，整理和总结了不少东西，挺多东西并没有公开发出来，原因我也在上文「公众号」一节提及了一下，但我也想寻求一个新的运营方式，所以我准备把一些自己整理的东西，即便是小的知识点，也都发出来，跟大家一起学习和探讨。 不怕被笑话「原来我这个知识点还不会呢」，我新学到的就发出来看。因为只有「改革开放」才能真正地进步，固步自封最终吃亏的还是自己。</p>
                  <h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3>
                  <p>说到知识，今年来我个人觉得学习的还算及格，我学到的知识一方面来自于工作，一方面来自于平时生活。 稍微总结一下今年来都学了些什么吧：</p>
                  <ul>
                    <li>C#、.NET。其实在实习期间我不接触线上代码，C#、.NET 并不常用。正式开始工作了，这个必须学起来了，因为一些 Service 必须要用它来搭。学了之后，确实觉得 C# 设计得真的很棒，很多特性和理念值得好好学习。</li>
                    <li>爬虫逆向。在 2019 年之前，我对爬虫逆向可以说基本不了解，因为在写第一版书那段期间，网站采取混淆或加密的不多，App 抓包基本都能抓得到。后来时代变了，网站现在你没有个混淆，基本就不是个合格的网站，很多 App 接口抓包也搞不到，或者一些接口加了很多加密参数。所以说 JavaScript 逆向和 App 逆向不学基本上就没法玩爬虫了。所以我也在开始学习和了解这一部分的内容，在 2019 下半年加入了夜幕团队，团队有几位搞逆向非常厉害的大佬，同时我们也合作出了一套 JavaScript 逆向课，另一方面也为了写书做准备。总之，收获很大，也非常感谢大家的指导和帮助。但由于这个技术比较敏感，担心发出来被对方寄律师函什么的，所以我也几乎不发文。不过现在我有了新的思路了，自建爬虫案例平台，所以等建好了，我会发一些关于逆向方面的文章的，大家敬请期待。</li>
                    <li>Kubernetes、DevOps。现在 DevOps 和 Kubernetes 基本上可以说是大势了，部署一把梭。在工作中我们也慢慢地把一些服务迁移到 Kubernetes 上面，为此我也自己摸索和搭建过 Kubernetes 集群，搞了一些 Service、数据库的搭建，DevOps 一套主要用 Azure Pipelines、GitHub Actions，是真香！现在我的几乎所有服务都在往 Kubernetes 上面迁，新的爬虫案例平台也用了 GitHub Actions 来实现自动部署。</li>
                    <li>深度学习。在 2019 年之前，我也有一些深度学习的基础，但 2019 年我在实现一些自己的开源项目 ModelZoo 的的时候，又学习了一些新的模型，把 ModelZoo 重新迁移到 TensorFlow 2.0 上面。另外在工作之余也学习了一些新的模型，如序列标注相关、图像识别相关。但最近我又有了新的想法，用了一段时间 TensorFlow 2.0 之后，感觉有些地方实现起来还是别扭，对接了 Keras 之后，调试也还是不太方便。经过与一些大佬的交流，决定准备转 PyTorch 了，这真可能是趋势，不知道我的感觉对不对。但选择比努力更重要吗不是？方向感觉不对，就要及时调整，没毛病。（逃</li>
                    <li>各种开源库。这些也不算系统的知识点了，单纯就是逛 GitHub 看到的，比如一些实用的类库，比如 typing、loguru、retrying、faker、airtest 等等，学了，顺带写一篇总结文，慢慢积累下来。</li>
                  </ul>
                  <p>总的来说，2019 学到的新东西还算不少，慢慢地我也摸清了我的技术路线，现在还会是 Python 主力的全栈方向，将来可能还会变，一些技术栈我会去慢慢补齐，我知道自己哪些不会，为了达成我的一些目标还需要去学什么。 另外在学习过程中，思考和总结是非常重要的。</p>
                  <ul>
                    <li>遇到不会的，多去思考和搜索，实在不行求助别人。</li>
                    <li>解决了问题，记得复盘和梳理下来。</li>
                    <li>学习新知识，顺带把学到的整理和记录下来。</li>
                  </ul>
                  <p>个人觉得这样学习起来，效果还是不错的。新的一年，继续加油。 当然除了技术，我自己也在学一些其他的，比如英语，之前跟小马出去塞尔维亚玩了一趟，英语要么听不懂，要么说不出来，太难受了。现在上班路上，我会抽时间听一点 BBC，用的是网易云。大家都在用啥学英语啊？ 另外理财相关的知识，我也在了解，同时买了点基金试试水，不过我还觉得储备的知识还不够，还需要继续学习。</p>
                  <h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3>
                  <p>这个话题，真的有点让我难以开口。因为这个健身，我真是做的太失败了，我一年几乎没有健身几次，加上吃太好，从 116 斤胖到了 141 斤。141 - 116 = 25，没错，我一年胖了 25 斤！ 一方面，小马带我吃的太好了，哈哈哈哈，我们几乎每周都会出去吃好吃的，另外她还会给我买各种零食和好吃的，家里的零食一箱箱永远吃不完。 有人说了，你胖了这么多，人家小马怎么瘦了呀？别找借口了。偷偷抹眼泪，说好一起变胖呢？ 另一方面，也是不运动，一坐一天，晚上还没啥空去健身房，日积月累，就成了这样子了，照片就不要看了，我不会给你们看的。 说到健身，小马几乎每周都会去跳舞或者去健身房，我偶尔周末会跟着去体验几节课，但是上完之后，在家就没有继续炼了。哎，也是确实没太有时间锻炼，也有一个原因就是太懒了，可能后者才是最主要的原因。 但这样下去我的体重就要收不住了。在年前的时候我立了 Flag，一周运动至少两次，主要是跑步，如果参与了一次健身也算，我成功坚持下来了。年后继续！ 我会变瘦的！ 没想到，短短一年，「减肥」这个词居然会落在了我的身上。</p>
                  <h3 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h3>
                  <p>嘿嘿，我和小马一起从 2018 跨到了 2020，在一起三年了（抖机灵。哈哈，其实我们已经在一起 449 天啦！总之和小马在一起的日子特别开心，以至于幸福肥了 25 斤（逃。 想分享的生活有太多，但是又觉得在这里公开秀恩爱有点不好意思，反正就是很幸福哈哈哈。比如一起出去吃好吃的、一起旅游、一起健身、一起拍照、一起画画、一起插玩具、一起玩游戏、一起去看展、一起穿情侣装。有时候我们一起吃到了好吃的就会一起高呼「卧槽这个好吃，卧槽这个也好吃，卧槽这个怎么这么好吃！」，有时候走在路上两人就像小孩子一样牵着手或者追来追去，有时候好长时间（一天）不见面，我们再见到对方就互相扑过去，我们很多时候会在对方面前表现得像个孩子或者像一只动物（猫？），我们每人的表情包已经全是「猫」和「狗」了，不多，也就一百多套吧。不好意思，不小心又秀了一下。 怎么说呢？我经常会在微博分享我们两人的生活。有人说我的微博已经从「互联网资讯博主」变成了「恋爱博主」，就是这么个感觉。本来我的书里面不是写了一节「Ajax 爬取微博」来教大家怎么学 Ajax 分析和爬取吗，结果大家爬下来了一堆狗粮，之后跟我说再也不学爬虫了。 我：？？？ 嗯，我也不知道他后来有没有再学，可能真的没有再学了吗？ 不过有时候我也会犯蠢，惹小马不开心或生气（但我们不会分手的，我也慢慢地从中学到了很多，我们的感情也变得越来越好了。昨天我看到知乎一个推荐「女生最想收到男生送的什么礼物？」，我看了看这都什么玩意，然后发给了小马，说我要是送你这些肯定会被分手了，小马看完，说我长大了，开心！看我是不是变得越来越懂你了呢。 新的一年，希望我们还会继续好好在一起呀！ 对了，朋友圈和微博没得刷了或者饿了的话，来刷刷我的微博「崔庆才丨静觅」吧（逃。</p>
                  <h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3>
                  <p>关于思考，这是一个非常抽象的东西，看不见摸不着，但确实很多时候，某些事情思考的深度、广度决定了我们的高度。 在这一年来，我接触了很多人，了解了一些事。比如一个技术项目吧，不同的人对于一个项目思考的深度就不同。很多人可能就是，接到了一个任务，别人告诉他要做什么，怎么做，那他就做完就行了，然后就完事了。但有的人，接到这个任务，会首先想，我这是在做什么？为什么要这么做而不是那么做？做的时候怎样实现才是最佳的？做完了还能做点什么才能变得更好？他会对事情的来龙去脉了解的非常清楚，结束了再去复盘和思考。这也是我觉得很多人所欠缺的一些地方。我觉得人和人之间段位的差距就是这么拉开的。 有的人可能会觉得，考虑这么多，找这个麻烦干什么呢？这其实真不是自己找麻烦，思考的成本其实很低，我们用来思考的时间其实很多，比如路上、休息时、吃饭时、睡前等等。不怕思考浪费时间，怕的是不去思考。 我前几天跟一位非常好的朋友吃饭聊天。这位朋友，我真的很佩服他，我觉得他有很多程序员少有的一些思维，他在思考一些事情时会考虑非常全面，就像上文所提到的一样。比如我之前曾经跟他商量一个实现方案，他第一个问我的问题是，为什么你会这么想这么做？你的理由是什么？你打算怎么来实现？只要你能把我说得通，我就支持你这么做。比如一些方法论上的东西，他一直在思考和探索一些适合自己的生活、工作方式，会思考自己想要做什么、为了达成某个目标怎样做最好、怎样才是最佳实践，同时他也在不断的探索和试错中完善自己的方法论。我从他身上学到了很多，同时我觉得我自己跟他还有很大的差距，还是要多多加油啊。 所以，有时候，我们也需要停下来去思考，自己在做什么、为什么要这么做、怎样做最好，甚至需要去思考一下，自己是谁、从哪里来、要到哪里去。</p>
                  <h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3>
                  <p>关于合作，今年我也体会到了很多，我的想法也变了许多。 怎么说呢，我自己原本是一个倾向于单枪匹马挑战一切的人，同时也不想去麻烦别人，比如一件事情，我习惯于包揽下来，自己去完成，有时候不想给别人添麻烦，有时候觉得交给别人不太放心或者担心做出来不符合我的心意。 慢慢地，在团队合作过程中，我意识到了，自己不是全能的，术业总会有专攻，总会有在某一方面比自己强的人。而且随着工作强度的变大，有些事情自己大包大揽真的有点力不从心。 两点体会吧。</p>
                  <ul>
                    <li>第一，一个人并不是万能的。每个人不可能在所有的事情上做到极致，同时一个人的精力也是有限的。几乎没有人能像 Linus 一样几乎单枪匹马做出一个 Linux 内核，但你说 Linux 和杜兰特比打篮球，谁更厉害？</li>
                    <li>第二，总会有人在某个方面强过自己。随着接触的人和事越来越多，我发现就是有人在某个方面比自己强，或者思考的问题深入，或者完成的效果好。所以，首先不要因为某个方面不如别人而感到难过，有些事，可以放心交给别人去做，有时候结果可能甚至远超过自己的预期。当然这个有个前提，确实也得看人，去学会分辨一些靠谱和不靠谱的人。</li>
                  </ul>
                  <p>所以，现在我在工作中，一些功能和需求，我不会再像之前一样倾向于大包大揽，相信自己的一些靠谱的合作伙伴，每个人直接好好分配，合作的时候一起交流、探讨。同时我自己也指导着两位同事，有些任务我会交给他们去做，不会再因为不放心和给别人添麻烦而全把任务归到自己。有时候真的，最终可能还会有意想不到的效果，或者在跟别人交流的过程中学到一些新的东西。 所以，Be Open，这是我的一点体会。</p>
                  <h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3>
                  <p>关于这个，我体会也很深。 我回顾了自己一年以来没有做和已经做的事情，发现了这么一个现象：有件事我确实给自己定目标了，比如我要学习 Go 语言。然后我就把这个加到了我的待做清单里面，没有给他设置时间限度，也没有具体规划我怎样去做，哪个时间去学什么，反而自己的时间被一些零碎的或更紧急的事情占据了，最后我一整年都没有学 Go。我仔细想想，其实也并不是没有时间，有时候，我在某个时间段，确实是完全闲着的，比如我周六的时候，可能会躺在床上玩手机，一玩一上午，但那会啥也不想做，也没想好要那会要做什么。 我反思了一下自己，还是因为自己给自己的规划不明确。 主要有这么两点：</p>
                  <ul>
                    <li>第一，某些目标我设置的太大，没有详细去规划什么时间做什么。比如学 Go 语言，我应该去好好思考一下，我要在多久时间内达成这个目标，我应该什么时间去做什么，我应该去细分到每一章节，在最开始的时候可能没必要所有的都分的那么细，但真正下一步要做的，一定要列得详细再详细。 比如说，我要三个月内学好 Go 语言，我可以先思考，三个月，我要学多少知识模块，比如有十个知识模块，那么我就规划每一个模块大体什么时候完成，每个模块列到自己的 Todo List 里面，设定好期限，注意，一定要设置好期限，不然真的会一拖再拖！然后，最开始我可能没必要把大把的时间把每个模块里面的每个小知识点都拆分好，但前面的一定要列好，比如我十个模块，我最开始的一两个模块一定要再拆分规划好，同时再设定好每个小知识点的时间。要是前面的模块学完了，再去抽时间规划下一个模块就好了。</li>
                    <li>第二，没有提前设定好每个小目标。我反思了，为什么有的时候我不知道要干些啥呢？原因就是我没有提前规划好我第二天或者接下来的时间做什么。所以我后面决定改变一下，我会为自己提前做好规划，比如我第二天做什么，以及另外一个很重要的，规划一些零碎的时间做什么，比如学习慕课网的一个视频，或者去学习某一节英语课，或者去完成某项健身活动，把时间都利用起来。</li>
                  </ul>
                  <h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3>
                  <p>另外，这一年中，我也悟出了一些做事的原则或者生活上的感悟，我把一些体会比较深的写下来。</p>
                  <ul>
                    <li>别自嗨，多往外看看。有时候我们可能新学到了一个知识点，或者新做成了一个功能，就觉得自己很了不起了，但殊不知，可能别人已经把这个知识点当做必备知识，或者我们做出来的这个功能拿到外面去，其实是完全被爆的。所以，不要闭门造车，多出去看看，多了解下别人是怎么做的，多了解下这个的前沿和天花板已经到了什么地步，站在巨人的肩膀上，往往会走得更远。</li>
                    <li>别沉浸于过去。有时候我就会沉浸或满足于自己已经取得的一些成就，去“啃老”，但这样是不对的。不论我现在已经取得了什么成就，我都不应该沉浸进去。要把每一天当成 0 起点去对待，和自己的前一天去比较，每天进步一点，这样日积月累，进步就显现出来了。</li>
                    <li>多反思和复盘。就像刚才说的，我们每个人可能一天上班完了，就回家睡大觉了，然后第二天接着去上班。但有多少人每天晚上回问，自己今天到底进步了什么，即使没有进步，也反思一下自己今天为什么没有进步，怎样来解决这个现状。所以，我觉得每天去反思和复盘是很重要的。睡前的十几二十分钟，去思考一下，今天做成了什么、没有做成什么、下一步该怎么做，我觉得还是非常有价值的。</li>
                    <li>不能打包票的不要许诺。很多事情，我们要量力而行。有时候我答应过别人一件事情，可是到了时候，我发现自己没有时间完成或者没有能力去完成，最后去跟别人说要拖延时间或者干脆不做了。这其实对别人来说也很不好，而且本来可能是帮别人一个忙，反而可能会成为倒忙。所以，一些事情，在答应之前，好好想想到底有没有问题，如果不能打包票，不要轻易许诺。</li>
                    <li>一些小事也别以为很简单，重要的是细节。一件事，做的时候不要眼高手低，本来以为很简单的一件事，觉得分分钟就能做完，结果做完了发现很多细节没有把握好，出了很多错误。比如我记得之前我答应小马改个文章，本来以为很简单的东西，心想不就是改个这个吗，当时改的时候还在想着别的东西，改的时候并没有那么认真，结果导致有些错别字，最后被打回来返工，使得事情变得更糟。我不止一次犯过这种毛病了，犯错之后我也深深自责，为什么这么简单的事也能错。所以，一些小事也不要以为很简单，要认认真真去做，一些细节要把握好。</li>
                  </ul>
                  <p>还有一些别的感悟，有的感悟更深刻了，不过之前都写过了，我就不再写了，大家如果感兴趣可以看看我去年的年度总结或者之前我的一些分享。 好了，一些变化和反思我就暂时总结这么多了，不足的地方还有很多，也希望来年我能变得更好，无愧于自己的努力。</p>
                  <h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2>
                  <p>照例，新的 2020 年，我给自己立一点 Flag 吧！明年再来继续总结和验收。</p>
                  <h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3>
                  <p>工作继续好好努力，这是最重要的，现在我规划了一些新的尝试的方向，愿明年能够顺利实现和上线。</p>
                  <h3 id="健身减肥"><a href="#健身减肥" class="headerlink" title="健身减肥"></a>健身减肥</h3>
                  <p>新的一年，每个工作周，健身至少 2 次。体重减重到 130 斤并一直维持，减掉赘肉和小肚子。</p>
                  <h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3>
                  <p>给自己定一个读书计划，读完自己规划的一些书，每一本写出自己的感悟。</p>
                  <h3 id="日-周总结"><a href="#日-周总结" class="headerlink" title="日/周总结"></a>日/周总结</h3>
                  <p>每日复盘和总结，写到日记本中，每周末对该周的内容进行复盘和总结。</p>
                  <h3 id="爬虫书"><a href="#爬虫书" class="headerlink" title="爬虫书"></a>爬虫书</h3>
                  <p>《Python3网络爬虫开发实战（第二版）》书籍完成，书籍争取在上半年发售。另外还规划了配套视频，按照计划顺利出来。</p>
                  <h3 id="公众号-1"><a href="#公众号-1" class="headerlink" title="公众号"></a>公众号</h3>
                  <p>公众号我就不按照粉丝量来设定目标了，如果「常读用户」机制一直存在的话，新的一年，我希望公众号常读用户数目可以达到 2w，平均阅读量达到 6000，即翻倍。 另外公众号会尝试新的运营思路，我会写一些小的知识点发到公众号上，如果反响不错，新的一年会一直保持。</p>
                  <h3 id="开源-1"><a href="#开源-1" class="headerlink" title="开源"></a>开源</h3>
                  <p>继续维护自己的项目 Gerapy 和 ModelZoo。 Gerapy 把已经规划好的「可视化爬虫」、「智能解析」、「监控分析」等功能完善，Star 数破 3k。 ModelZoo 将其迁移到 PyTorch，并对接好当前规划的前沿主流模型，总 Star 数破 1k。</p>
                  <h3 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h3>
                  <p>学习一些理财知识，记录成自己的一套方法论。</p>
                  <h3 id="感情-1"><a href="#感情-1" class="headerlink" title="感情"></a>感情</h3>
                  <p>当然是和小马好好在一起！让我们的感情变得更好！</p>
                  <h3 id="收入"><a href="#收入" class="headerlink" title="收入"></a>收入</h3>
                  <p>这个自己给自己定了一个目标，这个具体数字我不说啦，朝着我的小米之家梦进发！</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-01-29 10:35:13" itemprop="dateCreated datePublished" datetime="2020-01-29T10:35:13+08:00">2020-01-29</time>
                </span>
                <span id="/8808.html" class="post-meta-item leancloud_visitors" data-flag-title="2019 年终总结：新生活、新探索" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>12k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>11 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8703.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8703.html" class="post-title-link" itemprop="url">新书发售 限时折扣｜《Python3 反爬虫原理与绕过实战》</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>无论是在学习还是工作中，反爬虫技术是所有爬虫工程师都要面对的问题。 常见的反爬虫原理和绕过技巧也是中高级爬虫工程师<strong>面试中关注的焦点</strong>， 尤其是那些竞争激烈的大型互联网企业。作为一名<strong>开发者</strong>，了解<strong>反爬虫原理</strong>和<strong>绕过技巧</strong>有助于<strong>设计</strong>出更合理的<strong>反爬虫策略</strong>，这会使你在同行中<strong>脱颖而出</strong>，<strong>大放异彩</strong>。</p>
                  <h1 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h1>
                  <p>如何<strong>深入</strong>学习<strong>反爬虫原理</strong>并<strong>掌握绕过技巧</strong>呢？ 今天给大家推荐业内深受欢迎的反爬虫专题书籍《Python3 反爬虫原理与绕过实战》</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191214150839.jpeg" alt="" title="null"></p>
                  <p>这本书于 2020 年 1 月出版，目前在各大电商平台和书城均有售。本书定价 89，现在各大平台均有不同的<strong>限时折扣</strong>，喜欢的朋友赶紧下手哦！ 【京东自营】 <a href="https://item.jd.com/12794078.html" target="_blank" rel="noopener">https://item.jd.com/12794078.html</a> 【天猫】<a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.201.15272c73Ta0USk&amp;id=611222843708&amp;ns=1&amp;abbucket=7" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?spm=a230r.1.14.201.15272c73Ta0USk&amp;id=611222843708&amp;ns=1&amp;abbucket=7</a> 【当当】<a href="http://product.dangdang.com/28508464.html" target="_blank" rel="noopener">http://product.dangdang.com/28508464.html</a> 书中描述了爬虫技术与反爬虫技术的<strong>对抗过程</strong>，并详细介绍了这其中的<strong>原理</strong>和具体的<strong>实现方法</strong>。本书从开发环境的配置到 Web 网站的构成和页面渲染，再到动态网页和静态网页对爬虫造成的影响。然后介绍了不同类型的<strong>反爬虫原理</strong>、<strong>具体实现</strong>和<strong>绕过方法</strong>。书中还讲解了<strong>常见验证码的实现过程</strong>，并使用<strong>深度学习技术完成了验证</strong>。最后介绍了常见的<strong>编码和加密原理</strong>、<strong>JavaScript 代码混淆</strong>知识、<strong>前端禁止事件</strong>以及<strong>与爬虫相关的法律知识和风险点</strong>。</p>
                  <h1 id="精彩抢先看"><a href="#精彩抢先看" class="headerlink" title="精彩抢先看"></a>精彩抢先看</h1>
                  <p>在原理探究和分析方面，你会经历细致的分析过程，并通过示意图加深对知识的理解。例如第 6 章第 2 节 CSS 偏移反爬虫中描述元素位置和样式值关系的示意图：</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231134122.png" alt="" title="null"></p>
                  <p>例如第 6 章第 3 节 SVG 反爬虫中描述 SVG text 定位的示意图：</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231134610.jpg" alt="" title="null"></p>
                  <p>例如第 10 章第 1 节编码与加密中描述加密过程的示意图：</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231134642.png" alt="" title="null"></p>
                  <p>例如第 9 章第 3 节滑动验证码中描述移动距离的示意图：</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231134827.png" alt="" title="null"></p>
                  <p>网站的反爬虫措施是会更新的，为了保证读者的学习质量，本书在编写过程中开发了一套拥有 21 个示例的练习平台 Steamboat。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231135742.jpg" alt="" title="null"></p>
                  <p>练习平台与书本紧密结合，不会出现学习过程中找不到与书本相同环境的情况，同时也能避免因练习而导致的侵权问题。除了配套的示例之外，书中还分析了众多互联网产品中使用到的反爬虫手段，这些产品包括大众点评、淘宝滑动验证码、猫眼电影、京东商城、去哪儿网、掘金社区和掌上英雄联盟等。 你有想过将深度学习应用到爬虫中吗？</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231140847.jpg" alt="" title="null"></p>
                  <p>书中介绍了如何通过卷积神经网络来应对字符验证码，并给出了训练用的图片和识别率高达 99% 的训练代码。其中部分代码如下：</p>
                  <figure class="highlight arcade">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">`folders \= PATH_TEST # 指定预测集路径`</span><span class="string">`trains \= get_image_name(PATH_TRAIN)  # 获取训练样本所有图片的名称`</span><span class="string">`pres \= get_image_name(folders)  # 获取预测集所有图片的名称`</span><span class="string">`repeat \= len([p for p in pres if p in trains])  # 获取重复数量`</span><span class="string">`start_verifies(folders)  # 开启预测`</span><span class="string">`logging.info('预测前确认待预测图片与训练样本的重复情况，'`</span><span class="string">`'待预测图片%s张，训练样本%s张，重复数量为%s张' % (len(pres), len(trains), repeat))`</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，还有通过目标检测算法来应对点选验证码的精彩章节。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191231141853.png" alt="" title="null"></p>
                  <h1 id="这本书是谁写的？"><a href="#这本书是谁写的？" class="headerlink" title="这本书是谁写的？"></a>这本书是谁写的？</h1>
                  <p>作者韦世东是一名资深爬虫工程师，2019 年华为云认证云享专家、掘金社区优秀作者、GitChat 认证作者、夜幕团队 NightTeam 的成员。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102171141.png" alt="" title="null"></p>
                  <p>他曾在掘金社区发布过电子小册《Python 实战：用 Scrapyd 打造个人化的爬虫部署管理控制台[1]》 。也在 GitChat 上发布过 MongoDB 的 10 万字教程《超高性价比的 MongoDB 零基础快速入门实战教程[2]》。还在华为总部进行过时长 2 小时的技术直播，直播主题为《Python 项目部署与调度核心逻辑[3]》。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102171245.jpg" alt="" title="null"></p>
                  <h1 id="这本书适合哪些朋友？"><a href="#这本书适合哪些朋友？" class="headerlink" title="这本书适合哪些朋友？"></a>这本书适合哪些朋友？</h1>
                  <p>这本书的目标读者分为两个阵营：<strong>爬虫</strong>和<strong>反爬虫</strong>。 爬虫工程师自然不用多说，大家最期待的正是对反爬虫技术的剖析和绕过实战。 反爬虫的设计者和实施者遍布于各个岗位，它可以是<strong>前端工程师</strong>、<strong>后端工程师</strong>、<strong>移动端研发</strong>甚至是<strong>产品经理</strong>。他们能够<strong>从书中了解到爬虫工程师常用的技术手段和思路</strong>，知道<strong>哪些防护措施容易被突破</strong>、<strong>哪些措施的绕过难度会更高</strong>以及<strong>如何限制爬虫</strong>，从而<strong>设计出适合的反爬虫策略</strong>。</p>
                  <h1 id="大厂高级研发怎么看？"><a href="#大厂高级研发怎么看？" class="headerlink" title="大厂高级研发怎么看？"></a>大厂高级研发怎么看？</h1>
                  <p>以下是几位大厂工程师为本书编写的推荐语。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102175332.jpg" alt="" title="null"></p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102175558.jpg" alt="" title="null"></p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102175614.jpg" alt="" title="null"></p>
                  <h1 id="详细的章节目录"><a href="#详细的章节目录" class="headerlink" title="详细的章节目录"></a>详细的章节目录</h1>
                  <p>详细目录如下：</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102165750.jpg" alt="" title="null"></p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102165805.jpg" alt="" title="null"></p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102165825.jpg" alt="" title="null"></p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20200102165838.jpg" alt="" title="null"></p>
                  <p>这简直就是手把手带你探寻反爬虫的世界！ <img src="https://cdn.cuiqingcai.com/wp-content/uploads/2020/01/0f042d65-8e75-484b-89c0-b2b944a66661_0.png" alt=""></p>
                  <h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3>
                  <p><code>[1]</code> Python 实战：用 Scrapyd 打造个人化的爬虫部署管理控制台: <em><a href="https://juejin.im/book/5bb5d3fa6fb9a05d2a1d819a/section" target="_blank" rel="noopener">https://juejin.im/book/5bb5d3fa6fb9a05d2a1d819a/section</a></em> <code>[2]</code> 超高性价比的 MongoDB 零基础快速入门实战教程: <em><a href="https://gitbook.cn/gitchat/activity/5d52baeaac15fd68e9f78297" target="_blank" rel="noopener">https://gitbook.cn/gitchat/activity/5d52baeaac15fd68e9f78297</a></em> <code>[3]</code> Python 项目部署与调度核心逻辑: <em><a href="http://huaweicloud.bugu.mudu.tv/watch/vondje76" target="_blank" rel="noopener">http://huaweicloud.bugu.mudu.tv/watch/vondje76</a></em></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/韦世东学算法和反爬虫" class="author" itemprop="url" rel="index">韦世东学算法和反爬虫</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2020-01-03 19:55:51" itemprop="dateCreated datePublished" datetime="2020-01-03T19:55:51+08:00">2020-01-03</time>
                </span>
                <span id="/8703.html" class="post-meta-item leancloud_visitors" data-flag-title="新书发售 限时折扣｜《Python3 反爬虫原理与绕过实战》" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.2k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8678.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8678.html" class="post-title-link" itemprop="url">揭秘去哪儿网在用的 CSS 偏移反爬虫手段！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>内容选自<strong>即将出版</strong>的《Python3 反爬虫原理与绕过实战》，本次公开书稿范围为第 6 章——文本混淆反爬虫。本篇为第 6 章中的第 2 小节，第 3、4 小节已发，直达链接：</p>
                  <ul>
                    <li>《<a href="https://juejin.im/post/5e05a58b6fb9a0164f2955b2" target="_blank" rel="noopener">一线大厂在用的反爬虫手段，看我破！</a>》</li>
                    <li>《<a href="https://juejin.im/post/5e03ef93518825125c4316c3" target="_blank" rel="noopener">用前考虑清楚，伤敌一千自损八百的字体反爬虫</a>》</li>
                  </ul>
                  <p>其余小节将<strong>逐步放送</strong>。</p>
                  <h2 id="CSS-偏移反爬虫"><a href="#CSS-偏移反爬虫" class="headerlink" title="CSS 偏移反爬虫"></a>CSS 偏移反爬虫</h2>
                  <p>CSS 偏移反爬虫指的是利用 CSS 样式将乱序的文字排版为人类正常阅读顺序的行为。这个概念不是很好理解，我们可以通过对比两段文字来加深对这个概念的理解。</p>
                  <ul>
                    <li>HTML 文本中的文字：我的学号是 1308205，我在北京大学读书。</li>
                    <li>浏览器显示的文字：我的学号是 1380205，我在北京大学读书。</li>
                  </ul>
                  <p>爬虫提取到的学号是 1308205，但用户在浏览器中看到的却是 1380205。如果不细心观察，爬虫工程师很容易被爬取结果糊弄。这种混淆方法和图片伪装一样，是不会影响用户阅读的。让人好奇的是，浏览器如何将 HTML 文本中的数字按照开发者的意愿排序或放置呢？这种放置规则是如何运作的呢？我们可以通过一个具体的例子来了解 CSS 偏移反爬虫的应用和绕过方法。</p>
                  <h3 id="6-2-1-CSS-偏移反爬虫绕过实战"><a href="#6-2-1-CSS-偏移反爬虫绕过实战" class="headerlink" title="6.2.1 CSS 偏移反爬虫绕过实战"></a>6.2.1 CSS 偏移反爬虫绕过实战</h3>
                  <p>示例 5：CSS 偏移反爬虫示例。 网址：<a href="http://www.porters.vip/confusion/flight.html" target="_blank" rel="noopener">http://www.porters.vip/confusion/flight.html</a>。 任务：爬取航班查询和机票销售网站页面中的航站名称、所属航空公司和票价，页面内容如图 6-4 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223139.jpg" alt=""> 图 6-4 示例 5 页面 在编写 Python 代码之前，我们需要确定目标数据的元素定位。航空公司名称元素定位如图 6-5 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223224.jpg" alt=""> 图 6-5 航空公司名称元素定位结果 航空公司名称包裹在没有属性的 span 标签中，但该 span 标签包裹在 class 属性为 air g-tips 的 div 标签中。接下来我们看一下航站名称的元素定位，定位结果如图 6-6 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223314.jpg" alt=""> 图 6-6 航站名称元素定位结果 航站名称包裹在没有属性的 h2 标签中，h2 标签包裹在 class 为 sep-lf 的 div 标签中。 我们再看一下票价的元素定位，定位结果如图 6-7 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223407.jpg" alt=""> 图 6-7 票价的元素定位结果 页面中显示的票价为 467，但是在网页中却有两组不同的数字，其中一组是[7, 7, 7]，而另一组是 [6, 4]，这看起来就有点奇怪了。 难道是网页显示有问题？ 按照正常排序来说，这架航班的票价应该是 77 764 才对。我们可以查看第二架航班信息的价格，思考是网页显示问题还是做了什么反爬虫措施。第二架航班的票价元素定位结果如图 6-8 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223516.jpg" alt=""> 图 6-8 第二架航班的票价元素定位结果 结果与第一架航班的票价显示有同样的问题：网页显示内容和 HTML 代码中的内容不一致。我们分析一下 HTML 代码，看一看是否能找到什么线索。第一架航班票价的 HTML 代码为：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"prc_wp"</span> <span class="attr">style</span>=<span class="string">"width:48px"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">"rel"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width:48px;left:-48px"</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width: 16px;left:-32px"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width: 16px;left:-48px"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">em</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>代码中有 3 对 b 标签，第 1 对 b 标签中包含 3 对 i 标签，i 标签中的数字都是 7，也就是说第 1 对 b 标签的显示结果应该是 777。而第 2 对 b 标签中的数字是 6，第 3 对 b 标签中的数字是 4。 这些数字与页面所显示票价 467 的关系是什么呢？ 这一步找到的标签和数字有可能是数据源，但是数字的组合有很多种可能，如图 6-9 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223638.jpg" alt=""> 图 6-9 数字组合推测 5 个数字的组合结果太多了，我们必须找出其中的规律，这样就能知道网页为什么显示 467 而不是 764 或者 776 。在仔细查看过后，发现每个带有数字的标签都设定了样式。第 1 对 b 标签的样式为：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">width</span>:<span class="number">48px</span>;<span class="attribute">left</span>:-<span class="number">48px</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第 2 对 b 标签的样式为：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">width</span>: <span class="number">16px</span>;<span class="attribute">left</span>:-<span class="number">32px</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第 3 对 b 标签的样式为：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">width</span>: <span class="number">16px</span>;<span class="attribute">left</span>:-<span class="number">48px</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>i 标签对的样式是相同的，都是：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">width</span>: <span class="number">16px</span>;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，还注意到最外层的 span 标签对的样式为：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">width:<span class="number">48</span>px</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果按照 CSS 样式这条线索来分析的话，第 1 对 b 标签中的 3 对 i 标签刚好占满 span 标签对的位置，其位置如图 6-10 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223828.jpg" alt=""> 图 6-10 span 标签对和 i 标签对位置图 此时网页中显示的价格应该是 777，但是由于第 2 和第 3 对 b 标签中有值，所以我们还需要计算它们的位置。此时标签位置的变化如图 6-11 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225223941.jpg" alt=""> 图 6-11 标签位置变化 右侧是标签位置变化后的结果，由于第 2 对 b 标签的位置样式是 left:-32px，所以第 2 对 b 标签中的值 6 就会覆盖原来第 1 对 b 标签中的中的第 2 个数字 7，此时页面应该显示的数字是 767。 按此规律推算，第 3 对 b 标签的位置样式是 left:-48px，这个标签的值会覆盖第 1 对 b 标签中的第 1 个数字 7，覆盖结果如图 6-12 所示，最后显示的票价是 467。 <img src="http://can.sfhfpc.com/sfhfpc/20191225224032.jpg" alt=""> 图 6-12 覆盖结果 根据结果来看这种算法是合理的，不过我们还需要对其进行验证，现在将第二架航班的 HTML 值 和 CSS 样式按照这个规律进行推算。最后推算得到的结果与页面显示结果相同，说明这个位置偏移的计算方法是正确的，这样我们就可以编写 Python 代码获取网页中的票价信息了。因为 b 标签包裹在 class 属性为 rel 的 em 标签下，所以我们要定位所有的 em 标签。对应的 Python 代码如下：</p>
                  <figure class="highlight xl">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line">from parsel <span class="keyword">import</span> Selector </span><br><span class="line">url = <span class="string">'http://www.porters.vip/confusion/flight.html'</span> </span><br><span class="line">resp = requests.get(url) </span><br><span class="line">sel = Selector(resp.<span class="keyword">text</span>) </span><br><span class="line">em = sel.css(<span class="string">'em.rel'</span>).extract()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接着定位所有的 b 标签。由于 b 标签中还有 i 标签，而且 i 标签的值是基准数据，所以可以直接提取。对应的 Python 代码如下：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">for</span> <span class="keyword">element</span> <span class="keyword">in</span> em: </span><br><span class="line">    <span class="keyword">element</span> = Selector(<span class="keyword">element</span>) </span><br><span class="line">    <span class="comment"># 定位所有的&lt;b&gt;标签</span></span><br><span class="line">    element_b = <span class="keyword">element</span>.css(<span class="string">'b'</span>).extract() </span><br><span class="line">    b1 = Selector(element_b.pop(<span class="number">0</span>)) </span><br><span class="line">    <span class="comment"># 获取第 1 对&lt;b&gt;标签中的值(列表) </span></span><br><span class="line">    base_price = b1.css(<span class="string">'i::text'</span>).extract()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来要提取其他 b 标签的偏移量和数字。对应的 Python 代码如下：</p>
                  <figure class="highlight cs">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">alternate_price = [] </span><br><span class="line"><span class="keyword">for</span> eb <span class="keyword">in</span> element_b: </span><br><span class="line">   eb = Selector(eb) </span><br><span class="line">   <span class="meta"># 提取&lt;b&gt;标签的 style 属性值</span></span><br><span class="line">   style = eb.css(<span class="string">'b::attr("style")'</span>).<span class="keyword">get</span>() </span><br><span class="line">   <span class="meta"># 获得具体的位置</span></span><br><span class="line">   position = <span class="string">''</span>.<span class="keyword">join</span>(re.findall(<span class="string">'left:(.*)px'</span>, style)) </span><br><span class="line">   <span class="meta"># 获得该标签下的数字</span></span><br><span class="line">   <span class="keyword">value</span> = eb.css(<span class="string">'b::text'</span>).<span class="keyword">get</span>() </span><br><span class="line">   <span class="meta"># 将&lt;b&gt;标签的位置信息和数字以字典的格式添加到替补票价列表中</span></span><br><span class="line">   alternate_price.append(&#123;<span class="string">'position'</span>: position, <span class="string">'value'</span>: <span class="keyword">value</span>&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后根据偏移量决定基准数据列表的覆盖元素，实际上是完成图 6-11 中的操作。</p>
                  <figure class="highlight vim">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">for</span> <span class="keyword">al</span> in alternate_price: </span><br><span class="line">   position = <span class="keyword">int</span>(<span class="keyword">al</span>.<span class="built_in">get</span>(<span class="string">'position'</span>)) </span><br><span class="line">   value = <span class="keyword">al</span>.<span class="built_in">get</span>(<span class="string">'value'</span>) </span><br><span class="line">   # 判断位置的数值是否正整数</span><br><span class="line">   plus = True <span class="keyword">if</span> position &gt;= <span class="number">0</span> <span class="keyword">else</span> False </span><br><span class="line">   # 计算下标，以 <span class="number">16</span>px 为基准</span><br><span class="line">   <span class="built_in">index</span> = <span class="keyword">int</span>(position / <span class="number">16</span>) </span><br><span class="line">   # 替换第一对<span class="symbol">&lt;b&gt;</span>标签值列表中的元素，也就是完成值覆盖操作</span><br><span class="line">   base_price[<span class="built_in">index</span>] = value </span><br><span class="line"><span class="keyword">print</span>(base_price)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>最后将数据列表打印出来，得到的输出结果为：</p>
                  <figure class="highlight scheme">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="symbol">'4</span>', <span class="symbol">'6</span>', <span class="symbol">'7</span>'] </span><br><span class="line">[<span class="symbol">'8</span>', <span class="symbol">'7</span>', <span class="symbol">'0</span>', <span class="symbol">'5</span>']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>令人感到奇怪的是，输出结果中第一组票价数字与页面中显示的相同，但第二组却不同。这是因为第二架航班的票价基准数据有 4 个值。航班票价对应的 HTML 代码如下：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">"rel"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width:64px;left:-64px"</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"width: 16px;"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width: 16px;left:-32px"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width: 16px;left:-48px"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">b</span> <span class="attr">style</span>=<span class="string">"width: 16px;left:-16px"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">b</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>覆盖操作是根据由偏移量计算得出的下标进行的，实际上就是列表元素的替换。当基准数据列表的元素数量超过包裹着 i 标签的 b 标签宽度时，我们就对列表进行切片，否则按照原来的替换规则进行。因此，需要对代码做一些调整。调整内容如下：</p>
                  <figure class="highlight vala">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta"># 减号代表删除此行代码，加号代表新增代码</span></span><br><span class="line">+ import re </span><br><span class="line">- base_price = b1.css(<span class="string">'i::text'</span>).extract() </span><br><span class="line">+ b1_style = b1.css(<span class="string">'b::attr("style")'</span>).<span class="keyword">get</span>() </span><br><span class="line"><span class="meta"># 获得具体的位置</span></span><br><span class="line">+ b1_width = <span class="string">''</span>.join(re.findall(<span class="string">'width:(.*)px;'</span>, b1_style)) </span><br><span class="line">+ number = <span class="keyword">int</span>(<span class="keyword">int</span>(b1_width) / <span class="number">16</span>) </span><br><span class="line"><span class="meta"># 获取第 1 对 &lt;b&gt; 标签中的值(列表) </span></span><br><span class="line">+ base_price = b1.css(<span class="string">'i::text'</span>).extract()[:number]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果列表中元素的数量超过标签宽度，那么后面的元素是不会显示的。比如 width:32px，每个标签占位宽度 16 px，那么即使 b 标签下有 5 个 i 标签（base_price=[1, 2 ,3 ,4 , 5]），在页面中也仅显示前面的两个数字。代码调整完毕后，再次运行代码。运行结果为：</p>
                  <figure class="highlight scheme">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="symbol">'4</span>', <span class="symbol">'6</span>', <span class="symbol">'7</span>'] </span><br><span class="line">[<span class="symbol">'8</span>', <span class="symbol">'7</span>', <span class="symbol">'0</span>', <span class="symbol">'5</span>']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第二架航班的票价结果仍然跟页面显示的内容不同，但根据 CSS 宽度规则，我们之前分析的逻辑是正确的。为什么结果还是跟页面显示的不一样呢？ 实际上并不是我们的逻辑和代码有错，而是页面显示错误。要注意的是，页面数据显示错误是常发生的事，我们只需要按照正确的逻辑编写代码即可。</p>
                  <h3 id="6-2-2-去哪儿网反爬虫案例"><a href="#6-2-2-去哪儿网反爬虫案例" class="headerlink" title="6.2.2 去哪儿网反爬虫案例"></a>6.2.2 去哪儿网反爬虫案例</h3>
                  <p>去哪儿网是中国领先的在线旅游平台，覆盖全球 68 万余条航线，并与国内的旅游景点和航空公司进行了深度的合作。去哪儿网也有用到类似的反爬虫手段，我们一起来了解一下。 打开浏览器并访问 <a href="https://dwz.cn/d05zNKyq，页面内容如图" target="_blank" rel="noopener">https://dwz.cn/d05zNKyq，页面内容如图</a> 6-13 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225224432.jpg" alt=""> 图 6-13 去哪儿网航班信息 航班票价对应的 HTML 代码如图 6-14 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225224514.jpg" alt=""> 图 6-14 去哪儿网航班票价 HTML 代码 去哪儿网航班票价所对应的 HTML 代码结构和 CSS 与我们在示例 5 中见到的类似。我们可以大胆猜测，去哪儿网航班票价的显示规律与示例 5 中所用的方法也是类似的，感兴趣的同学可以按照 6.2.1 节的思路进行票价推算。去哪儿网航班票价中第 1 对 b 标签下的 i 标签数量与 width 是相匹配的，并未出现显示错误的问题。</p>
                  <h3 id="6-2-3-小结"><a href="#6-2-3-小结" class="headerlink" title="6.2.3 小结"></a>6.2.3 小结</h3>
                  <p>CSS 样式可以改变页面显示，但这种“改变”仅存在于浏览器（能够解释 CSS 的渲染工具）中，即使爬虫工程师借助渲染工具，也无法获得“见到”的内容。 </p>
                  <h2 id="新书福利"><a href="#新书福利" class="headerlink" title="新书福利"></a>新书福利</h2>
                  <p>真是翘首以盼！《Python3 反爬虫原理与绕过实战》一书终于要跟大家见面了！为了感谢大家对韦世东和本书的期待与支持，在新书发布时会举办多场送书活动和限时折扣活动。 <img src="http://can.sfhfpc.com/sfhfpc/20191226081009.jpg" alt=""> 想要与作者韦世东交流或者参加新书发布活动的朋友可以扫描二维码进群与我互动哦！</p>
                  <h3 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h3>
                  <p>本篇内容摘自出版图书《Python3 反爬虫原理与绕过实战》，欢迎各位好友与同行转载！ 记得带上相关的版权信息哦😊。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/韦世东学算法和反爬虫" class="author" itemprop="url" rel="index">韦世东学算法和反爬虫</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-31 16:41:19" itemprop="dateCreated datePublished" datetime="2019-12-31T16:41:19+08:00">2019-12-31</time>
                </span>
                <span id="/8678.html" class="post-meta-item leancloud_visitors" data-flag-title="揭秘去哪儿网在用的 CSS 偏移反爬虫手段！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>5.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>5 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8648.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8648.html" class="post-title-link" itemprop="url">大厂在用的反爬虫手段，破了它！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>内容选自<strong>即将出版</strong>的《Python3 反爬虫原理与绕过实战》，本次公开书稿范围为第 6 章——文本混淆反爬虫。本篇为第 6 章中的第 3 小节，第 4 小节<a href="https://juejin.im/post/5e03ef93518825125c4316c3" target="_blank" rel="noopener"><strong>字体反爬虫</strong></a>已发布，其余小节将<strong>逐步放送</strong>。</p>
                  <h2 id="新书福利"><a href="#新书福利" class="headerlink" title="新书福利"></a>新书福利</h2>
                  <p>真是翘首以盼！《Python3 反爬虫原理与绕过实战》一书终于要跟大家见面了！为了感谢大家对韦世东和本书的期待与支持，在新书发布时会举办多场送书活动和限时折扣活动。</p>
                  <p><img src="http://can.sfhfpc.com/sfhfpc/20191226081009.jpg" alt="" title="null"></p>
                  <p>想要与作者韦世东交流或者参加新书发布活动的朋友可以扫描二维码进群与我互动哦！</p>
                  <h2 id="SVG-映射反爬虫"><a href="#SVG-映射反爬虫" class="headerlink" title="SVG 映射反爬虫"></a>SVG 映射反爬虫</h2>
                  <p>SVG 是用于描述二维矢量图形的一种图形格式。它基于 XML 描述图形，对图形进行放大或缩小操作都不会影响图形质量。矢量图形的这个特点使得它被广泛应用在 Web 网站中。 接下来我们要了解的反爬虫手段正是利用 SVG 实现的，这种反爬虫手段用矢量图形代替具体的文字，不会影响用户正常阅读，但爬虫程序却无法像读取文字那样获得 SVG 图形中的内容。由于 SVG 中的图形代表的也是一个个文字，所以在使用时必须在后端或前端将真实的文字与对应的 SVG 图形进行映射和替换，这种反爬虫手段被称为 SVG 映射反爬虫。</p>
                  <h3 id="6-3-1-SVG-映射反爬虫绕过实战"><a href="#6-3-1-SVG-映射反爬虫绕过实战" class="headerlink" title="6.3.1 SVG 映射反爬虫绕过实战"></a>6.3.1 SVG 映射反爬虫绕过实战</h3>
                  <p>示例 6：SVG 映射反爬虫示例。 网址：<a href="http://www.porters.vip/confusion/food.html" target="_blank" rel="noopener">http://www.porters.vip/confusion/food.html</a>。 任务：爬取美食商家评价网站页面中的商家联系电话、店铺地址和评分数据，页面内容如图 6-15 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225224848.jpg" alt=""> 图 6-15 示例 6 页面 在编写 Python 代码之前，我们需要确定目标数据的元素定位。在定位过程中，发现一个与以往不同的现象：有些数字在 HTML 代码中并不存在。例如口味的评分数据，其元素定位如图 6-16 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225224930.jpg" alt=""> 图 6-16 评分数据中口味分数元素定位 根据页面显示内容，HTML 代码中应该是 8.7 才对，但实际上我们看到的却是：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>口味:<span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkjj4"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span>.7<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>HTML 代码中有数字 7 和小数点，但没有 8 这个数字，似乎数字 8 的位置被 d 标签占据。而商家电话号码处的显示就更奇怪了，一个数字都没有。商家电话对应的 HTML 代码如下：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col more"</span>&gt;</span> </span><br><span class="line">        电话：</span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkbvu"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk08k"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk08k"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>-<span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk84t"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk6zl"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkqsc"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkqsc"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk6zl"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>包含很多的 d 标签，难道它使用 d 标签进行占位，然后用元素进行覆盖吗？我们可以将 d 标签的数量和数字的数量进行对比，发现它们的数量是相同的，也就是说一对 d 标签代表一个数字。 每一对 d 标签都有 class 属性，有些 class 属性值是相同的，有些则不同。我们再将 class 属性值与数字进行对比，看一看能否找到规律，如图 6-17 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225103.jpg" alt=""> 图 6-17 class 属性值和数字的对比 从图 6-17 中可以看出，class 属性值和数字是一一对应的，如属性值 vhk08k 与数字 0 对应。根据这个线索，我们可以猜测每个数字都与一个属性值对应，对应关系如图 6-18 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225143.jpg" alt=""> 图 6-18 数字与属性值对应关系 浏览器在渲染页面的时候就会按照这个对应关系进行映射，所以页面中显示的是数字，而我们在 HTML 代码中看到的则是这些 class 属性值。浏览器在渲染时将 HTML 中的 d 标签与数字按照此关系进行映射，并将映射结果呈现在页面中。映射逻辑如图 6-19 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225239.jpg" alt=""> 图 6-19 映射逻辑 我们的爬虫代码可以按照同样的逻辑实现映射功能，在解析 HTML 代码时将 d 标签的 class 属性值取出来，然后进行映射即可得到页面中显示的数字。如何在爬虫代码中实现映射关系呢？实际上网页中使用的是“属性名数字”这种结构，Python 中内置的字典正好可以满足我们的需求。我们可以用 Python 代码测试一下，代码如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 定义映射关系</span></span><br><span class="line"><span class="string">mappings</span> <span class="string">=</span> <span class="string">&#123;'vhk08k':</span> <span class="number">0</span><span class="string">,</span> <span class="attr">'vhk6zl':</span> <span class="number">1</span><span class="string">,</span> <span class="attr">'vhk9or':</span> <span class="number">2</span><span class="string">,</span> </span><br><span class="line">   <span class="attr">'vhkfln':</span> <span class="number">3</span><span class="string">,</span> <span class="attr">'vhkbvu':</span> <span class="number">4</span><span class="string">,</span> <span class="attr">'vhk84t':</span> <span class="number">5</span><span class="string">,</span> </span><br><span class="line">   <span class="attr">'vhkvxd':</span> <span class="number">6</span><span class="string">,</span> <span class="attr">'vhkqsc':</span> <span class="number">7</span><span class="string">,</span> <span class="attr">'vhkjj4':</span> <span class="number">8</span><span class="string">,</span> </span><br><span class="line">   <span class="attr">'vhk0f1':</span> <span class="number">9</span><span class="string">&#125;</span> </span><br><span class="line"><span class="comment"># HTML 中得到的属性值</span></span><br><span class="line"><span class="string">html_d_class</span> <span class="string">=</span> <span class="string">'vhkvxd'</span> </span><br><span class="line"><span class="comment"># 将映射后的结果打印输出</span></span><br><span class="line"><span class="string">print(mappings.get(html_d_class))</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这段代码的逻辑是：首先定义属性值与数字的映射关系，然后假设一个 HTML 中 d 标签的属性值，接着将这个属性值的映射结果打印出来。代码运行后得到的结果为：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">6</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果说明映射这种方法是可行的。接着我们试一试将商家的联系电话映射出来：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 定义映射关系</span></span><br><span class="line">mappings = &#123;<span class="string">'vhk08k'</span>: 0, <span class="string">'vhk6zl'</span>: 1, <span class="string">'vhk9or'</span>: 2, </span><br><span class="line">            <span class="string">'vhkfln'</span>: 3, <span class="string">'vhkbvu'</span>: 4, <span class="string">'vhk84t'</span>: 5, </span><br><span class="line">            <span class="string">'vhkvxd'</span>: 6, <span class="string">'vhkqsc'</span>: 7, <span class="string">'vhkjj4'</span>: 8, </span><br><span class="line">            <span class="string">'vhk0f1'</span>: 9&#125; </span><br><span class="line"><span class="comment"># 商家联系电话 class 属性</span></span><br><span class="line">html_d_class = [<span class="string">'vhkbvu'</span>, <span class="string">'vhk08k'</span>, <span class="string">'vhk08k'</span>, </span><br><span class="line">                <span class="string">''</span>, <span class="string">'vhk84t'</span>, <span class="string">'vhk6zl'</span>, </span><br><span class="line">                <span class="string">'vhkqsc'</span>, <span class="string">'vhkqsc'</span>, <span class="string">'vhk6zl'</span>] </span><br><span class="line"></span><br><span class="line">phone = [mappings.<span class="builtin-name">get</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> html_d_class] </span><br><span class="line"><span class="comment"># 将映射后的结果打印输出</span></span><br><span class="line"><span class="builtin-name">print</span>(phone)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果为：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, None, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">1</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们使用映射的方法得到了商家联系电话，说明 SVG 映射反爬虫已经被我们绕过了。</p>
                  <h3 id="6-3-2-大众点评反爬虫案例"><a href="#6-3-2-大众点评反爬虫案例" class="headerlink" title="6.3.2 大众点评反爬虫案例"></a>6.3.2 大众点评反爬虫案例</h3>
                  <p>这种映射手段不仅仅出现在本书的示例中，在大型网站中也有应用。大众点评是中国领先的本地生活信息及交易平台，也是全球最早建立的独立第三方消费点评网站。大众点评不仅为用户提供商户信息、消费点评及消费优惠等信息服务，同时提供团购、餐厅预订、外卖和电子会员卡等 O2O（Online To Offline）交易服务。大众点评网站也使用了映射型反爬虫手段，打开浏览器并访问 <a href="https://www.dianping.com/shop/14741057，页面如图" target="_blank" rel="noopener">https://www.dianping.com/shop/14741057，页面如图</a> 6-20 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225522.jpg" alt=""> 图 6-20 大众点评商家信息页 大众点评的商家信息页主要用于展示消费者对商家的各项评分、商家电话、店铺地址和推荐菜品等。我们可以看一看商家电话或评分的 HTML 代码，如图 6-21 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225608.jpg" alt=""> 图 6-21 商家电话 HTML 代码 大众点评中的商家号码并不是全部使用 d 标签代替，其中有部分使用了数字。但是仔细观察一下就可以发现商家号码的数量等于 d 标签数量加上数字的数量，说明 d 标签的 class 属性值与数字也有可能是一一对应的映射关系。感兴趣的同学可以使用示例 6 中的方法，尝试映射大众点评案例中的数字。 如果这种手段的绕过方法这么简单的话，那么它早就被淘汰了，为什么连大众点评这样的大型网站都会使用呢？我们继续往下看，大众点评的商家营业时间部分的 HTML 代码如图 6-22 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225659.jpg" alt=""> 图 6-22 大众点评商家营业时间 除了刚才的数字映射之外，大众点评还对中文进行了映射。此时如果按照示例 6 中人为地将 class 值和对应的文字进行映射的话，就非常麻烦了。试想一下，如果网页中所有的文字都使用这种映射反爬虫的手段，那么爬虫工程师要如何应对呢？对所有用到的文字进行映射吗？ 这不可能做到，其中要完成映射的包括 10 个数字、26 个英文字母和几千个常用汉字。而且目标网站一旦更改文字的对应关系，那么爬虫工程师就需要重新映射所有文字。面对这样的问题，我们必须找到文字映射规律，并且能够使用 Python 语言实现映射算法。如此一来，无论目标网站文字映射的对应关系如何变化，我们都能够使用这套映射算法得到正确的结果。 这种映射关系在网页中是如何实现的呢？是使用 JavaScript 在页面中定义数组吗？还是异步请求API 拿到 JSON 数据？这都有可能，接下来我们就去寻找答案。</p>
                  <h3 id="6-3-3-SVG-反爬虫原理"><a href="#6-3-3-SVG-反爬虫原理" class="headerlink" title="6.3.3 SVG 反爬虫原理"></a>6.3.3 SVG 反爬虫原理</h3>
                  <p>映射关系不可能凭空出现，一定使用了某种技术特性。HTML 中与标签 class 属性相关的只有 JavaScript 和 CSS。根据这个线索，我们需要继续对示例 6 进行分析。案例中商家电话的 HTML 代码为：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col more"</span>&gt;</span>电话：</span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkbvu"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk08k"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk08k"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>-<span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk84t"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk6zl"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkqsc"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhkqsc"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">d</span> <span class="attr">class</span>=<span class="string">"vhk6zl"</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们可以随意选择一对 d 标签，然后观察它对应的 CSS 样式有没有可以深入分析的线索，如果没有线索再看 JavaScript。 d 标签的 CSS 样式如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">d</span><span class="selector-attr">[class^=<span class="string">"vhk"</span>]</span> &#123; </span><br><span class="line">   <span class="attribute">width</span>: <span class="number">14px</span>; </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">30px</span>; </span><br><span class="line">   <span class="attribute">margin-top</span>: -<span class="number">9px</span>; </span><br><span class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(../font/food.svg); </span><br><span class="line">   <span class="attribute">background-repeat</span>: no-repeat; </span><br><span class="line">   <span class="attribute">display</span>: inline-block; </span><br><span class="line">   <span class="attribute">vertical-align</span>: middle; </span><br><span class="line">   <span class="attribute">margin-left</span>: -<span class="number">6px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.vhkqsc</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: -<span class="number">288.0px</span> -<span class="number">141.0px</span>; </span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>d 标签样式看上去没有什么特别之处，只是设置了 background 属性的坐标值。但是上方 d 标签的公共样式中设置了背景图片，我们可以复制背景图片的地址，在浏览器的新标签页中打开，d 标签背景图如图 6-23 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225857.jpg" alt=""> 图 6-23 标签背景图 d 标签的背景图中全部都是数字，这些无序的数字共有 4 行。但这好像不是一张大图片，我们查看该图片页面的源代码，内容如图 6-24 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225225953.jpg" alt=""> 图 6-24 图片页面源代码 源代码中前两行表明这是一个 SVG 文件，该文件中使用 text 标签定义文本， style 标签用于设置文本样式， text 标签定义的文本正是图片页面显示的数字。难道这些无序的数字就是我们在页面中看到的电话号码和评分数字？ 除了 class 属性值为 vhkbvu 的 d 标签，其他标签也使用了这个的 CSS 样式，但每对 d 标签的坐标定位都不同。它们的坐标定位如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-class">.vhkbvu</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: -<span class="number">386px</span> -<span class="number">97px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.vhk08k</span> &#123; </span><br><span class="line">    <span class="attribute">background</span>: -<span class="number">274px</span> -<span class="number">141px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.vhk84t</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: -<span class="number">176px</span> -<span class="number">141px</span>; </span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>坐标是定位数字的关键，要想知道坐标的计算方法，必须了解一些关于 SVG 的知识。 在本节开始的时候，我们简单地了解了 SVG 的概念，知道 SVG 是基于 XML 的。实际上它是用文本格式的描述性语言来描述图像内容的，因此 SVG 是一种与图像分辨率无关的矢量图形格式。打开文本编辑器，并在新建的文件中写入以下内容：</p>
                  <figure class="highlight django">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">svg</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD SVG 1.1//EN"</span> <span class="meta-string">"http://www.w3.org/Graphics/SVG/1.1/ </span></span></span></span><br><span class="line"><span class="xml"> DTD/svg11.dtd"&gt; </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/ </span></span></span></span><br><span class="line"><span class="xml"> 1999/xlink" width="250px" height="250.0px"&gt; </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">'10'</span> <span class="attr">y</span>=<span class="string">'30'</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">text</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>将该文件保存为 test.svg，然后使用浏览器打开 test.svg 文件，显示内容如图 6-25 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230140.jpg" alt=""> 图 6-25 test.svg 显示内容 代码前 3 行声明文件类型，第 4 行~第 5 行定义了 SVG 内容块和画布宽高，第 6 行使用 text 标签定义了一段文本并指定了文本的坐标。这段文本就是我们在浏览器中看到的内容，而代码中的 <em>x</em> 坐标和 <em>y</em> 坐标则用于确定该文本在画布中的位置，坐标规则如下。</p>
                  <ul>
                    <li>以页面的左上角为零坐标点，即坐标值为 (0, 0)。</li>
                    <li>坐标以像素为单位。</li>
                    <li><em>x</em> 轴的正方向为从左到右，<em>y</em> 轴的正方向是从上到下。</li>
                    <li><em>n</em> 个字符可以有 <em>n</em> 个位置参数。</li>
                  </ul>
                  <p>如果字符数量大于位置参数数量，那么没有位置参数的字符将以最后一个位置参数为零坐标点，并按原文顺序排列。 看上去并不是很好理解，我们可以通过修改代码来理解坐标轴的定义。首先是 <em>x</em> 轴， text 标签中的 <em>x</em> 代表列表字符在页面中的 <em>x</em> 轴位置，test.svg 中的 <em>x</em> 值为 10，现在我们将其设为 0 ，保存后刷新网页，页面内容如图 6-26 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230255.jpg" alt=""> 图 6-26 <em>x</em> 为 0 时的 test.svg 显示内容 <em>x</em> 的值为 0 时，文本紧贴浏览器左侧。而 <em>x</em> 的值为 10 时，文本距离浏览器左侧有一定的距离，这说明 <em>x</em> 的值能够决定文字所在的位置。现在我们将代码中 <em>x</em> 对应的值改为“10 50 30 40 20 60”（注意这里特意将第 2个数字 20与第 5个数字互换了位置），这样做是为了设定前 6个字符的坐标位置。 此时，第 1 个字符的位置参数为 10，第 2 个字符的位置参数为 50，第 3 个字符的位置参数为 30，以此类推，页面中正常显示的文字顺序应该是：</p>
                  <figure class="highlight autohotkey">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="built_in">holle,</span>world</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>但是由于我们调换了第 2 个字符和第 5 个字符的位置参数，即字母 e 和字母 o 的位置互换，如图 6-27 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230403.jpg" alt=""> 图 6-27 设定多个 <em>x</em> 值的 svg 图 6-27 中文字顺序与我们猜测的顺序是一样的，这说明 SVG 中每个字符都可以有自己的 <em>x</em> 轴坐标值。<em>y</em> 与 <em>x</em> 同理，每个字符都可以有自己的 <em>y</em> 轴坐标值。虽然我们只设定了 6 个位置参数， svg 中的字符却有 11 个，但没有设定位置参数的字符依然能够按照原文顺序排序。在了解 SVG 基本知识之后，我们回头看一下案例中所使用的 SVG 文件中坐标参数的设定，图 6-23 中的字符与图 6-24 图片页源代码中的字符一一对应，且每个字符都设定了 <em>x</em> 轴的位置参数，而 <em>y</em> 轴则只有 1 个值。 在了解位置参数之后，我们还需要弄清楚字符定位的问题。浏览器根据 CSS 样式中设定的坐标和元素宽高来确定 SVG 中对应数字。<em>x</em> 轴的正方向为从左到右，<em>y</em> 轴的正方向是从上到下，如图 6-28 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230507.jpg" alt=""> 图 6-28 SVG <em>x</em> 轴和 <em>y</em> 轴与位置参数的关系 而 CSS 样式中的 <em>x</em> 轴与 <em>y</em> 轴是相反的，也就是说 CSS 样式中 <em>x</em> 轴是负数向右的，<em>y</em> 轴是负数向下的，如图 6-29 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230553.jpg" alt=""> 图 6-29 CSS <em>x</em> 轴和 <em>y</em> 轴与位置参数的关系 所以当我们需要在 CSS 中定位 SVG 中的字符位置时，需要用负数表示。我们可以通过一个例子来理解它们的关系，现在需要在 CSS 中定位图 6-30 中第 1 行的第 1 个字符的中心点。 <img src="http://can.sfhfpc.com/sfhfpc/20191225230642.jpg" alt=""> 图 6-30 SVG 假设字符大小为 14 px，那么 SVG 的计算规则如下。</p>
                  <ul>
                    <li>字符在<em>x</em>轴中心点的计算规则为：字符大小除以2，再加字符的<em>x</em>轴起点位置参数，即14÷2+0 等于 7。</li>
                    <li>字符在 <em>y</em> 轴中心点的计算规则为：<em>y</em> 轴高度减字符 <em>y</em> 轴起点减字符大小，其值除以 2 后加上字符 <em>y</em> 轴起点位置参数，最后再加上字符大小数值的一半，即(38−0−14)÷2+0+7 等于 19。</li>
                  </ul>
                  <p>最后得到 SVG 的坐标为：</p>
                  <figure class="highlight gml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">x</span>=<span class="string">'7'</span> <span class="symbol">y</span>=<span class="string">'19'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>CSS 样式的 <em>x</em> 轴和 <em>y</em> 轴与 SVG 是相反的，所以 CSS 样式中对该字符的定位为：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\<span class="number">-7</span>px <span class="number">-19</span>px</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就能够定位到指定字符的中心点了。但是如果要在 HTML 页面中完整显示该字符，那么还需要为 HTML 中对应的标签设置宽高样式，如：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">width</span>: <span class="number">14px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">30px</span>;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在了解了 SVG 与 CSS 样式的关联关系后，我们就能够根据 CSS 样式映射出 SVG 中对应的字符。 在实际场景中，我们需要让程序能够自动处理 CSS 样式和 SVG 的映射关系，而不是人为地完成这些 工作。以示例 6 中的 SVG 和 CSS 样式为例，假如我们需要用 Python 代码实现自动映射功能，首先我 们就需要拿到这两个文件的 URL，如：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">url_css</span> = <span class="string">'http://www.porters.vip/confusion/css/food.css'</span> </span><br><span class="line"><span class="attr">url_svg</span> = <span class="string">'http://www.porters.vip/confusion/font/food.svg'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>还有需要映射的 HTML 标签的 class 属性值，如：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">css_class_name</span> = <span class="string">'vhkbvu'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来使用 Requests 库向 URL 发出请求，拿到文本内容。对应代码如下：</p>
                  <figure class="highlight arduino">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line">css_resp = requests.<span class="built_in">get</span>(url_css).<span class="built_in">text</span> </span><br><span class="line">svg_resp = requests.<span class="built_in">get</span>(url_svg).<span class="built_in">text</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>提取 CSS 样式文件中标签属性对应的坐标值，这里使用正则进行匹配即可。对应代码如下：</p>
                  <figure class="highlight sas">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import re </span><br><span class="line">pile = <span class="string">'.%s&#123;background:-(d+)px-(d+)px;&#125;'</span> % css_class_name </span><br><span class="line">pattern = re.compile(pile) </span><br><span class="line">css = css_resp.<span class="meta">replace</span>(<span class="string">'n'</span>, <span class="string">''</span>).<span class="meta">replace</span>(<span class="string">' '</span>, <span class="string">''</span>) </span><br><span class="line">coord = pattern.findall(css) </span><br><span class="line"><span class="meta">if</span> coord: </span><br><span class="line"> <span class="meta">x</span>, y = coord[0] </span><br><span class="line"> <span class="meta">x</span>, y =<span class="meta"> int(</span><span class="meta">x</span>),<span class="meta"> int(</span>y)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此时得到的坐标值是正数，可以直接用于 SVG 字符定位。定位前我们要先拿到 SVG 中所有 text 标签的 Element 对象：</p>
                  <figure class="highlight oxygene">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel import <span class="keyword">Selector</span> </span><br><span class="line">svg_data = <span class="keyword">Selector</span>(svg_resp) </span><br><span class="line">texts = svg_data.xpath(<span class="string">'//text'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后获取所有 text 标签中的 y 值，接着我们将上一步得到的 Element 对象进行循环取值即可：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">axis_y = [<span class="string">i.attrib.get('y') for i in texts if y &lt;= int(i.attrib.get('y'))</span>][<span class="symbol">0</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>得到 <em>y</em> 值后就可以开始字符定位了。要注意的是，SVG 中 text 标签的 <em>y</em> 值与 CSS 样式中得到的 <em>y</em> 值并不需要完全相等，因为样式可以随意调整，比如 CSS 样式中-90 和-92 对于 SVG 的定位来说并没有什么差别，所以我们只需要知道具体是哪一个 text 即可。 那么如何确定是哪一个 text呢？ 我们可以用排除法来确定，假如当前 CSS 样式中的 <em>y</em> 值是-97，那么在 SVG 中 text 的 <em>y</em> 值就不可能小于 97，我们只需要取到比 97 大且最相近的 text 标签 <em>y</em> 值即可。比如当前 SVG 所有 text 标签的 <em>y</em> 值为：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="number">38</span>, <span class="number">83</span>, <span class="number">120</span>, <span class="number">164</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>那么大于 97 且最相近的是 120。将这个逻辑转化为代码：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">axis_y = [<span class="string">i.attrib.get('y') for i in texts if y &lt;= int(i.attrib.get('y'))</span>][<span class="symbol">0</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>得到 y 值后就可以确定具体是哪个 text 标签了。对应代码如下：</p>
                  <figure class="highlight excel">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">svg_text = svg_data.xpath('//<span class="built_in">text</span>[@y=<span class="string">"%s"</span>]/<span class="built_in">text</span>()' % axis_y).extract_first()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来需要确认 SVG 中的文字大小，也就是需要找到 font-size 属性的值。对应代码如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">font_size</span> = re.search(<span class="string">'font-size:(d+)px'</span>, svg_resp).group(<span class="number">1</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>得到 font-size 的值后，我们就可以定位具体的字符了。<em>x</em> 轴有多少个字符呢？刚才我们拿到的 svg_text 就是指定的 text 标签中的字符：</p>
                  <figure class="highlight 1c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">'<span class="number">67126078110409</span><span class="number">66630008923284</span><span class="number">40489239185923</span>'</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们需要计算字符串长度吗？并不用，我们知道，每个字符大小为 14 px，只需要将 CSS 样式中的 <em>x</em> 值除以字符大小，得到的就是该字符在字符串中的位置。除法得到的结果有可能是整数也有可能是非整数，当结果是整数是说明定位完全准确，我们利用切片特性就可以拿到字符。如果结果是非整数，就说明定位不完全准确，由于字符不可能出现一半，所以我们利用地板除（编程语言中常见的向下取整除法，返回商的整数部分。）就可以拿到整数：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">position</span> = x // int(font_size) <span class="comment"># 结果为 27</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>也就是说 CSS 样式 vhkbvu 映射的是 SVG 中第 4 行文本的第 27 个位置的值。映射结果如图 6-31 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191225231136.jpg" alt=""> 图 6-31 映射结果 然后再利用切片特性拿到字符。对应代码如下：</p>
                  <figure class="highlight fortran">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">number</span> = svg_text[<span class="keyword">position</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">number</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>代码运行结果为 4。我们还可以尝试其他的 class 属性值，最后得到的结果与页面显示的字符都是相同的，说明这种映射算法是正确的。至此，我们已经完成了对映射型反爬虫的绕过。</p>
                  <h3 id="6-3-4-小结"><a href="#6-3-4-小结" class="headerlink" title="6.3.4 小结"></a>6.3.4 小结</h3>
                  <p>与 6.1 节和 6.2 节相同，本节示例所用的反爬虫手段，即使借助渲染工具也无法获得“见到”的内容。SVG 映射反爬虫利用了浏览器与编程语言在渲染方面的差异，以及 SVG 与 CSS 定位这样的前端知识。如果爬虫工程师不熟悉渲染原理和前端知识，那么这种反爬虫手段就会带来很大的困扰。 </p>
                  <h3 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h3>
                  <p>本篇内容摘自出版图书《Python3 反爬虫原理与绕过实战》，欢迎各位好友与同行转载！ 记得带上相关的版权信息哦😊。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/韦世东学算法和反爬虫" class="author" itemprop="url" rel="index">韦世东学算法和反爬虫</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-27 15:09:11" itemprop="dateCreated datePublished" datetime="2019-12-27T15:09:11+08:00">2019-12-27</time>
                </span>
                <span id="/8648.html" class="post-meta-item leancloud_visitors" data-flag-title="大厂在用的反爬虫手段，破了它！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>9.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>8 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8637.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8637.html" class="post-title-link" itemprop="url">谷歌验证码 ReCaptcha 破解教程，简单方便从零开始。</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>很久没有做爬虫破解类相关的分享了，之前交流群里有朋友提问谷歌系的 reCAPTCHA V2 验证码怎么破，因为工作的原因我是很久之后才看到的，也不知道那位朋友后来成功了没有。所以今天就来跟大家分享一下 reCAPTCHA V2 的破解。 （小马补充：想加交流群的朋友，进入公众号下方，点击技术交流，有读者群和交流群，点击后都会弹出崔老师的二维码，扫微信二维码拉群～） 如果大家访问国外的一些网站的话，想必肯定见过这样的一个验证码，它上面写着「I’m not a robot」，意为「我不是机器人」，验证码长这个样子： <img src="https://cdn.cuiqingcai.com/2019-12-26-001513.png" alt=""> 这时候，只要我们点击最前面的复选框，验证码算法会首先利用其「风险分析引擎」做一次安全检测，如果直接检验通过的话，我们会直接得到如下的结果： <img src="https://cdn.cuiqingcai.com/2019-12-26-000950.png" alt=""> 如果算法检测到当前系统存在风险，比如可能是陌生的网络环境，可能是模拟程序，会需要做二次校验。它会进一步弹出类似如下的内容： <img src="https://cdn.cuiqingcai.com/2019-12-26-002143.png" alt=""> 比如上面这张图，验证码页面会出现九张图片，同时最上方出现文字「树木」，我们需要点选下方九张图中出现「树木」的图片，点选完成之后，可能还会出现几张新的图片，我们需要再次完成点选，最后点击「验证」按钮即可完成验证。 或者我们可以点击下方的「耳机」图标，这时候会切换到听写模式，验证码会变成这样： <img src="https://cdn.cuiqingcai.com/2019-12-26-004236.png" alt=""> 这时候我们如果能填写对验证码读的音频内容，同样可以通过验证。 这两种方式都可以通过验证，验证完成之后，我们才能完成表单的提交，比如完成登录、注册等操作。 这种验证码叫什么名字？ 这个验证码就是 Google 的 reCAPTCHA V2 验证码，它就属于行为验证码的一种，这些行为包括点选复选框、选择对应图片、语音听写等内容，只有将这些行为校验通过，此验证码才能通过验证。相比于一般的图形验证码来说，此种验证码交互体验更好、安全性会更高、破解难度更大。 许多国外的网站都采用了此种验证码，由于某些原因，在国内其实无法直接使用，但只需要将验证码的域名更换为 recaptcha.net 同样是可以使用的，所以有时候我们在国内某些站点同样能看到它的身影。 其实上文所介绍的验证码仅仅是 reCAPTCHA 验证码的一种形式，是 V2 的显式版本，另外其 V2 版本还有隐式版本，隐式版本在校验的时候不会再显式地出现验证页面，它是通过 JavaScript 将验证码和提交按钮进行绑定，在提交表单的时候会自动完成校验。除了 V2 版本，Google 又推出了最新的 V3 版本，reCAPTCHA V3 验证码会为根据用户的行为来计算一个分数，这个分数代表了用户可能为机器人的概率，最后通过概率来判断校验是否可以通过。其安全性更高、体验更好。 具体的内容大家可以参考 reCAPTCHA 的官方介绍：<a href="https://developers.google.com/recaptcha" target="_blank" rel="noopener">https://developers.google.com/recaptcha</a>。 那么在做爬虫的时候，如果我们遇到了这样的验证码？该怎么办呢？不要着急，这篇文章就来介绍一个解决方案。</p>
                  <h2 id="机器学习-vs-识别服务"><a href="#机器学习-vs-识别服务" class="headerlink" title="机器学习 vs 识别服务"></a>机器学习 vs 识别服务</h2>
                  <p>之前我在写上一篇如何识别滑动验证码问题的时候，当时朋友留言问我能不能做一个机器学习的，我回复了，我说当然没问题，你等着，我这周就做。 我那周从周一做到周五，我记得用的应该是 yolo，反复修改，小马还经常过来催崔稿，耗费良久，然后就在那周周五晚上的 23:59 分，我灵机一动，终于明白了。 去他的机器学习，有服务不好吗？ reCAPTCHA 本身比极验还要复杂，国内网站我暂时没看到破解的，然后这次是用的俄罗斯的一个服务商 2Captcha 提供的 图像识别和一系列行为验证码的识别服务。 <img src="https://cdn.cuiqingcai.com/2019-12-26-012846.png" alt=""> 破解验证码背后有图像识别算法和大量人力的支撑，如果我们仅仅是简单的图形验证码，其可以通过一些图像识别算法将内容识别出来转化为文本内容。如果是较为复杂的图形验证码或者像 reCAPTCHA 类似的行为验证码，其背后会有人来对验证码进行模拟，然后返回其验证成功后的秘钥，我们利用其结果便可以完成一些验证码的绕过。 当然这种网站肯定是要收费的，按照 1000 次识别为单位，其花费的费用为 0.5 美刀到 2.99 美刀不等，比如非常简单的图形验证码可能就是 0.5 美刀，这种验证码对于其人力和算力资源消耗都是相对较小的，对于复杂的 reCAPTCHA 验证码，就要花 2.99 美刀了，因为识别这么一个验证码并不容易，其背后的人可能需要看好多图，点选好多次才能完成一次成功的验证。 目前我用的服务的收费标准是这样的： <img src="https://cdn.cuiqingcai.com/2019-12-26-012237.png" alt=""> 具体的内容或者更新大家可以到其官方说明 <a href="https://2captcha.com/2captcha-api#rates" target="_blank" rel="noopener">https://2captcha.com/2captcha-api#rates</a> 去查看。 后面我用他的服务来破解 reCAPTCHA，当然类比其他服务也是可以的，过程大概都是这样。</p>
                  <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2>
                  <p>要使用 2Captcha，第一步当然是注册一下它的账号了，注册完成之后我们可以进入到 2Captcha 的控制台，类似于这样子： <img src="https://cdn.cuiqingcai.com/2019-12-26-013234.png" alt=""> 在这里我们可以看到账户余额、API KEY、FAQ 等配置。 这里最重要的就是 API KEY 了，它是我们用来使用 2Captcha 的凭证，我们将它复制下来，后面我们会在代码中使用它。 <img src="https://cdn.cuiqingcai.com/2019-12-26-013456.png" alt=""> 好，准备工作完成了，我们接下来进入正式内容。</p>
                  <h2 id="2Captcha-for-reCAPTCHA-V2"><a href="#2Captcha-for-reCAPTCHA-V2" class="headerlink" title="2Captcha for reCAPTCHA V2"></a>2Captcha for reCAPTCHA V2</h2>
                  <p>在上文我们已经介绍过 reCAPTCHA V2 的使用和交互流程了，下面我们来介绍下其识别和绕过的基本流程。 在这里我们就拿官方的 reCAPTCHA V2 的示例网站来做演示吧，其网址为：<a href="https://www.google.com/recaptcha/api2/demo，打开之后界面如下所示" target="_blank" rel="noopener">https://www.google.com/recaptcha/api2/demo，打开之后界面如下所示</a>： <img src="https://cdn.cuiqingcai.com/2019-12-26-014533.png" alt=""> 在这里可以看到有一个表单，上面有一些输入框，下方是 reCAPTCHA V2 验证码。 要识别这个验证码，第一步便是找到这个验证码 sitekey，这个是验证码的唯一标识。 我们打开浏览器的开发者工具，查看其页面源码，首先找到 reCAPTCHA 的源代码，如下图所示： <img src="https://cdn.cuiqingcai.com/2019-12-26-015303.png" alt=""> 可以看到 reCAPTCHA 是对应了一个 iframe，我们看到的 reCAPTCHA 内容都是在 iframe 里面呈现出来的。 这里我们可以观察到在 reCAPTCHA 的源码的最外层的 div 上面有一个字段，叫做 data-sitekey，这就是刚才我们所说的 sitekey，它是验证码的唯一标识，比如这里我先将这个 sitekey 保存下来，这里其值为：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">6</span>Le-wvkSAAAAAPBMRTvw0Q4Muexq9bi0DJwx_mJ-</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>下一步，我们就需要将这个 sitekey 和当前页面的 URL 告诉 2Captcha，让 2Captcha 来帮助我们识别这个 reCAPTCHA 验证码，告诉 2Captcha 之后，2Captcha 会利用这些信息加载出对应的验证码，再利用其背后的人力来对验证码进行识别，最后将识别得到的 token 返回给我们即可。 好，那么接下来怎么把这个信息告诉 2Captcha 呢？ 很简单，2Captcha 为我们提供了一个接口，其接口地址为：<a href="https://2captcha.com/in.php，我们只需要将对应的信息发送到这个接口就好了" target="_blank" rel="noopener">https://2captcha.com/in.php，我们只需要将对应的信息发送到这个接口就好了</a>。 那么发送需要什么参数呢，在这里介绍一下：</p>
                  <p>参数</p>
                  <p>类型</p>
                  <p>必须</p>
                  <p><strong>描述</strong></p>
                  <p>key</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>我们自己的 API KEY</p>
                  <p>method</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>userrecaptcha，定义破解 reCAPTCHA 验证码的方式</p>
                  <p>googlekey</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>reCAPTCHA 的 sitekey</p>
                  <p>pageurl</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>reCAPTCHA 当前所在的 URL</p>
                  <p>invisible</p>
                  <p>Integer Default: 0</p>
                  <p>No</p>
                  <p>是否可见，1 代表是隐式验证码，0 代表普通验证码。</p>
                  <p>header_acao</p>
                  <p>Integer Default: 0</p>
                  <p>No</p>
                  <p>跨域访问配置</p>
                  <p>pingback</p>
                  <p>String</p>
                  <p>No</p>
                  <p>回调地址</p>
                  <p>json</p>
                  <p>Integer Default: 0</p>
                  <p>No</p>
                  <p>返回格式，1 代表返回 JSON 格式，0 代表纯文本，默认 0</p>
                  <p>soft_id</p>
                  <p>Integer</p>
                  <p>No</p>
                  <p>ID of software developer. Developers who integrated their software with 2captcha get reward: 10% of spendings of their software users.</p>
                  <p>proxy</p>
                  <p>String</p>
                  <p>No</p>
                  <p>代理配置</p>
                  <p>在这里我们可以构造一个 URL，它包括这几个参数：</p>
                  <ul>
                    <li>key：注意这里的 KEY 换成你自己的 API KEY</li>
                    <li>method：直接赋值 userrecaptcha</li>
                    <li>googlekey：复制的 sitekey</li>
                    <li>pageurl：当前 URL</li>
                    <li>json：直接赋值 1，代表返回 JSON 格式</li>
                  </ul>
                  <p>比如在这里我就构造了这个 URL，内容如下：</p>
                  <figure class="highlight llvm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https://<span class="number">2</span>captcha.com/in.php?key=<span class="keyword">c</span><span class="number">0</span>ae<span class="number">5935</span>d<span class="number">807</span><span class="keyword">c</span><span class="number">28</span>f<span class="number">285e5</span>cb<span class="number">16</span><span class="keyword">c</span><span class="number">676</span>a<span class="number">48</span>&amp;method=userrecaptcha&amp;googlekey=<span class="number">6</span>Le-wvkSAAAAAPBMRTvw<span class="number">0</span>Q<span class="number">4</span>Muexq<span class="number">9</span>b<span class="keyword">i0</span>DJwx_mJ-&amp;pageurl=https://www.google.com/recaptcha/ap<span class="keyword">i2</span>/demo&amp;json=<span class="number">1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候我们直接向这个 URL 发起一个 GET 请求即可。 我们可以直接在浏览器里面输入这个 URL，也可以使用 requests 等请求库来完成：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">response = requests.<span class="builtin-name">get</span>(url)</span><br><span class="line"><span class="builtin-name">print</span>(response.json())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接口会返回如下格式的内容：</p>
                  <figure class="highlight 1c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;'status': <span class="number">1</span>, 'request': '<span class="number">6291941969</span>5'&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里它返回了一个 JSON 格式的数据，其中 status 代表请求状态，如果是 1 的话，代表请求成功，另外其还会包含一个 request 字段，其内容是一个 ID，这个 ID 就是识别这个验证码的任务的 ID。因为 2Captcha 背后有很多人来帮助识别验证码，所以 2Captcha 将每个验证码的识别划分为一个个任务，每个任务都有一个唯一的 ID，刚分配任务时，这个任务被标记为 NOT_READY 状态。这些任务接下来会被分发给一个个人，识别完成之后，该任务就会被标记为已经识别状态，同时附有识别之后的信息，如 token 等内容。 好，刚才的接口请求成功之后，这个 reCAPTCHA 的识别任务就已经被下发了，其背后会有对应的人来对这个 reCAPTCHA 验证码进行识别，识别过程可能需要十几秒到几十秒不等，我们可以通过另一个接口来获取任务的结果。 获取结果的接口地址为：<a href="https://2captcha.com/res.php，同样我们需要传入一些参数，其参数介绍如下" target="_blank" rel="noopener">https://2captcha.com/res.php，同样我们需要传入一些参数，其参数介绍如下</a>：</p>
                  <p>参数</p>
                  <p><strong>类型</strong></p>
                  <p><strong>必需</strong></p>
                  <p><strong>描述</strong></p>
                  <p>key</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>API KEY</p>
                  <p>action</p>
                  <p>String</p>
                  <p>Yes</p>
                  <p>get，表示获取验证码的结果</p>
                  <p>id</p>
                  <p>Integer</p>
                  <p>Yes</p>
                  <p>任务 ID，就是刚才 in.php 接口返回的结果。</p>
                  <p>json</p>
                  <p>Integer Default: 0</p>
                  <p>No</p>
                  <p>返回 JSON 格式，1 代表使用 JSON 格式，0 代表纯文本格式</p>
                  <p>在这里我们构造一个 URL，它包括如上的参数：</p>
                  <ul>
                    <li>key：在这里换成你的 API KEY</li>
                    <li>action：就直接赋值 get</li>
                    <li>id：任务 ID</li>
                    <li>json：在这里用 1，即返回 JSON 格式数据</li>
                  </ul>
                  <p>这样我们就构造了如下的 URL：</p>
                  <figure class="highlight sas">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https://2captcha.com/res.php?<span class="meta">key</span>=c0ae5935d807c28f285e5cb16c676a48<span class="variable">&amp;action</span>=get<span class="variable">&amp;id</span>=62919419695<span class="variable">&amp;json</span>=1</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>同样我们可以在浏览器中访问或者用 requests 请求，得到如下结果：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"request"</span>: <span class="string">"03AOLTBLSg0fQUUMtP2o3kvJWNm6zla8MEjP_vPh629-xS-d_QrlJwMcxQfSJMUIU92noqbJ16yt5a0PdB3ORW-5MEbqK7NZ82bTnSZohCG_mYVVv8TbuvM1A99DFvlepxGEKlGCoi5lTHJd5z_QQ2mV1trGlI8VJkHjVAhLZzlz67MVgQzIu7aDl39n6aocAIVueQuCyjmA1C3hUECxpNlXJuXYVD10eJrqY_Bu36_2E0uBrmDIkAIjxCzEZWgadToU4ByLReOrNJ7_4t-P8leTUbPC5YBXvoDZZZByz8-vNnHzUu3GNNESzGSCMFfVPYumnXXI6i7TO5p1k-AElgb7qor6vDJGA_RpNNSUgAj8B0synG9APpbMQ4cEprHXle5pJtNCBX_v_8uqJLobomIx0St5l_H1tHGuTgI2UU-nWmR9TwvKp6SR-6G2Fi6pv7c8350tPbqJWWMcV0AXdfM85GjRDh2t7wh1CMukLQE21aIIwHh88kR0Fh0481Kw_umw8IfFCHyHKu8IcTERUL5LZdDzQkiGdF1wqWP-GhySMXEx-eOT7tB6SqPEAmO_mbwtJtA-qKzcHP"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果其返回的是如上格式的数据，就代表 reCAPTCHA 验证码已经识别成功了，其返回的 request 字段的内容就是识别的 token，我们直接拿着这个 token 放到表单里面提交就成功了。 那这个 token 怎么来用呢？ 其实如果不走 2Captcha 接口，我们如果人工验证成功之后，在其表单里面会把一个 name 叫做 g-recaptcha-response 的 textarea 赋值，如果验证成功，它的 value 值就是验证之后得到的 token，这个会作为表单提交的一部分发送到服务器进行验证。如果这个字段校验成功了，那就没问题了。 <img src="https://cdn.cuiqingcai.com/2019-12-26-024847.png" alt=""> 所以，2Captcha 相当于为我们模拟了点选验证码的过程，其最终得到的这个 token 其实就是我们应该赋值给 name 为 g-recaptcha-response 的内容。 那么怎么赋值呢？ 很简单，用 JavaScript 就好了。我们可以用 JavaScript 选取到这个 textarea，然后直接赋值即可，代码如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">document.getElementById(<span class="string">"g-recaptcha-response"</span>).<span class="attribute">innerHTML</span>=<span class="string">"TOKEN_FROM_2CAPTCHA"</span>;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>注意这里的 <code>TOKEN_FROM_2CAPTCHA</code> 需要换成刚才我们所得到的 token 值。我们做爬虫模拟登录的时候，假如是用 Selenium、Puppeteer 等软件，在模拟程序里面，只需要模拟执行这段 JavaScript 代码，就可以成功赋值了。 执行之后，直接提交表单，我们查看下 Network 请求： <img src="https://cdn.cuiqingcai.com/2019-12-26-025745.png" alt=""> 可以看到其就是提交了一个表单，其中有一个字段就是 g-recaptcha-response，它会发送到服务端进行校验，校验通过，那就成功了。 所以，如果我们借助于 2Captcha 得到了这个 token，然后把它赋值到表单的 textarea 里面，表单就会提交，如果 token 有效，就能成功绕过登录，而不需要我们再去点选验证码了。 最后我们得到如下成功的页面： <img src="https://cdn.cuiqingcai.com/2019-12-26-030006.png" alt=""> 至此，我们就成功地借助 2Captcha 来完成了 reCAPTCHA V2 验证码的识别。</p>
                  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
                  <p>本节我们介绍了利用 2Captcha 来帮助识别 reCAPTCHA V2 的流程。那应该来讲，我觉得工程师使用这样的服务并不是一种令人羞耻的过程，尤其是他可以以比较低的价格实现你的需求的情况下。毕竟你的时间，本身就是一种价值。 最后 2Captcha 这个网站我放在下面，有感兴趣的朋友可以看一下。另外如果有什么爬虫方面想看的文章，也欢迎在下面留言，我们会挑选被点赞较多的主题尽快写文。谢谢！</p>
                  <p><a href="http://2captcha.com/zh" target="_blank" rel="noopener">2captcha.com/zh</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-27 08:55:16" itemprop="dateCreated datePublished" datetime="2019-12-27T08:55:16+08:00">2019-12-27</time>
                </span>
                <span id="/8637.html" class="post-meta-item leancloud_visitors" data-flag-title="谷歌验证码 ReCaptcha 破解教程，简单方便从零开始。" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>6.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>6 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8627.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8627.html" class="post-title-link" itemprop="url">严选高质量文章 - 爬虫工程师必看，深入解读字体反爬虫</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>内容选自<strong>即将出版</strong>的《Python3 反爬虫原理与绕过实战》，本次公开书稿范围为第 6 章——文本混淆反爬虫。本篇为第 6 章中的第 4 小节，其余小节将<strong>逐步放送</strong>。 <img src="http://can.sfhfpc.com/sfhfpc/20191226081009.jpg" alt=""></p>
                  <h2 id="字体反爬虫开篇概述"><a href="#字体反爬虫开篇概述" class="headerlink" title="字体反爬虫开篇概述"></a>字体反爬虫开篇概述</h2>
                  <p>在 CSS3 之前，Web 开发者必须使用用户计算机上已有的字体。但是在 CSS3 时代，开发者可以使用@font-face 为网页指定字体，对用户计算机字体的依赖。开发者可将心仪的字体文件放在 Web 服务器上，并在 CSS 样式中使用它。用户使用浏览器访问 Web 应用时，对应的字体会被浏览器下载到用户的计算机上。 在学习浏览器和页面渲染的相关知识时，我们了解到 CSS 的作用是修饰 HTML ，所以在页面渲染的时候不会改变 HTML 文档内容。由于字体的加载和映射工作是由 CSS 完成的，所以即使我们借助 Splash、Selenium 和 Puppeteer 工具也无法获得对应的文字内容。字体反爬虫正是利用了这个特点，将自定义字体应用到网页中重要的数据上，使得爬虫程序无法获得正确的数据。</p>
                  <h3 id="6-4-1-字体反爬虫示例"><a href="#6-4-1-字体反爬虫示例" class="headerlink" title="6.4.1 字体反爬虫示例"></a>6.4.1 字体反爬虫示例</h3>
                  <p>示例 7：字体反爬虫示例。 网址：<a href="http://www.porters.vip/confusion/movie.html" target="_blank" rel="noopener">http://www.porters.vip/confusion/movie.html</a>。 任务：爬取影片信息展示页中的影片评分、评价人数和票房数据，页面内容如图 6-32 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226063524.jpg" alt=""> 图 6-32 示例 7 页面 在编写代码之前，我们需要确定目标数据的元素定位。定位时，我们在 HTML 中发现了一些奇怪的符号，HTML 代码如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"movie-index"</span>&gt; </span><br><span class="line">   &lt;p <span class="built_in">class</span>=<span class="string">"movie-index-title"</span>&gt;用户评分&lt;/p&gt; </span><br><span class="line">   &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"movie-index-content score normal-score"</span>&gt; </span><br><span class="line">       &lt;span <span class="built_in">class</span>=<span class="string">"index-left info-num "</span>&gt; </span><br><span class="line">       &lt;span <span class="built_in">class</span>=<span class="string">"stonefont"</span>&gt; ☒.☒ &lt;/span&gt; </span><br><span class="line">       &lt;/span&gt; </span><br><span class="line">   &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"index-right"</span>&gt; </span><br><span class="line">   &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"star-wrapper"</span>&gt; </span><br><span class="line">   &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"star-on"</span> style=<span class="string">"width:90%;"</span>&gt;&lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">   &lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">        &lt;span <span class="built_in">class</span>=<span class="string">"score-num"</span>&gt;&lt;span <span class="built_in">class</span>=<span class="string">"stonefont"</span>&gt; ☒☒. ☒☒ 万&lt;/span&gt;人评分&lt;/span&gt; </span><br><span class="line">   &lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">   &lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>页面中重要的数据都是一些奇怪的字符，本应该显示“9.7”的地方在 HTML 中显示的是“☒.☒”，而本应该显示“56.83”的地方在 HTML 中显示的是“☒☒.☒☒”。与 6.3 节中的映射反爬虫不同，案例中的文字都被“☒”符号代替了，根本无法分辨。这就很奇怪了，“☒”能代表这么多种数字吗？ 要注意的是，Chrome 开发者工具的元素面板中显示的内容不一定是相应正文的原文，要想知道“☒”符号是什么，还需要到网页源代码中确认。对应的网页源代码如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"movie-index"</span>&gt;</span><br><span class="line">    &lt;p <span class="built_in">class</span>=<span class="string">"movie-index-title"</span>&gt;用户评分&lt;/p&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"movie-index-content score normal-score"</span>&gt;</span><br><span class="line">        &lt;span <span class="built_in">class</span>=<span class="string">"index-left info-num "</span>&gt;</span><br><span class="line">            &lt;span <span class="built_in">class</span>=<span class="string">"stonefont"</span>&gt;&amp;<span class="comment">#xe624.&amp;#xe9c7&lt;/span&gt;</span></span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"index-right"</span>&gt;</span><br><span class="line">          &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"star-wrapper"</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"star-on"</span> style=<span class="string">"width:90%;"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">          &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">          &lt;span <span class="built_in">class</span>=<span class="string">"score-num"</span>&gt;&lt;span <span class="built_in">class</span>=<span class="string">"stonefont"</span>&gt;&amp;<span class="comment">#xf593&amp;#xe9c7&amp;#xe9c7.&amp;#xe624万&lt;/span&gt;人评分&lt;/span&gt;</span></span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>从网页源代码中看到的并不是符号，而是由&amp;#x 开头的一些字符，这与示例 6 中的 SVG 映射反爬虫非常相似。我们将页面显示的数字与网页源代码中的字符进行比较，映射关系如图 6-33 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064028.jpg" alt=""> 图 6-33 字符与数字的映射关系 字符与数字是一一对应的，我们只需要多找一些页面，将 0 ~ 9 数字对应的字符凑齐即可。但如果目标网站的字体是动态变化的呢？映射关系也是变化的呢？ 根据 6.3 节的学习和分析，我们知道人为映射并不能解决这些问题，必须找到映射关系的规律，并使用 Python 代码实现映射算法才行。继续往下分析，难道字符映射是先异步加载数据再使用 JavaScript 渲染的？ <img src="http://can.sfhfpc.com/sfhfpc/20191226064115.jpg" alt=""> 图 6-34 请求记录 网络请求记录如图 6-34 所示，请求记录中并没有发现异步请求，这个猜测并没有得到证实。CSS 样式方面有没有线索呢？页面中包裹符号的标签的 class 属性值都是 stonefont：</p>
                  <figure class="highlight clean">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;span <span class="keyword">class</span>=<span class="string">"stonefont"</span>&gt;&amp;#xe624.&amp;#xe9c7&lt;/span&gt; </span><br><span class="line">&lt;span <span class="keyword">class</span>=<span class="string">"stonefont"</span>&gt;&amp;#xf593&amp;#xe9c7&amp;#xe9c7.&amp;#xe624 万&lt;/span&gt; </span><br><span class="line">&lt;span <span class="keyword">class</span>=<span class="string">"stonefont"</span>&gt;&amp;#xea16&amp;#xe339.&amp;#xefd4&amp;#xf19a&lt;/span&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>但对应的 CSS 样式中仅设置了字体：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-class">.stonefont</span> &#123; </span><br><span class="line">    <span class="attribute">font-family</span>: stonefont; </span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>既然是自定义字体，就意味着会加载字体文件，我们可以在网络请求中找到加载的字体文件 movie.woff，并将其下载到本地，接着使用百度字体编辑器看一看里面的内容。 百度字体编辑器 FontEditor （详见 <a href="http://fontstore.baidu.com/static/editor/index.html）是一款在线字体编辑软件，能够打开本地或者远程的" target="_blank" rel="noopener">http://fontstore.baidu.com/static/editor/index.html）是一款在线字体编辑软件，能够打开本地或者远程的</a> ttf、woff、eot、otf 格式的字体文件，具备这些格式字体文件的导入和导出功能，并且提供字形编辑、轮廓编辑和字体实时预览功能，界面如图 6-35 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064238.jpg" alt=""> 图 6-35 百度字体编辑器界面 打开页面后，将 movie.woff 文件拖曳到百度字体编辑器的灰色区域即可，字体文件内容如图 6-36 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064335.jpg" alt=""> 图 6-36 字体文件 movie.woff 预览 该字体文件中共有 12 个字体块，其中包括 2 个空白字体块和 0 ~ 9 的数字字体块。我们可以大胆地猜测，评分数据和票房数据中使用的数字正是从此而来。 由此看来，我们还需要了解一些字体文件格式相关的知识，在了解文件格式和规律后，才能够找到更合理的解决办法。</p>
                  <h3 id="6-4-2-字体文件-WOFF"><a href="#6-4-2-字体文件-WOFF" class="headerlink" title="6.4.2 字体文件 WOFF"></a>6.4.2 字体文件 WOFF</h3>
                  <p>WOFF（Web Open Font Format，Web 开放字体格式）是一种网页所采用的字体格式标准。本质上基于 SFNT 字体（如 TrueType），所以它具备 TrueType 的字体结构，我们只需要了解 TrueType 字体的相关知识即可。 TrueType 字体是苹果公司与微软公司联合开发的一种计算机轮廓字体，TrueType 字体中的每个字形由网格上的一系列点描述，点是字体中的最小单位，字形与点的关系如图 6-37 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064442.jpg" alt=""> 图 6-37 字形与点的关系 字体文件中不仅包含字形数据和点信息，还包括字符到字形映射、字体标题、命名和水平指标等，这些信息存在对应的表中，所以我们也可以认为 TrueType 字体文件由一系列的表组成，其中常用的表 及其作用如图 6-38 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064528.jpg" alt=""> 图 6-38 构成字体文件的常用表及其作用 如何查看这些表的结构和所包含的信息呢？我们可以借助第三方 Python 库 fonttools 将 WOFF 等字体文件转换成 XML 文件，这样就能查看字体文件的结构和表信息了。首先我们要安装 fonttools 库， 安装命令为：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ pip <span class="keyword">install</span> fonttools</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>安装完毕后就可以利用该库转换文件类型，对应的 Python 代码为：</p>
                  <figure class="highlight clean">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont </span><br><span class="line">font = TTFont(<span class="string">'movie.woff'</span>) # 打开当前目录的 movie.woff 文件</span><br><span class="line">font.saveXML(<span class="string">'movie.xml'</span>) # 另存为 movie.xml</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>代码运行后就会在当前目录生成名为 movie 的 XML 文件。文件中字符到字形映射表 cmap 的内容如下：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;cmap_format_4 platformID=<span class="string">"0"</span> platEncID=<span class="string">"3"</span> language=<span class="string">"0"</span>&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0x78"</span> name=<span class="string">"x"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xe339"</span> name=<span class="string">"uniE339"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xe624"</span> name=<span class="string">"uniE624"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xe7df"</span> name=<span class="string">"uniE7DF"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xe9c7"</span> name=<span class="string">"uniE9C7"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xea16"</span> name=<span class="string">"uniEA16"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xee76"</span> name=<span class="string">"uniEE76"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xefd4"</span> name=<span class="string">"uniEFD4"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xf19a"</span> name=<span class="string">"uniF19A"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xf57b"</span> name=<span class="string">"uniF57B"</span>/&gt; </span><br><span class="line">   &lt;<span class="meta">map</span> <span class="meta">code</span>=<span class="string">"0xf593"</span> name=<span class="string">"uniF593"</span>/&gt; </span><br><span class="line">&lt;/cmap_format_4&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>map 标签中的 code 代表字符，name 代表字形名称，关系如图 6-39 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064718.jpg" alt=""> 图 6-39 字符到字形映射关系示例 XML 中的字符 0xe339 与网页源代码中的字符 对应，这样我们就确定了 HTML 中的字符码与 movie.woff 字体文件中对应的字形关系。字形数据存储在 glyf 表中，每个字形的数据都是独立的，例如字形 uniE339 的字形数据如下：</p>
                  <figure class="highlight vim">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;TTGlyph name=<span class="string">"uniE339"</span> xMin=<span class="string">"0"</span> yMin=<span class="string">"-12"</span> xMax=<span class="string">"510"</span> yMax=<span class="string">"719"</span>&gt; </span><br><span class="line">   <span class="symbol">&lt;contour&gt;</span> </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"410"</span> <span class="keyword">y</span>=<span class="string">"534"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"398"</span> <span class="keyword">y</span>=<span class="string">"586"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"377"</span> <span class="keyword">y</span>=<span class="string">"609"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"341"</span> <span class="keyword">y</span>=<span class="string">"646"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"289"</span> <span class="keyword">y</span>=<span class="string">"646"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">     ... </span><br><span class="line">   &lt;/contour&gt; </span><br><span class="line">   <span class="symbol">&lt;contour&gt;</span> </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"139"</span> <span class="keyword">y</span>=<span class="string">"232"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"139"</span> <span class="keyword">y</span>=<span class="string">"188"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">     &lt;<span class="keyword">pt</span> <span class="keyword">x</span>=<span class="string">"178"</span> <span class="keyword">y</span>=<span class="string">"103"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">     ... </span><br><span class="line">   &lt;/contour&gt; </span><br><span class="line">   &lt;instructions/&gt; </span><br><span class="line">&lt;/TTGlyph&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>TTGlyph 标签中记录着字形的名称、<em>x</em> 轴坐标和 <em>y</em> 轴坐标（坐标也可以理解为字形的宽高）。contour 标签记录的是字形的轮廓信息，也就是多个点的坐标位置，正是这些点构成了如图 6-40 所示的字形。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064821.jpg" alt=""> 图 6-40 字形 uniE339 的轮廓 我们可以在百度字体编辑器中调整点的位置，然后保存字体文件并将新字体文件转换为 XML 格式，相同名称的字形数据如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;TTGlyph <span class="built_in">name</span>=<span class="string">"uniE339"</span> xMin=<span class="string">"115"</span> yMin=<span class="string">"6"</span> xMax=<span class="string">"430"</span> yMax=<span class="string">"495"</span>&gt; </span><br><span class="line"> &lt;contour&gt; </span><br><span class="line">   &lt;pt x=<span class="string">"400"</span> y=<span class="string">"352"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">   &lt;pt x=<span class="string">"356"</span> y=<span class="string">"406"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">   &lt;pt x=<span class="string">"342"</span> y=<span class="string">"421"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">   &lt;pt x=<span class="string">"318"</span> y=<span class="string">"446"</span> <span class="keyword">on</span>=<span class="string">"0"</span>/&gt; </span><br><span class="line">   &lt;pt x=<span class="string">"283"</span> y=<span class="string">"446"</span> <span class="keyword">on</span>=<span class="string">"1"</span>/&gt; </span><br><span class="line">   ... </span><br><span class="line"> &lt;/contour&gt; </span><br><span class="line"> &lt;instructions/&gt; </span><br><span class="line">&lt;/TTGlyph&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接着将调整前的字形数据和调整后的字形数据进行对比。 如图 6-41 所示，点的位置调整后，字形数据也会发生相应的变化，如 xMin、xMax、yMin、yMax 还有 pt 标签中的 x 坐标 y 坐标都与之前的不同了。 <img src="http://can.sfhfpc.com/sfhfpc/20191226064932.jpg" alt=""> 图 6-41 字形数据对比 XML 文件中记录的是字形坐标信息，实际上，我们没有办法直接通过字形数据获得文字，只能从其他方面想办法。虽然目标网站使用多套字体，但相同文字的字形也是相同的。比如现在有 movie.woff 和 food.woff 这两套字体，它们包含的字形如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># movie.woff </span></span><br><span class="line"><span class="comment"># 包含 10 个字形数据：[0123456789] </span></span><br><span class="line">&lt;cmap_format_4 platformID=<span class="string">"0"</span> platEncID=<span class="string">"3"</span> language=<span class="string">"0"</span>&gt; </span><br><span class="line">   &lt;map code=<span class="string">"0x78"</span> <span class="built_in">name</span>=<span class="string">"x"</span>/&gt; </span><br><span class="line">   &lt;map code=<span class="string">"0xe339"</span> <span class="built_in">name</span>=<span class="string">"uniE339"</span>/&gt; <span class="comment"># 数字 6 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xe624"</span> <span class="built_in">name</span>=<span class="string">"uniE624"</span>/&gt; <span class="comment"># 数字 9 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xe7df"</span> <span class="built_in">name</span>=<span class="string">"uniE7DF"</span>/&gt; <span class="comment"># 数字 2 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xe9c7"</span> <span class="built_in">name</span>=<span class="string">"uniE9C7"</span>/&gt; <span class="comment"># 数字 7 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xea16"</span> <span class="built_in">name</span>=<span class="string">"uniEA16"</span>/&gt; <span class="comment"># 数字 5 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xee76"</span> <span class="built_in">name</span>=<span class="string">"uniEE76"</span>/&gt; <span class="comment"># 数字 0 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xefd4"</span> <span class="built_in">name</span>=<span class="string">"uniEFD4"</span>/&gt; <span class="comment"># 数字 8 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xf19a"</span> <span class="built_in">name</span>=<span class="string">"uniF19A"</span>/&gt; <span class="comment"># 数字 3 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xf57b"</span> <span class="built_in">name</span>=<span class="string">"uniF57B"</span>/&gt; <span class="comment"># 数字 1</span></span><br><span class="line">   &lt;map code=<span class="string">"0xf593"</span> <span class="built_in">name</span>=<span class="string">"uniF593"</span>/&gt; <span class="comment"># 数字 4 </span></span><br><span class="line">&lt;/cmap_format_4&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># food.woff </span></span><br><span class="line"><span class="comment"># 包含 3 个字形数据：[012] </span></span><br><span class="line">&lt;cmap_format_4 platformID=<span class="string">"0"</span> platEncID=<span class="string">"3"</span> language=<span class="string">"0"</span>&gt; </span><br><span class="line">   &lt;map code=<span class="string">"0x78"</span> <span class="built_in">name</span>=<span class="string">"x"</span>/&gt; </span><br><span class="line">   &lt;map code=<span class="string">"0xe556"</span> <span class="built_in">name</span>=<span class="string">"uniE556"</span>/&gt; <span class="comment"># 数字 0 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xe667"</span> <span class="built_in">name</span>=<span class="string">"uniE667"</span>/&gt; <span class="comment"># 数字 1 </span></span><br><span class="line">   &lt;map code=<span class="string">"0xe778"</span> <span class="built_in">name</span>=<span class="string">"uniE778"</span>/&gt; <span class="comment"># 数字 2 </span></span><br><span class="line">&lt;/cmap_format_4&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>要实现自动识别文字，需要先准备参照字形，也就是人为地准备数字 0 ~ 9 的字形映射关系和字形数据，如：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 0 和 7 与字形名称的映射伪代码，data 键对应的值是字形数据</span></span><br><span class="line"><span class="attr">font_mapping</span> = [ </span><br><span class="line">   &#123;<span class="string">'name'</span>: <span class="string">'uniE9C7'</span>, <span class="string">'words'</span>: <span class="string">'7'</span>, <span class="string">'data'</span>: <span class="string">'uniE9C7_contour_pt'</span>&#125;, </span><br><span class="line">   &#123;<span class="string">'name'</span>: <span class="string">'uniEE76'</span>, <span class="string">'words'</span>: <span class="string">'0'</span>, <span class="string">'data'</span>: <span class="string">'uniEE76_countr_pt'</span>&#125;, </span><br><span class="line">]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当我们遇到目标网站上其他字体文件时，就可以使用参照字形中的字形数据与目标字形进行匹配，如果字形数据非常接近，就认为这两个字形描述的是相同的文字。字形数据包含记录字形名称和字形起止坐标的 TTGlyph 标签以及记录点坐标的 pt 标签，起止坐标代表的是字形在画布上的位置，点坐标代表字形中每个点在画布上的位置。在起止坐标中，<em>x</em> 轴差值代表字形宽度，<em>y</em> 轴差值代表字形高度。 如图 6-42 所示，两个字形的起止坐标和宽高都有很大的差别，但是却能够描述相同的文字，所以字形在画布中的位置并不会影响描述的文字，字形宽度和字形高度也不会影响描述的文字。 <img src="http://can.sfhfpc.com/sfhfpc/20191226065110.jpg" alt=""> 图 6-42 描述相同文字的两个字形 点坐标的数量和坐标值可以作为比较条件吗？ 如图 6-43 所示，两个不同文字的字形数据是不一样的。虽然这两种字形的 name 都是 uniE9C7，但是字形数据中大部分 pt 标签 x 和 y 的差距都很大，所以我们可以判定这两个字形描述的并不是 同一个文字。你可能会想到点的数量也可以作为排除条件，也就是说如果点的数量不相同，那么这个 两个字形描述的就不是同一个文字。真的是这样吗？ <img src="http://can.sfhfpc.com/sfhfpc/20191226065656.jpg" alt=""> 图 6-43 描述不同文字的字形数据对比 在图 6-44 中，左侧描述文字 7 的字形有 17 个点，而右侧描述文字 7 的字形却有 20 个点。对应的字形信息如图 6-45 所示。 <img src="http://can.sfhfpc.com/sfhfpc/20191226065745.jpg" alt=""> 图 6-44 描述相同文字的字形 <img src="http://can.sfhfpc.com/sfhfpc/20191226065822.jpg" alt=""> 图 6-45 描述相同文字的字形信息 虽然点的数量不一样，但是它们的字形并没有太大的变化，也不会造成用户误读，所以点的数量并不能作为排除不同字形的条件。因此，只有起止坐标和点坐标数据完全相同的字形，描述的才是相同字符。</p>
                  <h3 id="6-4-3-字体反爬虫绕过实战"><a href="#6-4-3-字体反爬虫绕过实战" class="headerlink" title="6.4.3 字体反爬虫绕过实战"></a>6.4.3 字体反爬虫绕过实战</h3>
                  <p>要确定两组字形数据描述的是否为相同字符，我们必须取出 HTML 中对应的字形数据，然后将待确认的字形与我们准备好的基准字形数据进行对比。现在我们来整理一下这一系列工作的步骤。 (1) 准备基准字形描述信息。 (2) 访问目标网页。 (3) 从目标网页中读取字体编码字符。 (4) 下载 WOFF 文件并用 Python 代码打开。 (5) 根据字体编码字符找到 WOFF 文件中的字形轮廓信息。 (6) 将该字形轮廓信息与基准字形轮廓信息进行对比。 (7) 得出对比结果。 我们先完成前 4 个步骤的代码。下载 WOFF 文件并将其中字形描述的文字与人类认知的文字进行映射。由于字形数据比较庞大，所以我们可以将字形数据进行散列计算，这样得到的结果既简短又唯一，不会影响对比结果。这里以数字 0 ~ 9 为例：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">base_font </span>= &#123; </span><br><span class="line"> <span class="string">"font"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"uniEE76"</span>, <span class="string">"value"</span>: <span class="string">"0"</span>, <span class="string">"hex"</span>: <span class="string">"fc170db1563e66547e9100cf7784951f"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniF57B"</span>, <span class="string">"value"</span>: <span class="string">"1"</span>, <span class="string">"hex"</span>: <span class="string">"251357942c5160a003eec31c68a06f64"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniE7DF"</span>, <span class="string">"value"</span>: <span class="string">"2"</span>, <span class="string">"hex"</span>: <span class="string">"8a3ab2e9ca7db2b13ce198521010bde4"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniF19A"</span>, <span class="string">"value"</span>: <span class="string">"3"</span>, <span class="string">"hex"</span>: <span class="string">"712e4b5abd0ba2b09aff19be89e75146"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniF593"</span>, <span class="string">"value"</span>: <span class="string">"4"</span>, <span class="string">"hex"</span>: <span class="string">"e5764c45cf9de7f0a4ada6b0370b81a1"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniEA16"</span>, <span class="string">"value"</span>: <span class="string">"5"</span>, <span class="string">"hex"</span>: <span class="string">"c631abb5e408146eb1a17db4113f878f"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniE339"</span>, <span class="string">"value"</span>: <span class="string">"6"</span>, <span class="string">"hex"</span>: <span class="string">"0833d3b4f61f02258217421b4e4bde24"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniE9C7"</span>, <span class="string">"value"</span>: <span class="string">"7"</span>, <span class="string">"hex"</span>: <span class="string">"4aa5ac9a6741107dca4c5dd05176ec4c"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniEFD4"</span>, <span class="string">"value"</span>: <span class="string">"8"</span>, <span class="string">"hex"</span>: <span class="string">"c37e95c05e0dd147b47f3cb1e5ac60d7"</span>&#125;, </span><br><span class="line"> &#123;<span class="string">"name"</span>: <span class="string">"uniE624"</span>, <span class="string">"value"</span>: <span class="string">"9"</span>, <span class="string">"hex"</span>: <span class="string">"704362b6e0feb6cd0b1303f10c000f95"</span>&#125;] </span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>字典中的 name 代表该字形的名称，value 代表该字形描述的文字，hex 代表字形信息的 MD5 值。 考虑到网络请求记录中的字体文件路径有可能会变化，我们必须找到 CSS 中设定的字体文件路径，引入 CSS 的 HTML 代码为：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">"./css/movie.css"</span> <span class="attribute">rel</span>=<span class="string">"stylesheet"</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由引入代码得知该 CSS 文件的路径为 <a href="http://www.porters.vip/confusion/css/movie.css，文件中" target="_blank" rel="noopener">http://www.porters.vip/confusion/css/movie.css，文件中</a> @font-face 处就是设置字体的代码：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">@font-face</span> &#123; </span><br><span class="line">   <span class="attribute">font-family</span>: stonefont; </span><br><span class="line">   <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">'../font/movie.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>); </span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>字体文件路径为 <a href="http://www.porters.vip/confusion/font/movie.woff。找到文件后，我们就可以开始编写代码了，对应的" target="_blank" rel="noopener">http://www.porters.vip/confusion/font/movie.woff。找到文件后，我们就可以开始编写代码了，对应的</a> Python 代码如下：</p>
                  <figure class="highlight properties">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">import</span> <span class="string">re </span></span><br><span class="line"><span class="attr">from</span> <span class="string">parsel import Selector </span></span><br><span class="line"><span class="attr">from</span> <span class="string">urllib import parse </span></span><br><span class="line"><span class="attr">from</span> <span class="string">fontTools.ttLib import TTFont </span></span><br><span class="line"><span class="attr">url</span> = <span class="string">'http://www.porters.vip/confusion/movie.html' </span></span><br><span class="line"><span class="attr">resp</span> = <span class="string">requests.get(url) </span></span><br><span class="line"><span class="attr">sel</span> = <span class="string">Selector(resp.text) </span></span><br><span class="line"><span class="comment"># 提取页面加载的所有 css 文件路径</span></span><br><span class="line"><span class="attr">css_path</span> = <span class="string">sel.css('link[rel=stylesheet]::attr(href)').extract() </span></span><br><span class="line"><span class="attr">woffs</span> = <span class="string">[] </span></span><br><span class="line"><span class="attr">for</span> <span class="string">c in css_path: </span></span><br><span class="line"><span class="comment">   # 拼接正确的 css 文件路径</span></span><br><span class="line">   <span class="attr">css_url</span> = <span class="string">parse.urljoin(url, c) </span></span><br><span class="line"><span class="comment">   # 向 css 文件发起请求</span></span><br><span class="line">   <span class="attr">css_resp</span> = <span class="string">requests.get(css_url) </span></span><br><span class="line"><span class="comment">   # 匹配 css 文件中的 woff 文件路径</span></span><br><span class="line">   <span class="attr">woff_path</span> = <span class="string">re.findall("src:url('..(.*.woff)') format('woff');", </span></span><br><span class="line">   <span class="attr">css_resp.text)</span></span><br><span class="line">   <span class="attr">if</span> <span class="string">woff_path: </span></span><br><span class="line"><span class="comment">       # 如故路径存在则添加到 woffs 列表中</span></span><br><span class="line">       <span class="attr">woffs</span> <span class="string">+= woff_path </span></span><br><span class="line"><span class="attr">woff_url</span> = <span class="string">'http://www.porters.vip/confusion' + woffs.pop() </span></span><br><span class="line"><span class="attr">woff</span> = <span class="string">requests.get(woff_url) </span></span><br><span class="line"><span class="attr">filename</span> = <span class="string">'target.woff' </span></span><br><span class="line"><span class="attr">with</span> <span class="string">open(filename, 'wb') as f: </span></span><br><span class="line"><span class="comment">   # 将文件保存到本地</span></span><br><span class="line">   <span class="meta">f.write(woff.content)</span> <span class="string"></span></span><br><span class="line"><span class="comment"># 使用 TTFont 库打开刚才下载的 woff 文件</span></span><br><span class="line"><span class="attr">font</span> = <span class="string">TTFont(filename)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>因为 TTFont 可以直接读取 woff 文件的结构，所以这里不需要将 woff 保存为 XML 文件。接着以评分数据 9.7 对应的编码 #xe624.#xe9c7 进行测试，在原来的代码中引入基准字体数据 base_font，然后新增以下代码：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">web_code = <span class="string">'&amp;#xe624.&amp;#xe9c7'</span></span><br><span class="line"><span class="comment"># 编码文字替换</span></span><br><span class="line">woff_code = [i.<span class="built_in">upper</span>().<span class="built_in">replace</span>(<span class="string">'&amp;#X'</span>, <span class="string">'uni'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> web_code.<span class="built_in">split</span>(<span class="string">'.'</span>)] </span><br><span class="line">import hashlib </span><br><span class="line"><span class="built_in">result</span> = [] </span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> woff_code: </span><br><span class="line">   <span class="comment"># 从字体文件中取出对应编码的字形信息</span></span><br><span class="line">   content = font[<span class="string">'glyf'</span>].glyphs.<span class="built_in">get</span>(w).data </span><br><span class="line">   <span class="comment"># 字形信息 MD5 </span></span><br><span class="line">   glyph = hashlib.md5(content).hexdigest() </span><br><span class="line">   <span class="keyword">for</span> b <span class="keyword">in</span> base_font.<span class="built_in">get</span>(<span class="string">'font'</span>): </span><br><span class="line">       <span class="comment"># 与基准字形中的 MD5 值进行对比，如果相同则取出该字形描述的文字</span></span><br><span class="line">       <span class="keyword">if</span> b.<span class="built_in">get</span>(<span class="string">'hex'</span>) == glyph: </span><br><span class="line">           <span class="built_in">result</span>.append(b.<span class="built_in">get</span>(<span class="string">'value'</span>)) </span><br><span class="line">           break </span><br><span class="line"><span class="comment"># 打印映射结果</span></span><br><span class="line">print(<span class="built_in">result</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>以上代码运行结果为：</p>
                  <figure class="highlight scheme">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="symbol">'9</span>', <span class="symbol">'7</span>']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果说明能够正确映射字体文件中字形描述的文字。</p>
                  <h3 id="6-4-4-小结"><a href="#6-4-4-小结" class="headerlink" title="6.4.4 小结"></a>6.4.4 小结</h3>
                  <p>字体反爬能给爬虫工程师带来很大的麻烦。虽然爬虫工程师找到了应对方法，但这种方法依赖的条件比较严苛，如果开发者频繁改动字体文件或准备多套字体文件并随机切换，那真是一件令爬虫工程师头疼的事。不过，这些工作对于开发者来说也不是轻松的事。</p>
                  <h2 id="新书福利"><a href="#新书福利" class="headerlink" title="新书福利"></a>新书福利</h2>
                  <p>真是翘首以盼！《Python3 反爬虫原理与绕过实战》一书终于要跟大家见面了！为了感谢大家对韦世东和本书的期待与支持，在新书发布时会举办多场送书活动和限时折扣活动。 <img src="http://can.sfhfpc.com/sfhfpc/20191226081009.jpg" alt=""> 想要与作者韦世东交流或者参加新书发布活动的朋友可以扫描二维码进群与我互动哦！</p>
                  <h3 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h3>
                  <p>本篇内容摘自出版图书《Python3 反爬虫原理与绕过实战》，欢迎各位好友与同行转载！ 记得带上相关的版权信息哦😊。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/韦世东学算法和反爬虫" class="author" itemprop="url" rel="index">韦世东学算法和反爬虫</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-26 08:46:01" itemprop="dateCreated datePublished" datetime="2019-12-26T08:46:01+08:00">2019-12-26</time>
                </span>
                <span id="/8627.html" class="post-meta-item leancloud_visitors" data-flag-title="严选高质量文章 - 爬虫工程师必看，深入解读字体反爬虫" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>11k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>10 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8602.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8602.html" class="post-title-link" itemprop="url">如何通过 Tampermonkey 快速查找 JavaScript 加密入口</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>在很多情况下，我们可能想要在网页中自动执行某些代码，帮助我们完成一些操作。如自动抢票、自动刷单、自动爬虫等等，这些操作绝大部分都是借助 JavaScript 来实现的。那么问题来了？在浏览器里面怎样才能方便地执行我们所期望执行的 JavaScript 代码呢？在这里推荐一个插件，叫做 Tampermonkey。这个插件的功能非常强大，利用它我们几乎可以在网页中执行任何 JavaScript 代码，实现我们想要的功能。 当然不仅仅是自动抢票、自动刷单、自动爬虫，Tampermonkey 的用途远远不止这些，只要我们想要的功能能用 JavaScript 实现，Tampermonkey 就可以帮我们做到。比如我们可以将 Tampermonkey 应用到 JavaScript 逆向分析中，去帮助我们更方便地分析一些 JavaScript 加密和混淆代码。 本节我们就来介绍一下这个插件的使用方法，并结合一个实际案例，介绍下这个插件在 JavaScript 逆向分析中的用途。</p>
                  <h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2>
                  <p>Tampermonkey，中文也叫作「油猴」，它是一款浏览器插件，支持 Chrome。利用它我们可以在浏览器加载页面时自动执行某些 JavaScript 脚本。由于执行的是 JavaScript，所以我们几乎可以在网页中完成任何我们想实现的效果，如自动爬虫、自动修改页面、自动响应事件等等。</p>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <p>首先我们需要安装 Tampermonkey，这里我们使用的浏览器是 Chrome。直接在 Chrome 应用商店或者在 Tampermonkey 的官网 <a href="https://www.tampermonkey.net/" target="_blank" rel="noopener">https://www.tampermonkey.net/</a> 下载安装即可。 安装完成之后，在 Chrome 浏览器的右上角会出现 Tampermonkey 的图标，这就代表安装成功了。 <img src="https://cdn.cuiqingcai.com/2019-12-14-123401.png" alt=""></p>
                  <h2 id="获取脚本"><a href="#获取脚本" class="headerlink" title="获取脚本"></a>获取脚本</h2>
                  <p>Tampermonkey 运行的是 JavaScript 脚本，每个网站都能有对应的脚本运行，不同的脚本能完成不同的功能。这些脚本我们可以自定义，同样也可以用已经写好的很多脚本，毕竟有些轮子有了，我们就不需要再去造了。 我们可以在 <a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts</a> 这个网站找到一些非常实用的脚本，如全网视频去广告、百度云全网搜索等等，大家可以体验一下。</p>
                  <h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2>
                  <p>除了使用别人已经写好的脚本，我们也可以自己编写脚本来实现想要的功能。编写脚本难不难呢？其实就是写 JavaScript 代码，只要懂一些 JavaScript 的语法就好了。另外除了懂 JavaScript 语法，我们还需要遵循脚本的一些写作规范，这其中就包括一些参数的设置。 下面我们就简单实现一个小的脚本，实现某个功能。 首先我们可以点击 Tampermonkey 插件图标，点击「管理面板」按钮，打开脚本管理页面。 <img src="https://cdn.cuiqingcai.com/2019-12-14-130908.png" alt=""> 界面类似显示如下图所示。 <img src="https://cdn.cuiqingcai.com/2019-12-14-130941.png" alt=""> 在这里显示了我们已经有的一些 Tampermonkey 脚本，包括我们自行创建的，也包括从第三方网站下载安装的。 另外这里也提供了编辑、调试、删除等管理功能，我们可以方便地对脚本进行管理。 接下来我们来创建一个新的脚本来试试，点击左侧的「+」号，会显示如图所示的页面。 <img src="https://cdn.cuiqingcai.com/2019-12-14-131204.png" alt=""> 初始化的代码如下：</p>
                  <figure class="highlight php">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://www.tampermonkey.net/documentation.php?ext=dhdg</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here...</span></span><br><span class="line">&#125;)();</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里最上面是一些注释，但这些注释是非常有用的，这部分内容叫做 <code>UserScript Header</code> ，我们可以在里面配置一些脚本的信息，如名称、版本、描述、生效站点等等。 下面简单介绍下 <code>UserScript Header</code> 的一些参数定义。</p>
                  <ul>
                    <li>@name：脚本的名称，就是在控制面板显示的脚本名称。</li>
                    <li>@namespace：脚本的命名空间。</li>
                    <li>@version：脚本的版本，主要是做版本更新时用。</li>
                    <li>@author：作者。</li>
                    <li>@description：脚本描述。</li>
                    <li>@homepage, @homepageURL, @website，@source：作者主页，用于在 Tampermonkey 选项页面上从脚本名称点击跳转。请注意，如果 @namespace 标记以 <code>http://</code>开头，此处也要一样。</li>
                    <li>@icon, @iconURL and @defaulticon：低分辨率图标。</li>
                    <li>@icon64 and @icon64URL：64x64 高分辨率图标。</li>
                    <li>@updateURL：检查更新的网址，需要定义 @version。</li>
                    <li>@downloadURL：更新下载脚本的网址，如果定义成 <code>none</code> 就不会检查更新。</li>
                    <li>@supportURL：报告问题的网址。</li>
                    <li>
                      <p>@include：生效页面，可以配置多个，但注意这里并不支持 URL Hash。 例如：</p>
                      <figure class="highlight jboss-cli">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"><span class="string">//</span> @include http:<span class="string">//www.tampermonkey.net/</span>*</span><br><span class="line"><span class="string">//</span> @include http:<span class="string">//</span>*</span><br><span class="line"><span class="string">//</span> @include https:<span class="string">//</span>*</span><br><span class="line"><span class="string">//</span> @include *</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </li>
                    <li>
                      <p>@match：约等于 @include 标签，可以配置多个。</p>
                    </li>
                    <li>@exclude：不生效页面，可配置多个，优先级高于 @include 和 @match。</li>
                    <li>
                      <p>@require：附加脚本网址，相当于引入外部的脚本，这些脚本会在自定义脚本执行之前执行，比如引入一些必须的库，如 jQuery 等，这里可以支持配置多个 @require 参数。 例如：</p>
                      <figure class="highlight vim">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">// @require http<span class="variable">s:</span>//code.jquery.<span class="keyword">com</span>/jquery-<span class="number">2.1</span>.<span class="number">4</span>.<span class="built_in">min</span>.js</span><br><span class="line">// @require http<span class="variable">s:</span>//code.jquery.<span class="keyword">com</span>/jquery-<span class="number">2.1</span>.<span class="number">3</span>.<span class="built_in">min</span>.js#sha256=<span class="number">23456</span>...</span><br><span class="line">// @require http<span class="variable">s:</span>//code.jquery.<span class="keyword">com</span>/jquery-<span class="number">2.1</span>.<span class="number">2</span>.<span class="built_in">min</span>.js#md5=<span class="number">34567</span>...,<span class="built_in">sha256</span>=<span class="number">6789</span>...</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </li>
                    <li>
                      <p>@resource：预加载资源，可通过 GM_getResourceURL 和 GM_getResourceText 读取。</p>
                    </li>
                    <li>@connect：允许被 GM_xmlhttpRequest 访问的域名，每行一个。</li>
                    <li>@run-at：脚本注入的时刻，如页面刚加载时，某个事件发生后等等。 例如：<ul>
                        <li>document-start：尽可能地早执行此脚本。</li>
                        <li>document-body：DOM 的 body 出现时执行。</li>
                        <li>document-end：DOMContentLoaded 事件发生时或发生后后执行。</li>
                        <li>document-idle：DOMContentLoaded 事件发生后执行，即 DOM 加载完成之后执行，这是默认的选项。</li>
                        <li>context-menu：如果在浏览器上下文菜单（仅限桌面 Chrome 浏览器）中点击该脚本，则会注入该脚本。注意：如果使用此值，则将忽略所有 @include 和 @exclude 语句。</li>
                      </ul>
                    </li>
                    <li>
                      <p>@grant：用于添加 GM 函数到白名单，相当于授权某些 GM 函数的使用权限。 例如：</p>
                      <figure class="highlight pgsql">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">// @<span class="keyword">grant</span> GM_setValue</span><br><span class="line">// @<span class="keyword">grant</span> GM_getValue</span><br><span class="line">// @<span class="keyword">grant</span> GM_setClipboard</span><br><span class="line">// @<span class="keyword">grant</span> unsafeWindow</span><br><span class="line">// @<span class="keyword">grant</span> <span class="keyword">window</span>.<span class="keyword">close</span></span><br><span class="line">// @<span class="keyword">grant</span> <span class="keyword">window</span>.focus</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                      <p>如果没有定义过 @grant 选项，Tampermonkey 会猜测所需要的函数使用情况。</p>
                    </li>
                    <li>
                      <p>@noframes：此标记使脚本在主页面上运行，但不会在 iframe 上运行。</p>
                    </li>
                    <li>
                      <p>@nocompat：由于部分代码可能是专门为专门的浏览器所写，通过此标记，Tampermonkey 会知道脚本可以运行的浏览器。 例如：</p>
                      <figure class="highlight 1c">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line"><span class="comment">// @nocompat Chrome</span></span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                      <p>这样就指定了脚本只在 Chrome 浏览器中运行。</p>
                    </li>
                  </ul>
                  <p>除此之外，Tampermonkey 还定义了一些 API，使得我们可以方便地完成某个操作，如：</p>
                  <ul>
                    <li>GM_log：将日志输出到控制台。</li>
                    <li>GM_setValue：将参数内容保存到 Storage 中。</li>
                    <li>GM_addValueChangeListener：为某个变量添加监听，当这个变量的值改变时，就会触发回调。</li>
                    <li>GM_xmlhttpRequest：发起 Ajax 请求。</li>
                    <li>GM_download：下载某个文件到磁盘。</li>
                    <li>GM_setClipboard：将某个内容保存到粘贴板。</li>
                  </ul>
                  <p>还有很多其他的 API，大家可以到 <a href="https://www.tampermonkey.net/documentation.php" target="_blank" rel="noopener">https://www.tampermonkey.net/documentation.php</a> 来查看更多的内容。 在 <code>UserScript Header</code> 下方是 JavaScript 函数和调用的代码，其中 <code>&#39;use strict&#39;</code> 标明代码使用 JavaScript 的严格模式，在严格模式下可以消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为，如不能直接使用未声明的变量，这样可以保证代码的运行安全，同时提高编译器的效率，提高运行速度。在下方 <code>// Your code here...</code> 这里我们就可以编写自己的代码了。</p>
                  <h2 id="实战-JavaScript-逆向"><a href="#实战-JavaScript-逆向" class="headerlink" title="实战 JavaScript 逆向"></a>实战 JavaScript 逆向</h2>
                  <p>下面我们来通过一个简单的 JavaScript 逆向案例来演示一下 Tampermonkey 的作用。 在 JavaScript 逆向的时候，我们经常会需要追踪某些方法的堆栈调用情况，但很多情况下，一些 JavaScript 的变量或者方法名经过混淆之后是非常难以捕捉的。 但如果我们能掌握一定的门路或规律，辅助以 Tampermonkey，就可以更轻松地找出一些 JavaScript 方法的断点位置，从而加速逆向过程。 在逆向过程中，一个非常典型的技术就是 Hook 技术。Hook 技术中文又叫做钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原先的方法前后加入我们自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，钩子函数先得到控制权，这时钩子函数既可以加工处理（改变）该函数的执行行为，还可以强制结束消息的传递。 如果觉得比较抽象，看完下面的 Hook 案例就懂了。 例如，我们接下来使用 Tampermonkey 实现对某个 JavaScript 方法的 Hook，轻松找到某个方法执行的位置，从而快速定位到逆向入口。 接下来我们来这么一个简单的网站：<a href="https://scrape.cuiqingcai.com/login1，这个网站结构非常简单，就是一个用户名密码登录，但是不同的是，点击" target="_blank" rel="noopener">https://scrape.cuiqingcai.com/login1，这个网站结构非常简单，就是一个用户名密码登录，但是不同的是，点击</a> Submit 的时候，表单提交 POST 的内容并不是单纯的用户名和密码，而是一个加密后的 Token。 页面长这样： <img src="https://cdn.cuiqingcai.com/2019-12-14-163945.png" alt=""> 我们随便输入用户名密码，点击登录按钮，观察一下网络请求的变化。 可以看到如下结果： <img src="https://cdn.cuiqingcai.com/2019-12-14-165609.png" alt=""> 看到实际上控制台提交了一个 POST 请求，内容为：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"token"</span>:<span class="string">"eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiJ9"</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>嗯，确实，没有诸如 username 和 password 的内容了，那这究竟是个啥？我要是做爬虫的话？怎么模拟登录呢？ 模拟登录的前提当然就是找到当前 token 生成的逻辑了，那么问题来了，到底这个 token 和用户名、密码什么关系呢？我们怎么来找寻其中的蛛丝马迹呢？ 这里我们就可能思考了，本身输入的是用户名和密码，但是提交的时候却变成了一个 token，经过观察 token 的内容还很像 Base64 编码。这就代表，网站可能首先将用户名密码混为了一个新的字符串，然后最后经过了一次 Base64 编码，最后将其赋值为 token 来提交了。所以，初步观察我们可以得出这么多信息。 好，那就来验证下吧，看看网站 JavaScript 代码里面是咋实现的。 接下来我们看看网站的源码，打开 Sources 面板，好家伙，看起来都是 Webpack 打包之后的内容，经过了一些混淆，类似结果如下： <img src="https://cdn.cuiqingcai.com/2019-12-14-171158.png" alt=""> 这么多混淆代码，总不能一点点扒着看吧？这得找到猴年马月？那么遇到这种情形，这怎么去找 token 的生成位置呢？ 解决方法其实有两种。</p>
                  <h3 id="Ajax-断点"><a href="#Ajax-断点" class="headerlink" title="Ajax 断点"></a>Ajax 断点</h3>
                  <p>由于这个请求正好是一个 Ajax 请求，所以我们可以添加一个 XHR 断点监听，把 POST 的网址加到断点监听上面去，在 Sources 面板右侧添加这么一个 XHR 断点，如图所示： <img src="https://cdn.cuiqingcai.com/2019-12-14-171458.png" alt="image-20191215011457030"> 这时候如果我们再次点击登录按钮的时候，正好发起一次 Ajax 请求，就进入到断点了，然后再看堆栈信息就可以一步步找到编码的入口了。 点击 Submit 之后，页面就进入了 Debug 状态停下来了，结果如下： <img src="https://cdn.cuiqingcai.com/2019-12-14-171736.png" alt="image-20191215011734985"> 一步步找，我们最后其实可以找到入口其实是在 onSubmit 方法这里。但实际上，我们观察到，这里的断点的栈顶还会包括了一些 async Promise 等无关的内容，而我们真正想找的是用户名和密码经过处理，再进行 Base64 编码的地方，这些请求的调用实际上和我们找寻的入口是没有很大的关系的。 另外，如果我们想找的入口位置并不伴随这一次 Ajax 请求，这个方法就没法用了。 这个方法是奏效的，但是我们先不讲 onSubmit 方法里面究竟是什么逻辑，下一个方法再来讲。</p>
                  <h3 id="Hook-Function"><a href="#Hook-Function" class="headerlink" title="Hook Function"></a>Hook Function</h3>
                  <p>所以，这里介绍第二种可以快速定位入口的方法，那就是使用 Tampermonkey 自定义 JavaScript 实现某个 JavaScript 方法的 Hook。Hook 哪里呢？最明显的，Hook Base64 编码的位置就好了。 那么这里就涉及到一个小知识点，JavaScript 里面的 Base64 编码是怎么实现的。没错就是 btoa 方法，所以说，我们来 Hook btoa 方法就好了。 好，这里我们新建一个 Tampermonkey 脚本，内容如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         HookBase64</span></span><br><span class="line"><span class="comment">// @namespace    https://scrape.cuiqingcai.com/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  Hook Base64 encode function</span></span><br><span class="line"><span class="comment">// @author       Germey</span></span><br><span class="line"><span class="comment">// @match       https://scrape.cuiqingcai.com/login1</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hook</span>(<span class="params">object, attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = object[attr]</span><br><span class="line">        object[attr] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hooked'</span>, object, attr)</span><br><span class="line">            <span class="keyword">var</span> ret = func.apply(object, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hook(<span class="built_in">window</span>, <span class="string">'btoa'</span>)</span><br><span class="line">&#125;)()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先我们定义了一些 UserScript Header，包括 @name、@match 等等，这里比较重要的就是 @name，表示脚本名称；另外一个就是 @match，代表脚本生效的网址。 脚本的内容如上所示。我们定义了一个 hook 方法，传入 object 和 attr 参数，意思就是 Hook object 对象的 attr 参数。例如我们如果想 Hook 一个 alert 方法，那就把 object 设置为 window，把 attr 设置为 alert 字符串。这里我们想要 Hook Base64 的编码方法，在 JavaScript 中，Based64 编码是用 btoa 方法实现的，那么这里我们就只需要 Hook window 对象的 btoa 方法就好了。 那么 Hook 是怎么实现的呢？我们来看下，首先一句 <code>var func = object[attr]</code>，相当于我们先把它赋值为一个变量，我们调用 func 方法就可以实现和原来相同的功能。接着，我们再直接改写这个方法的定义，直接改写 <code>object[attr]</code>，将其改写成一个新的方法，在新的方法中，通过 <code>func.apply</code> 方法又重新调用了原来的方法。这样我们就可以保证，前后方法的执行效果是不受什么影响的，之前这个方法该干啥就还是干啥的。但是和之前不同的是，我们自定义方法之后，现在可以在 <code>func</code> 方法执行的前后，再加入自己的代码，如 <code>console.log</code> 将信息输出到控制台，如 <code>debugger</code> 进入断点等等。这个过程中，我们先临时保存下来了 <code>func</code> 方法，然后定义一个新的方法，接管程序控制权，在其中自定义我们想要的实现，同时在新的方法里面再重新调回 <code>func</code> 方法，保证前后结果是不受影响的。所以，我们达到了在不影响原有方法效果的前提下，可以实现在方法的前后实现自定义的功能，就是 Hook 的过程。 最后，我们调用 hook 方法，传入 window 对象和 btoa 字符串，保存。 接下来刷新下页面，这时候我们就可以看到这个脚本就在当前页面生效了，如图所示。 <img src="https://cdn.cuiqingcai.com/2019-12-14-174022.png" alt=""> 接下来，打开控制台，切换到 Sources 面板，这时候我们可以看到站点下面的资源多了一个叫做 Tampermonkey 的目录，展开之后，发现就是我们刚刚自定义的脚本。 <img src="https://cdn.cuiqingcai.com/2019-12-14-174210.png" alt=""> 然后输入用户名、密码，点击提交。发现成功进入了断点模式停下来了，代码就卡在了我们自定义的 <code>debugger</code> 这一行代码的位置，如下图所示。 <img src="https://cdn.cuiqingcai.com/2019-12-14-174338.png" alt=""> 成功 Hook 住了，这说明 JavaScript 代码在执行过程中调用到了 btoa 方法。 看下控制台，如下图所示。 <img src="https://cdn.cuiqingcai.com/2019-12-14-174540.png" alt="image-20191215014538625"> 这里也输出了 window 对象和 btoa 方法，验证正确。 这样，我们就顺利找到了 Base64 编码操作这个路口，然后看看堆栈信息，也已经不会出现 async、Promise 这样的调用，很清晰地呈现了 btoa 方法逐层调用的过程，非常清晰明了了，如图所示。 <img src="https://cdn.cuiqingcai.com/2019-12-14-174803.png" alt=""> 各个底层的 encode 方法略过，这样我们也非常顺利地找到了 onSubmit 方法里面的处理逻辑：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">onSubmit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = c.encode(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.form));</span><br><span class="line">  <span class="keyword">this</span>.$http.post(a[<span class="string">"a"</span>].state.url.root, &#123;</span><br><span class="line">    token: e</span><br><span class="line">  &#125;).then((<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data"</span>, e)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>仔细看看，encode 方法其实就是调用了一下 btoa 方法，就是一个 Base64 编码的过程。 另外堆栈信息中可以清晰地看到 Hook 的方法在执行前传入的参数值，即 arguments。另外执行的之后的结果 ret 也可以轻松地找到了，如图所示： <img src="https://cdn.cuiqingcai.com/2019-12-23-211320.png" alt=""> 所以，现在我们知道了 token 和用户名、密码是什么关系了吧。 这里一目了然了，就是对表单进行了 JSON 序列化，然后调用了 encode 也就是 btoa 方法，并赋值为了 token，入口顺利解开。后面，我们只需要模拟这个过程就 OK 了。 所以，我们通过 Tampermonkey 自定义 JavaScript 脚本的方式实现了某个方法调用的 Hook，使得我们快速能定位到加密入口的位置，非常方便。 以后如果观察出来了一些门道，可以多使用这种方法来尝试，如 Hook encode 方法、decode 方法、stringify 方法、log 方法、alert 方法等等，简单而又高效。 以上便是通过 Tampermonkey 实现简单 Hook 的基础操作，当然这个仅仅是一个常见的基础案例，不过从中我们也可以总结出一些 Hook 的基本门道。 后面我们会继续介绍更多相关内容。</p>
                  <h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2>
                  <ul>
                    <li>Hook 技术：<a href="https://www.jianshu.com/p/3382cc765b39" target="_blank" rel="noopener">https://www.jianshu.com/p/3382cc765b39</a></li>
                    <li>Tampermonkey：<a href="http://www.tampermonkey.net/" target="_blank" rel="noopener">http://www.tampermonkey.net/</a></li>
                    <li>Base64 编码：<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/atob" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/atob</a>。</li>
                    <li>示例网址：<a href="https://github.com/Python3WebSpider/Scrape" target="_blank" rel="noopener">https://github.com/Python3WebSpider/Scrape</a></li>
                  </ul>
                  <h2 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h2>
                  <p>本篇属于 JavaScript 逆向系列内容。由于某些原因，JavaScript 逆向是在爬虫中比较敏感的内容，因此文章中不会选取当前市面上任何一个商业网站作为案例，都是通过自建平台示例的方式来单独讲解某个知识点。另外大家不要将相关技术应用到非法用途，惜命惜命。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-24 05:47:08" itemprop="dateCreated datePublished" datetime="2019-12-24T05:47:08+08:00">2019-12-24</time>
                </span>
                <span id="/8602.html" class="post-meta-item leancloud_visitors" data-flag-title="如何通过 Tampermonkey 快速查找 JavaScript 加密入口" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>8.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>8 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8509.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8509.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 15.5–Gerapy 分布式管理</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="15-5-Gerapy-分布式管理"><a href="#15-5-Gerapy-分布式管理" class="headerlink" title="15.5 Gerapy 分布式管理"></a>15.5 Gerapy 分布式管理</h1>
                  <p>我们可以通过 Scrapyd-Client 将 Scrapy 项目部署到 Scrapyd 上，并且可以通过 Scrapyd API 来控制 Scrapy 的运行。那么，我们是否可以做到更优化？方法是否可以更方便可控？ 我们重新分析一下当前可以优化的问题。</p>
                  <ul>
                    <li>使用 Scrapyd-Client 部署时，需要在配置文件中配置好各台主机的地址，然后利用命令行执行部署过程。如果我们省去各台主机的地址配置，将命令行对接图形界面，只需要点击按钮即可实现批量部署，这样就更方便了。</li>
                    <li>使用 Scrapyd API 可以控制 Scrapy 任务的启动、终止等工作，但很多操作还是需要代码来实现，同时获取爬取日志还比较烦琐。如果我们有一个图形界面，只需要点击按钮即可启动和终止爬虫任务，同时还可以实时查看爬取日志报告，那这将大大节省我们的时间和精力。</li>
                  </ul>
                  <p>所以我们的终极目标是如下内容。</p>
                  <ul>
                    <li>更方便地控制爬虫运行</li>
                    <li>更直观地查看爬虫状态</li>
                    <li>更实时地查看爬取结果</li>
                    <li>更简单地实现项目部署</li>
                    <li>更统一地实现主机管理</li>
                  </ul>
                  <p>而这所有的工作均可通过 Gerapy 来实现。 Gerapy 是一个基于 Scrapyd、Scrapyd API、Django、Vue.js 搭建的分布式爬虫管理框架。接下来将简单介绍它的使用方法。</p>
                  <h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3>
                  <p>在本节开始之前请确保已经正确安装好了 Gerapy，安装方式可以参考第一章。</p>
                  <h3 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2. 使用说明"></a>2. 使用说明</h3>
                  <p>首先可以利用 gerapy 命令新建一个项目，命令如下：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">gerapy init</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样会在当前目录下生成一个 gerapy 文件夹，然后进入 gerapy 文件夹，会发现一个空的 projects 文件夹，我们后文会提及。 这时先对数据库进行初始化：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">gerapy migrate</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样即会生成一个 SQLite 数据库，数据库中会用于保存各个主机配置信息、部署版本等。 接下来启动 Gerapy 服务，命令如下：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">gerapy runserver</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样即可在默认 8000 端口上开启 Gerapy 服务，我们浏览器打开：<a href="http://localhost:8000" target="_blank" rel="noopener">http://localhost:8000</a> 即可进入 Gerapy 的管理页面，在这里提供了主机管理和项目管理的功能。 主机管理中，我们可以将各台主机的 Scrapyd 运行地址和端口添加，并加以名称标记，添加之后便会出现在主机列表中，Gerapy 会监控各台主机的运行状况并以不同的状态标识，如图 15-6 所示： <img src="./assets/15-6.jpg" alt=""> 图 15-6 主机列表 另外刚才我们提到在 gerapy 目录下有一个空的 projects 文件夹，这就是存放 Scrapy 目录的文件夹，如果我们想要部署某个 Scrapy 项目，只需要将该项目文件放到 projects 文件夹下即可。 比如这里我放了两个 Scrapy 项目，如图 15-7 所示： <img src="./assets/15-7.jpg" alt=""> 图 15-7 项目目录 这时重新回到 Gerapy 管理界面，点击项目管理，即可看到当前项目列表，如图 15-8 所示： <img src="./assets/15-8.jpg" alt=""> 图 15-8 项目列表 由于此处我有过打包和部署记录，在这里分别予以显示。 Gerapy 提供了项目在线编辑功能，我们可以点击编辑即可可视化地对项目进行编辑，如图 15-9 所示： <img src="./assets/15-9.jpg" alt=""> 图 15-9 可视化编辑 如果项目没有问题，可以点击部署进行打包和部署，部署之前需要打包项目，打包时可以指定版本描述，如图 15-10 所示： <img src="./assets/15-10.jpg" alt=""> 图 15-10 项目打包 打包完成之后可以直接点击部署按钮即可将打包好的 Scrapy 项目部署到对应的云主机上，同时也可以批量部署，如图 15-11 所示： <img src="./assets/15-11.jpg" alt=""> 图 15-11 部署页面 部署完毕之后就可以回到主机管理页面进行任务调度了，点击调度即可查看进入任务管理页面，可以当前主机所有任务的运行状态，如图 15-12 所示： <img src="./assets/15-12.jpg" alt=""> 图 15-12 任务运行状态 我们可以通过点击新任务、停止等按钮来实现任务的启动和停止等操作，同时也可以通过展开任务条目查看日志详情，如图 15-13 所示： <img src="./assets/15-13.jpg" alt=""> 图 15-13 查看日志 这样我们就可以实时查看到各个任务运行状态了。 以上便是 Gerapy 的一些功能的简单介绍，使用它我们可以更加方便地管理、部署和监控 Scrapy 项目，尤其是对分布式爬虫来说。 更多的信息可以查看 Gerapy 的 GitHub 地址：<a href="https://github.com/Gerapy" target="_blank" rel="noopener">https://github.com/Gerapy</a>。</p>
                  <h3 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h3>
                  <p>本节我们介绍了 Gerapy 的简单使用，利用它我们可以方便地实现 Scrapy 项目的部署、管理等操作，可以大大提高效率。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-12 09:28:36" itemprop="dateCreated datePublished" datetime="2019-12-12T09:28:36+08:00">2019-12-12</time>
                </span>
                <span id="/8509.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 15.5–Gerapy 分布式管理" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8506.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8506.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 15.4–Scrapyd 批量部署</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="15-4-Scrapyd-批量部署"><a href="#15-4-Scrapyd-批量部署" class="headerlink" title="15.4 Scrapyd 批量部署"></a>15.4 Scrapyd 批量部署</h1>
                  <p>我们在上一节实现了 Scrapyd 和 Docker 的对接，这样每台主机就不用再安装 Python 环境和安装 Scrapyd 了，直接执行一句 Docker 命令运行 Scrapyd 服务即可。但是这种做法有个前提，那就是每台主机都安装 Docker，然后再去运行 Scrapyd 服务。如果我们需要部署 10 台主机的话，工作量确实不小。 一种方案是，一台主机已经安装好各种开发环境，我们取到它的镜像，然后用镜像来批量复制多台主机，批量部署就可以轻松实现了。 另一种方案是，我们在新建主机的时候直接指定一个运行脚本，脚本里写好配置各种环境的命令，指定其在新建主机的时候自动执行，那么主机创建之后所有的环境就按照自定义的命令配置好了，这样也可以很方便地实现批量部署。 目前很多服务商都提供云主机服务，如阿里云、腾讯云、Azure、Amazon 等，不同的服务商提供了不同的批量部署云主机的方式。例如，腾讯云提供了创建自定义镜像的服务，在新建主机的时候使用自定义镜像创建新的主机即可，这样就可以批量生成多个相同的环境。Azure 提供了模板部署的服务，我们可以在模板中指定新建主机时执行的配置环境的命令，这样在主机创建之后环境就配置完成了。 本节我们就来看看这两种批量部署的方式，来实现 Docker 和 Scrapyd 服务的批量部署。</p>
                  <h3 id="1-镜像部署"><a href="#1-镜像部署" class="headerlink" title="1. 镜像部署"></a>1. 镜像部署</h3>
                  <p>以腾讯云为例进行说明。首先需要有一台已经安装好环境的云主机，Docker 和 Scrapyd 镜像均已经正确安装，Scrapyd 镜像启动加到开机启动脚本中，可以在开机时自动启动。 接下来我们来看下腾讯云下批量部署相同云服务的方法。 首先进入到腾讯云后台，可以点击更多选项制作镜像，如图 15-3 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-114145.png" alt=""> 图 15-3 制作镜像 然后输入镜像的一些配置信息，如图 15-4 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-114152.jpg" alt=""> 图 15-4 镜像配置 最后确认制作镜像即可，稍等片刻即可制作成功。 接下来我们可以创建新的主机，在新建主机时选择已经制作好的镜像即可，如图 15-5 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-114200.png" alt=""> 图 15-5 新建主机 后续配置过程按照提示进行即可。 配置完成之后登录新到云主机，即可看到当前主机 Docker 和 Scrapyd 镜像都已经安装好，Scrapyd 服务已经正常运行。 我们就通过自定义镜像的方式实现了相同环境的云主机的批量部署。</p>
                  <h3 id="2-模板部署"><a href="#2-模板部署" class="headerlink" title="2. 模板部署"></a>2. 模板部署</h3>
                  <p>Azure 的云主机在部署时都会使用一个部署模板，这个模板实际上是一个 JSON 文件，里面包含了很多部署时的配置选项，如主机名称、用户名、密码、主机型号等。在模板中我们可以指定新建完云主机之后执行的命令行脚本，如安装 Docker、运行镜像等。等部署工作全部完成之后，新创建的云主机就已经完成环境配置，同时运行相关服务。 这里提供一个部署 Linux 主机时自动安装 Docker 和运行 Scrapyd 镜像的模板，模板内容太多，源文件可以查看：<a href="https://github.com/Python3WebSpider/ScrapydDeploy/blob/master/azuredeploy.json。模板中" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapydDeploy/blob/master/azuredeploy.json。模板中</a> Microsoft.Compute/virtualMachines/extensions 部分有一个 commandToExecute 字段，它可以指定建立主机后自动执行的命令。这里的命令完成的是安装 Docker 并运行 Scrapyd 镜像服务的过程。 首先安装一个 Azure 组件，安装过程可以参考：<a href="https://docs.azure.cn/zh-cn/xplat-cli-install。之后就可以使用" target="_blank" rel="noopener">https://docs.azure.cn/zh-cn/xplat-cli-install。之后就可以使用</a> azure 命令行进行部署。 登录 Azure，这里登录的是中国区，命令如下：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">azure login -e AzureChinaCloud</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果没有资源组的话需要新建一个资源组，命令如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">azure<span class="built_in"> group </span>create myResourceGroup chinanorth</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中 myResourceGroup 就是资源组的名称，可以自行定义。 接下来就可以使用该模板进行部署了，命令如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">azure<span class="built_in"> group </span>deployment create --template-file azuredeploy.json myResourceGroup myDeploymentName</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 myResourceGroup 就是资源组的名称，myDeploymentName 是部署任务的名称。 例如，部署一台 Linux 主机的过程如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">azure<span class="built_in"> group </span>deployment create --template-file azuredeploy.json MyResourceGroup SingleVMDeploy</span><br><span class="line">info:    Executing command<span class="built_in"> group </span>deployment create</span><br><span class="line">info:    Supply values <span class="keyword">for</span> the following parameters</span><br><span class="line">adminUsername:  datacrawl</span><br><span class="line">adminPassword:  DataCrawl123</span><br><span class="line">vmSize:  Standard_D2_v2</span><br><span class="line">vmName:  datacrawl-vm</span><br><span class="line">dnsLabelPrefix:  datacrawlvm</span><br><span class="line">storageAccountName:  datacrawlstorage</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行命令后会提示输入各个配置参数，如主机用户名、密码等。之后等待整个部署工作完成即可，命令行会自动退出。然后，我们登录云主机即可查看到 Docker 已经成功安装并且 Scrapyd 服务正常运行。</p>
                  <h3 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h3>
                  <p>以上内容便是批量部署的两种方法。在大规模分布式爬虫架构中，如果需要批量部署多个爬虫环境，使用如上方法可以快速批量完成环境的搭建工作，而不用再去逐个主机配置环境。 到此为止，我们解决了批量部署的问题，创建主机完毕之后即可直接使用 Scrapyd 服务。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-12 09:26:43" itemprop="dateCreated datePublished" datetime="2019-12-12T09:26:43+08:00">2019-12-12</time>
                </span>
                <span id="/8506.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 15.4–Scrapyd 批量部署" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8494.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8494.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 15.3–Scrapyd 对接 Docker</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="15-3-Scrapyd-对接-Docker"><a href="#15-3-Scrapyd-对接-Docker" class="headerlink" title="15.3 Scrapyd 对接 Docker"></a>15.3 Scrapyd 对接 Docker</h1>
                  <p>我们使用了 Scrapyd-Client 成功将 Scrapy 项目部署到 Scrapyd 运行，前提是需要提前在服务器上安装好 Scrapyd 并运行 Scrapyd 服务，而这个过程比较麻烦。如果同时将一个 Scrapy 项目部署到 100 台服务器上，我们需要手动配置每台服务器的 Python 环境，更改 Scrapyd 配置吗？如果这些服务器的 Python 环境是不同版本，同时还运行其他的项目，而版本冲突又会造成不必要的麻烦。 所以，我们需要解决一个痛点，那就是 Python 环境配置问题和版本冲突解决问题。如果我们将 Scrapyd 直接打包成一个 Docker 镜像，那么在服务器上只需要执行 Docker 命令就可以启动 Scrapyd 服务，这样就不用再关心 Python 环境问题，也不需要担心版本冲突问题。 接下来，我们就将 Scrapyd 打包制作成一个 Docker 镜像。</p>
                  <h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3>
                  <p>请确保本机已经正确安装好了 Docker，如没有安装可以参考第 1 章的安装说明。</p>
                  <h3 id="2-对接-Docker"><a href="#2-对接-Docker" class="headerlink" title="2. 对接 Docker"></a>2. 对接 Docker</h3>
                  <p>接下来我们首先新建一个项目，然后新建一个 scrapyd.conf，即 Scrapyd 的配置文件，内容如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section">[scrapyd]</span></span><br><span class="line"><span class="attr">eggs_dir</span>    = eggs</span><br><span class="line"><span class="attr">logs_dir</span>    = logs</span><br><span class="line"><span class="attr">items_dir</span>   =</span><br><span class="line"><span class="attr">jobs_to_keep</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">dbs_dir</span>     = dbs</span><br><span class="line"><span class="attr">max_proc</span>    = <span class="number">0</span></span><br><span class="line"><span class="attr">max_proc_per_cpu</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">finished_to_keep</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">poll_interval</span> = <span class="number">5.0</span></span><br><span class="line"><span class="attr">bind_address</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">http_port</span>   = <span class="number">6800</span></span><br><span class="line"><span class="attr">debug</span>       = <span class="literal">off</span></span><br><span class="line"><span class="attr">runner</span>      = scrapyd.runner</span><br><span class="line"><span class="attr">application</span> = scrapyd.app.application</span><br><span class="line"><span class="attr">launcher</span>    = scrapyd.launcher.Launcher</span><br><span class="line"><span class="attr">webroot</span>     = scrapyd.website.Root</span><br><span class="line"></span><br><span class="line"><span class="section">[services]</span></span><br><span class="line"><span class="attr">schedule.json</span>     = scrapyd.webservice.Schedule</span><br><span class="line"><span class="attr">cancel.json</span>       = scrapyd.webservice.Cancel</span><br><span class="line"><span class="attr">addversion.json</span>   = scrapyd.webservice.AddVersion</span><br><span class="line"><span class="attr">listprojects.json</span> = scrapyd.webservice.ListProjects</span><br><span class="line"><span class="attr">listversions.json</span> = scrapyd.webservice.ListVersions</span><br><span class="line"><span class="attr">listspiders.json</span>  = scrapyd.webservice.ListSpiders</span><br><span class="line"><span class="attr">delproject.json</span>   = scrapyd.webservice.DeleteProject</span><br><span class="line"><span class="attr">delversion.json</span>   = scrapyd.webservice.DeleteVersion</span><br><span class="line"><span class="attr">listjobs.json</span>     = scrapyd.webservice.ListJobs</span><br><span class="line"><span class="attr">daemonstatus.json</span> = scrapyd.webservice.DaemonStatus</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里实际上是修改自官方文档的配置文件：<a href="https://scrapyd.readthedocs.io/en/stable/config.html#example-configuration-file" target="_blank" rel="noopener">https://scrapyd.readthedocs.io/en/stable/config.html#example-configuration-file</a>，其中修改的地方有两个：</p>
                  <ul>
                    <li>max_proc_per_cpu = 10，原本是 4，即 CPU 单核最多运行 4 个 Scrapy 任务，也就是说 1 核的主机最多同时只能运行 4 个 Scrapy 任务，在这里设置上限为 10，也可以自行设置。</li>
                    <li>bind_address = 0.0.0.0，原本是 127.0.0.1，不能公开访问，在这里修改为 0.0.0.0 即可解除此限制。</li>
                  </ul>
                  <p>接下来新建一个 requirements.txt ，将一些 Scrapy 项目常用的库都列进去，内容如下：</p>
                  <figure class="highlight mipsasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">requests</span><br><span class="line">selenium</span><br><span class="line">aiohttp</span><br><span class="line"><span class="keyword">beautifulsoup4</span></span><br><span class="line"><span class="keyword">pyquery</span></span><br><span class="line"><span class="keyword">pymysql</span></span><br><span class="line"><span class="keyword">redis</span></span><br><span class="line"><span class="keyword">pymongo</span></span><br><span class="line"><span class="keyword">flask</span></span><br><span class="line"><span class="keyword">django</span></span><br><span class="line"><span class="keyword">scrapy</span></span><br><span class="line"><span class="keyword">scrapyd</span></span><br><span class="line"><span class="keyword">scrapyd-client</span></span><br><span class="line"><span class="keyword">scrapy-redis</span></span><br><span class="line"><span class="keyword">scrapy-splash</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果我们运行的 Scrapy 项目还有其他的库需要用到可以自行添加到此文件中。 最后我们新建一个 Dockerfile，内容如下：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./scrapyd.conf /etc/scrapyd/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6800</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> scrapyd</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一行 FROM 是指在 python:3.6 这个镜像上构建，也就是说在构建时就已经有了 Python 3.6 的环境。 第二行 ADD 是将本地的代码放置到虚拟容器中，它有两个参数，第一个参数是 . ，即代表本地当前路径，/code 代表虚拟容器中的路径，也就是将本地项目所有内容放置到虚拟容器的 /code 目录下。 第三行 WORKDIR 是指定工作目录，在这里将刚才我们添加的代码路径设成工作路径，在这个路径下的目录结构和我们当前本地目录结构是相同的，所以可以直接执行库安装命令等。 第四行 COPY 是将当前目录下的 scrapyd.conf 文件拷贝到虚拟容器的 /etc/scrapyd/ 目录下，Scrapyd 在运行的时候会默认读取这个配置。 第五行 EXPOSE 是声明运行时容器提供服务端口，注意这里只是一个声明，在运行时不一定就会在此端口开启服务。这样的声明一是告诉使用者这个镜像服务的运行端口，以方便配置映射。另一个用处则是在运行时使用随机端口映射时，会自动随机映射 EXPOSE 的端口。 第六行 RUN 是执行某些命令，一般做一些环境准备工作，由于 Docker 虚拟容器内只有 Python3 环境，而没有我们所需要的一些 Python 库，所以在这里我们运行此命令来在虚拟容器中安装相应的 Python 库，这样项目部署到 Scrapyd 中便可以正常运行了。 第七行 CMD 是容器启动命令，在容器运行时，会直接执行此命令，在这里我们直接用 scrapyd 来启动 Scrapyd 服务。 到现在基本的工作就完成了，运行如下命令进行构建：</p>
                  <figure class="highlight mipsasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker <span class="keyword">build </span>-t <span class="keyword">scrapyd:latest </span>.</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>构建成功后即可运行测试：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker run -d -p <span class="number">6800</span>:<span class="number">6800</span> scrapyd</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行之后我们打开：<a href="http://localhost:6800" target="_blank" rel="noopener">http://localhost:6800</a> 即可观察到 Scrapyd 服务，如图 15-2 所示： <img src="https://cdn.cuiqingcai.com/2019-11-29-114136.png" alt=""> 图 15-2 Scrapyd 主页 这样我们就完成了 Scrapyd Docker 镜像的构建并成功运行了。 然后我们可以将此镜像上传到 Docker Hub，例如我的 Docker Hub 用户名为 germey，新建了一个名为 scrapyd 的项目，首先可以打一个标签：</p>
                  <figure class="highlight crmsh">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker <span class="keyword">tag</span> <span class="title">scrapyd</span>:latest germey/scrapyd:latest</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里请自行替换成你的项目名称。 然后 Push 即可：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">docker</span> <span class="keyword">push </span>germey/scrapyd:latest</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>之后我们在其他主机运行此命令即可启动 Scrapyd 服务：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker run -d -p <span class="number">6800</span>:<span class="number">6800</span> germey/scrapyd</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>执行命令后会发现 Scrapyd 就可以成功在其他服务器上运行了。</p>
                  <h3 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h3>
                  <p>这样我们就利用 Docker 解决了 Python 环境的问题，在后一节我们再解决一个批量部署 Docker 的问题就可以解决批量部署问题了。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-11 10:13:48" itemprop="dateCreated datePublished" datetime="2019-12-11T10:13:48+08:00">2019-12-11</time>
                </span>
                <span id="/8494.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 15.3–Scrapyd 对接 Docker" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8491.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8491.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 15.2–Scrapyd-Client 的使用</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="15-2-Scrapyd-Client-的使用"><a href="#15-2-Scrapyd-Client-的使用" class="headerlink" title="15.2 Scrapyd-Client 的使用"></a>15.2 Scrapyd-Client 的使用</h1>
                  <p>这里有现成的工具来完成部署过程，它叫作 Scrapyd-Client。本节将简单介绍使用 Scrapyd-Client 部署 Scrapy 项目的方法。</p>
                  <h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3>
                  <p>请先确保 Scrapyd-Client 已经正确安装，安装方式可以参考第 1 章的内容。</p>
                  <h3 id="2-Scrapyd-Client-的功能"><a href="#2-Scrapyd-Client-的功能" class="headerlink" title="2. Scrapyd-Client 的功能"></a>2. Scrapyd-Client 的功能</h3>
                  <p>Scrapyd-Client 为了方便 Scrapy 项目的部署，提供两个功能：</p>
                  <ul>
                    <li>将项目打包成 Egg 文件。</li>
                    <li>将打包生成的 Egg 文件通过 addversion.json 接口部署到 Scrapyd 上。</li>
                  </ul>
                  <p>也就是说，Scrapyd-Client 帮我们把部署全部实现了，我们不需要再去关心 Egg 文件是怎样生成的，也不需要再去读 Egg 文件并请求接口上传了，这一切的操作只需要执行一个命令即可一键部署。</p>
                  <h3 id="3-Scrapyd-Client-部署"><a href="#3-Scrapyd-Client-部署" class="headerlink" title="3. Scrapyd-Client 部署"></a>3. Scrapyd-Client 部署</h3>
                  <p>要部署 Scrapy 项目，我们首先需要修改一下项目的配置文件，例如我们之前写的 Scrapy 微博爬虫项目，在项目的第一层会有一个 scrapy.cfg 文件，它的内容如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[settings]</span><br><span class="line">default = weibo.settings</span><br><span class="line"></span><br><span class="line">[deploy]</span><br><span class="line"><span class="comment">#url = http://localhost:6800/</span></span><br><span class="line">project = weibo</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们需要配置一下 deploy 部分，例如我们要将项目部署到 120.27.34.25 的 Scrapyd 上，就需要修改为如下内容：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section">[deploy]</span></span><br><span class="line"><span class="attr">url</span> = http://<span class="number">120.27</span>.<span class="number">34.25</span>:<span class="number">6800</span>/</span><br><span class="line"><span class="attr">project</span> = weibo</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们再在 scrapy.cfg 文件所在路径执行如下命令：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapyd-deploy</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Packing <span class="keyword">version</span> <span class="number">1501682277</span></span><br><span class="line">Deploying <span class="keyword">to</span> project "weibo" <span class="keyword">in</span> http://<span class="number">120.27</span><span class="number">.34</span><span class="number">.25</span>:<span class="number">6800</span>/addversion.json</span><br><span class="line"><span class="keyword">Server</span> response (<span class="number">200</span>):</span><br><span class="line">&#123;"status": "ok", "spiders": <span class="number">1</span>, "node_name": "datacrawl-vm", "project": "weibo", "version": "1501682277"&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回这样的结果就代表部署成功了。 我们也可以指定项目版本，如果不指定的话默认为当前时间戳，指定的话通过 version 参数传递即可，例如：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapyd-deploy <span class="comment">--version 201707131455</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>值得注意的是在 Python3 的 Scrapyd 1.2.0 版本中我们不要指定版本号为带字母的字符串，需要为纯数字，否则可能会出现报错。 另外如果我们有多台主机，我们可以配置各台主机的别名，例如可以修改配置文件为：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section">[deploy:vm1]</span></span><br><span class="line"><span class="attr">url</span> = http://<span class="number">120.27</span>.<span class="number">34.24</span>:<span class="number">6800</span>/</span><br><span class="line"><span class="attr">project</span> = weibo</span><br><span class="line"></span><br><span class="line"><span class="section">[deploy:vm2]</span></span><br><span class="line"><span class="attr">url</span> = http://<span class="number">139.217</span>.<span class="number">26.30</span>:<span class="number">6800</span>/</span><br><span class="line"><span class="attr">project</span> = weibo</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>有多台主机的话就在此统一配置，一台主机对应一组配置，在 deploy 后面加上主机的别名即可，这样如果我们想将项目部署到 IP 为 139.217.26.30 的 vm2 主机，我们只需要执行如下命令：</p>
                  <figure class="highlight gcode">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapyd-deploy v<span class="name">m2</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以将项目部署到名称为 vm2 的主机上了。 如此一来，如果我们有多台主机，我们只需要在 scrapy.cfg 文件中配置好各台主机的 Scrapyd 地址，然后调用 scrapyd-deploy 命令加主机名称即可实现部署，非常方便。 如果 Scrapyd 设置了访问限制的话，我们可以在配置文件中加入用户名和密码的配置，同时端口修改一下，修改成 Nginx 代理端口，如在第一章我们使用的是 6801，那么这里就需要改成 6801，修改如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section">[deploy:vm1]</span></span><br><span class="line"><span class="attr">url</span> = http://<span class="number">120.27</span>.<span class="number">34.24</span>:<span class="number">6801</span>/</span><br><span class="line"><span class="attr">project</span> = weibo</span><br><span class="line"><span class="attr">username</span> = admin</span><br><span class="line"><span class="attr">password</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="section">[deploy:vm2]</span></span><br><span class="line"><span class="attr">url</span> = http://<span class="number">139.217</span>.<span class="number">26.30</span>:<span class="number">6801</span>/</span><br><span class="line"><span class="attr">project</span> = weibo</span><br><span class="line"><span class="attr">username</span> = germey</span><br><span class="line"><span class="attr">password</span> = germey</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样通过加入 username 和 password 字段我们就可以在部署时自动进行 Auth 验证，然后成功实现部署。</p>
                  <h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h3>
                  <p>本节介绍了利用 Scrapyd-Client 来方便地将项目部署到 Scrapyd 的过程，有了它部署不再是麻烦事。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-11 09:55:47" itemprop="dateCreated datePublished" datetime="2019-12-11T09:55:47+08:00">2019-12-11</time>
                </span>
                <span id="/8491.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 15.2–Scrapyd-Client 的使用" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8475.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8475.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 15.1–Scrapyd 分布式部署</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="15-1-Scrapyd-分布式部署"><a href="#15-1-Scrapyd-分布式部署" class="headerlink" title="15.1 Scrapyd 分布式部署"></a>15.1 Scrapyd 分布式部署</h1>
                  <p>分布式爬虫完成并可以成功运行了，但是有个环节非常烦琐，那就是代码部署。 我们设想下面的几个场景。</p>
                  <ul>
                    <li>如果采用上传文件的方式部署代码，我们首先将代码压缩，然后采用 SFTP 或 FTP 的方式将文件上传到服务器，之后再连接服务器将文件解压，每个服务器都需要这样配置。</li>
                    <li>如果采用 Git 同步的方式部署代码，我们可以先把代码 Push 到某个 Git 仓库里，然后再远程连接各台主机执行 Pull 操作，同步代码，每个服务器同样需要做一次操作。</li>
                  </ul>
                  <p>如果代码突然有更新，那我们必须更新每个服务器，而且万一哪台主机的版本没控制好，这可能会影响整体的分布式爬取状况。 所以我们需要一个更方便的工具来部署 Scrapy 项目，如果可以省去一遍遍逐个登录服务器部署的操作，那将会方便很多。 本节我们就来看看提供分布式部署的工具 Scrapyd。</p>
                  <h3 id="1-了解-Scrapyd"><a href="#1-了解-Scrapyd" class="headerlink" title="1. 了解 Scrapyd"></a>1. 了解 Scrapyd</h3>
                  <p>Scrapyd 是一个运行 Scrapy 爬虫的服务程序，它提供一系列 HTTP 接口来帮助我们部署、启动、停止、删除爬虫程序。Scrapyd 支持版本管理，同时还可以管理多个爬虫任务，利用它我们可以非常方便地完成 Scrapy 爬虫项目的部署任务调度。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>请确保本机或服务器已经正确安装好了 Scrapyd，安装和配置的方法可以参见第 1 章的内容。</p>
                  <h3 id="3-访问-Scrapyd"><a href="#3-访问-Scrapyd" class="headerlink" title="3. 访问 Scrapyd"></a>3. 访问 Scrapyd</h3>
                  <p>安装并运行了 Scrapyd 之后，我们就可以访问服务器的 6800 端口看到一个 WebUI 页面了，例如我的服务器地址为 120.27.34.25，在上面安装好了 Scrapyd 并成功运行，那么我就可以在本地的浏览器中打开：<a href="http://120.27.34.25:6800" target="_blank" rel="noopener">http://120.27.34.25:6800</a>，就可以看到 Scrapyd 的首页，这里请自行替换成你的服务器地址查看即可，如图 15-1 所示： <img src="https://cdn.cuiqingcai.com/2019-11-29-114054.png" alt=""> 图 15-1 Scrapyd 首页 如果可以成功访问到此页面，那么证明 Scrapyd 配置就没有问题了。</p>
                  <h3 id="4-Scrapyd-的功能"><a href="#4-Scrapyd-的功能" class="headerlink" title="4. Scrapyd 的功能"></a>4. Scrapyd 的功能</h3>
                  <p>Scrapyd 提供了一系列 HTTP 接口来实现各种操作，在这里我们可以将接口的功能梳理一下，以 Scrapyd 所在的 IP 为 120.27.34.25 为例：</p>
                  <h4 id="daemonstatus-json"><a href="#daemonstatus-json" class="headerlink" title="daemonstatus.json"></a>daemonstatus.json</h4>
                  <p>这个接口负责查看 Scrapyd 当前的服务和任务状态，我们可以用 curl 命令来请求这个接口，命令如下：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//139.217.26.30:6800/daemonstatus.json</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就会得到如下结果：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"finished"</span>: <span class="number">90</span>, <span class="attr">"running"</span>: <span class="number">9</span>, <span class="attr">"node_name"</span>: <span class="string">"datacrawl-vm"</span>, <span class="attr">"pending"</span>: <span class="number">0</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回结果是 Json 字符串，status 是当前运行状态， finished 代表当前已经完成的 Scrapy 任务，running 代表正在运行的 Scrapy 任务，pending 代表等待被调度的 Scrapyd 任务，node_name 就是主机的名称。</p>
                  <h4 id="addversion-json"><a href="#addversion-json" class="headerlink" title="addversion.json"></a>addversion.json</h4>
                  <p>这个接口主要是用来部署 Scrapy 项目用的，在部署的时候我们需要首先将项目打包成 Egg 文件，然后传入项目名称和部署版本。 我们可以用如下的方式实现项目部署：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="keyword">http</span>://<span class="number">120.27</span><span class="number">.34</span><span class="number">.25</span>:<span class="number">6800</span>/addversion.json -F project=wenbo -F <span class="built_in">version</span>=<span class="keyword">first</span> -F egg=@weibo.egg</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里 -F 即代表添加一个参数，同时我们还需要将项目打包成 Egg 文件放到本地。 这样发出请求之后我们可以得到如下结果：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"spiders"</span>: <span class="number">3</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个结果表明部署成功，并且其中包含的 Spider 的数量为 3。 此方法部署可能比较繁琐，在后文会介绍更方便的工具来实现项目的部署。</p>
                  <h4 id="schedule-json"><a href="#schedule-json" class="headerlink" title="schedule.json"></a>schedule.json</h4>
                  <p>这个接口负责调度已部署好的 Scrapy 项目运行。 我们可以用如下接口实现任务调度：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/schedule.json -d project=weibo -d spider=weibocn</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要传入两个参数，project 即 Scrapy 项目名称，spider 即 Spider 名称。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"jobid"</span>: <span class="string">"6487ec79947edab326d6db28a2d86511e8247444"</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表 Scrapy 项目启动情况，jobid 代表当前正在运行的爬取任务代号。</p>
                  <h4 id="cancel-json"><a href="#cancel-json" class="headerlink" title="cancel.json"></a>cancel.json</h4>
                  <p>这个接口可以用来取消某个爬取任务，如果这个任务是 pending 状态，那么它将会被移除，如果这个任务是 running 状态，那么它将会被终止。 我们可以用下面的命令来取消任务的运行：</p>
                  <figure class="highlight dns">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl http://<span class="number">120.27.34.25</span>:<span class="number">6800</span>/cancel.json -d project=weibo -d job=<span class="number">6487</span>ec79947edab326d6db28a2d865<span class="number">11e8247444</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要传入两个参数，project 即项目名称，job 即爬取任务代号。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"prevstate"</span>: <span class="string">"running"</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，prevstate 代表之前的运行状态。</p>
                  <h4 id="listprojects-json"><a href="#listprojects-json" class="headerlink" title="listprojects.json"></a>listprojects.json</h4>
                  <p>这个接口用来列出部署到 Scrapyd 服务上的所有项目描述。 我们可以用下面的命令来获取 Scrapyd 服务器上的所有项目描述：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/listprojects.json</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里不需要传入任何参数。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"projects"</span>: [<span class="string">"weibo"</span>, <span class="string">"zhihu"</span>]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，projects 是项目名称列表。</p>
                  <h4 id="listversions-json"><a href="#listversions-json" class="headerlink" title="listversions.json"></a>listversions.json</h4>
                  <p>这个接口用来获取某个项目的所有版本号，版本号是按序排列的，最后一个条目是最新的版本号。 我们可以用如下命令来获取项目的版本号：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/listversions.json?project=weibo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要一个参数 project，就是项目的名称。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"versions"</span>: [<span class="string">"v1"</span>, <span class="string">"v2"</span>]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，versions 是版本号列表。</p>
                  <h4 id="listspiders-json"><a href="#listspiders-json" class="headerlink" title="listspiders.json"></a>listspiders.json</h4>
                  <p>这个接口用来获取某个项目最新的一个版本的所有 Spider 名称。 我们可以用如下命令来获取项目的 Spider 名称：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/listspiders.json?project=weibo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要一个参数 project，就是项目的名称。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>, <span class="attr">"spiders"</span>: [<span class="string">"weibocn"</span>]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，spiders 是 Spider 名称列表。</p>
                  <h4 id="listjobs-json"><a href="#listjobs-json" class="headerlink" title="listjobs.json"></a>listjobs.json</h4>
                  <p>这个接口用来获取某个项目当前运行的所有任务详情。 我们可以用如下命令来获取所有任务详情：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/listjobs.json?project=weibo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要一个参数 project，就是项目的名称。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>,</span><br><span class="line"> <span class="attr">"pending"</span>: [&#123;<span class="attr">"id"</span>: <span class="string">"78391cc0fcaf11e1b0090800272a6d06"</span>, <span class="attr">"spider"</span>: <span class="string">"weibocn"</span>&#125;],</span><br><span class="line"> <span class="attr">"running"</span>: [&#123;<span class="attr">"id"</span>: <span class="string">"422e608f9f28cef127b3d5ef93fe9399"</span>, <span class="attr">"spider"</span>: <span class="string">"weibocn"</span>, <span class="attr">"start_time"</span>: <span class="string">"2017-07-12 10:14:03.594664"</span>&#125;],</span><br><span class="line"> <span class="attr">"finished"</span>: [&#123;<span class="attr">"id"</span>: <span class="string">"2f16646cfcaf11e1b0090800272a6d06"</span>, <span class="attr">"spider"</span>: <span class="string">"weibocn"</span>, <span class="attr">"start_time"</span>: <span class="string">"2017-07-12 10:14:03.594664"</span>, <span class="attr">"end_time"</span>: <span class="string">"2017-07-12 10:24:03.594664"</span>&#125;]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，pendings 代表当前正在等待的任务，running 代表当前正在运行的任务，finished 代表已经完成的任务。</p>
                  <h4 id="delversion-json"><a href="#delversion-json" class="headerlink" title="delversion.json"></a>delversion.json</h4>
                  <p>这个接口用来删除项目的某个版本。 我们可以用如下命令来删除项目版本：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/delversion.json -d project=weibo -d version=v1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要一个参数 project，就是项目的名称，还需要一个参数 version，就是项目的版本。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，这样就代表删除成功了。</p>
                  <h4 id="delproject-json"><a href="#delproject-json" class="headerlink" title="delproject.json"></a>delproject.json</h4>
                  <p>这个接口用来删除某个项目。 我们可以用如下命令来删除某个项目：</p>
                  <figure class="highlight groovy">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl <span class="string">http:</span><span class="comment">//120.27.34.25:6800/delproject.json -d project=weibo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里需要一个参数 project，就是项目的名称。 返回结果如下：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"status"</span>: <span class="string">"ok"</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>status 代表请求执行情况，这样就代表删除成功了。 以上就是 Scrapyd 所有的接口，我们可以直接请求 HTTP 接口即可控制项目的部署、启动、运行等操作。</p>
                  <h3 id="5-ScrapydAPI-的使用"><a href="#5-ScrapydAPI-的使用" class="headerlink" title="5. ScrapydAPI 的使用"></a>5. ScrapydAPI 的使用</h3>
                  <p>以上的这些接口可能使用起来还不是很方便，没关系，还有一个 ScrapydAPI 库对这些接口又做了一层封装，其安装方式也可以参考第一章的内容。 下面我们来看下 ScrapydAPI 的使用方法，其实核心原理和 HTTP 接口请求方式并无二致，只不过用 Python 封装后使用更加便捷。 我们可以用如下方式建立一个 ScrapydAPI 对象：</p>
                  <figure class="highlight clean">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapyd_api <span class="keyword">import</span> ScrapydAPI</span><br><span class="line">scrapyd = ScrapydAPI(<span class="string">'http://120.27.34.25:6800'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后就可以调用它的方法来实现对应接口的操作了，例如部署的操作可以使用如下方式：</p>
                  <figure class="highlight sas">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">egg =<span class="meta"> open(</span><span class="string">'weibo.egg'</span>, <span class="string">'rb'</span>)</span><br><span class="line">scrapyd.add_versi<span class="meta">on(</span><span class="string">'weibo'</span>, <span class="string">'v1'</span>, egg)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以将项目打包为 Egg 文件，然后把本地打包的的 Egg 项目部署到远程 Scrapyd 了。 另外 ScrapydAPI 还实现了所有 Scrapyd 提供的 API 接口，名称都是相同的，参数也是相同的。 例如我们可以调用 list_projects() 方法即可列出 Scrapyd 中所有已部署的项目：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapyd</span><span class="selector-class">.list_projects</span>()</span><br><span class="line"><span class="selector-attr">[<span class="string">'weibo'</span>, <span class="string">'zhihu'</span>]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外还有其他的方法在此不再一一列举了，名称和参数都是相同的，更加详细的操作可以参考其官方文档：<a href="http://python-scrapyd-api.readthedocs.io/" target="_blank" rel="noopener">http://python-scrapyd-api.readthedocs.io/</a>。</p>
                  <h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h3>
                  <p>本节介绍了 Scrapyd 及 ScrapydAPI 的相关用法，我们可以通过它来部署项目，并通过 HTTP 接口来控制人物的运行，不过这里有一个不方便的地方就是部署过程，首先它需要打包 Egg 文件然后再上传，还是比较繁琐的，在下一节我们介绍一个更加方便的工具来完成部署过程。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-10 09:26:07" itemprop="dateCreated datePublished" datetime="2019-12-10T09:26:07+08:00">2019-12-10</time>
                </span>
                <span id="/8475.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 15.1–Scrapyd 分布式部署" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>4.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>4 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8472.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8472.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 14.4–Bloom Filter 的对接</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="14-4-Bloom-Filter-的对接"><a href="#14-4-Bloom-Filter-的对接" class="headerlink" title="14.4 Bloom Filter 的对接"></a>14.4 Bloom Filter 的对接</h1>
                  <p>首先回顾一下 Scrapy-Redis 的去重机制。Scrapy-Redis 将 Request 的指纹存储到了 Redis 集合中，每个指纹的长度为 40，例如 27adcc2e8979cdee0c9cecbbe8bf8ff51edefb61 就是一个指纹，它的每一位都是 16 进制数。 我们计算一下用这种方式耗费的存储空间。每个十六进制数占用 4 b，1 个指纹用 40 个十六进制数表示，占用空间为 20 B，1 万个指纹即占用空间 200 KB，1 亿个指纹占用 2 GB。当爬取数量达到上亿级别时，Redis 的占用的内存就会变得很大，而且这仅仅是指纹的存储。Redis 还存储了爬取队列，内存占用会进一步提高，更别说有多个 Scrapy 项目同时爬取的情况了。当爬取达到亿级别规模时，Scrapy-Redis 提供的集合去重已经不能满足我们的要求。所以我们需要使用一个更加节省内存的去重算法 Bloom Filter。</p>
                  <h3 id="1-了解-BloomFilter"><a href="#1-了解-BloomFilter" class="headerlink" title="1. 了解 BloomFilter"></a>1. 了解 BloomFilter</h3>
                  <p>Bloom Filter，中文名称叫作布隆过滤器，是 1970 年由 Bloom 提出的，它可以被用来检测一个元素是否在一个集合中。Bloom Filter 的空间利用效率很高，使用它可以大大节省存储空间。Bloom Filter 使用位数组表示一个待检测集合，并可以快速地通过概率算法判断一个元素是否存在于这个集合中。利用这个算法我们可以实现去重效果。 本节我们来了解 Bloom Filter 的基本算法，以及 Scrapy-Redis 中对接 Bloom Filter 的方法。</p>
                  <h3 id="2-BloomFilter-的算法"><a href="#2-BloomFilter-的算法" class="headerlink" title="2. BloomFilter 的算法"></a>2. BloomFilter 的算法</h3>
                  <p>在 Bloom Filter 中使用位数组来辅助实现检测判断。在初始状态下，我们声明一个包含 m 位的位数组，它的所有位都是 0，如图 14-7 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-113850.jpg" alt=""> 图 14-7 初始位数组 现在我们有了一个待检测集合，我们表示为 S={x1, x2, …, xn}，我们接下来需要做的就是检测一个 x 是否已经存在于集合 S 中。在 BloomFilter 算法中首先使用 k 个相互独立的、随机的哈希函数来将这个集合 S 中的每个元素 x1、x2、…、xn 映射到这个长度为 m 的位数组上，哈希函数得到的结果记作位置索引，然后将位数组该位置索引的位置 1。例如这里我们取 k 为 3，即有三个哈希函数，x1 经过三个哈希函数映射得到的结果分别为 1、4、8，x2 经过三个哈希函数映射得到的结果分别为 4、6、10，那么就会将位数组的 1、4、6、8、10 这五位置 1，如图 14-8 所示： <img src="https://cdn.cuiqingcai.com/2019-11-29-114343.jpg" alt=""> 图 14-8 映射后位数组 这时如果再有一个新的元素 x，我们要判断 x 是否属于 S 这个集合，我们便会将仍然用 k 个哈希函数对 x 求映射结果，如果所有结果对应的位数组位置均为 1，那么我们就认为 x 属于 S 这个集合，否则如果有一个不为 1，则 x 不属于 S 集合。 例如一个新元素 x 经过三个哈希函数映射的结果为 4、6、8，对应的位置均为 1，则判断 x 属于 S 这个集合。如果结果为 4、6、7，7 对应的位置为 0，则判定 x 不属于 S 这个集合。 注意这里 m、n、k 满足的关系是 m&gt;nk，也就是说位数组的长度 m 要比集合元素 n 和哈希函数 k 的乘积还要大。 这样的判定方法很高效，但是也是有代价的，它可能把不属于这个集合的元素误认为属于这个集合，我们来估计一下它的错误率。当集合 S={x1, x2,…, xn} 的所有元素都被 k 个哈希函数映射到 m 位的位数组中时，这个位数组中某一位还是 0 的概率是： <img src="https://cdn.cuiqingcai.com/2019-11-29-114353.jpg" alt=""> 因为哈希函数是随机的，所以任意一个哈希函数选中这一位的概率为 1/m，那么 1-1/m 就代表哈希函数一次没有选中这一位的概率，要把 S 完全映射到 m 位数组中，需要做 kn 次哈希运算，所以最后的概率就是 1-1/m 的 kn 次方。 一个不属于 S 的元素 x 如果要被误判定为在 S 中，那么这个概率就是 k 次哈希运算得到的结果对应的位数组位置都为 1，所以误判概率为： <img src="https://cdn.cuiqingcai.com/2019-11-29-114430.jpg" alt=""> 根据： <img src="https://cdn.cuiqingcai.com/2019-11-29-114441.jpg" alt=""> 可以将误判概率转化为： <img src="https://cdn.cuiqingcai.com/2019-11-29-114445.jpg" alt=""> 在给定 m、n 时，可以求出使得 f 最小化的 k 值为： <img src="https://cdn.cuiqingcai.com/2019-11-29-114452.jpg" alt=""> 在这里将误判概率归纳如下： 表 14-1 　误判概率</p>
                  <p>m/n</p>
                  <p>最优 k</p>
                  <p>k=1</p>
                  <p>k=2</p>
                  <p>k=3</p>
                  <p>k=4</p>
                  <p>k=5</p>
                  <p>k=6</p>
                  <p>k=7</p>
                  <p>k=8</p>
                  <p>2</p>
                  <p>1.39</p>
                  <p>0.393</p>
                  <p>0.400</p>
                  <p>3</p>
                  <p>2.08</p>
                  <p>0.283</p>
                  <p>0.237</p>
                  <p>0.253</p>
                  <p>4</p>
                  <p>2.77</p>
                  <p>0.221</p>
                  <p>0.155</p>
                  <p>0.147</p>
                  <p>0.160</p>
                  <p>5</p>
                  <p>3.46</p>
                  <p>0.181</p>
                  <p>0.109</p>
                  <p>0.092</p>
                  <p>0.092</p>
                  <p>0.101</p>
                  <p>6</p>
                  <p>4.16</p>
                  <p>0.154</p>
                  <p>0.0804</p>
                  <p>0.0609</p>
                  <p>0.0561</p>
                  <p>0.0578</p>
                  <p>0.0638</p>
                  <p>7</p>
                  <p>4.85</p>
                  <p>0.133</p>
                  <p>0.0618</p>
                  <p>0.0423</p>
                  <p>0.0359</p>
                  <p>0.0347</p>
                  <p>0.0364</p>
                  <p>8</p>
                  <p>5.55</p>
                  <p>0.118</p>
                  <p>0.0489</p>
                  <p>0.0306</p>
                  <p>0.024</p>
                  <p>0.0217</p>
                  <p>0.0216</p>
                  <p>0.0229</p>
                  <p>9</p>
                  <p>6.24</p>
                  <p>0.105</p>
                  <p>0.0397</p>
                  <p>0.0228</p>
                  <p>0.0166</p>
                  <p>0.0141</p>
                  <p>0.0133</p>
                  <p>0.0135</p>
                  <p>0.0145</p>
                  <p>10</p>
                  <p>6.93</p>
                  <p>0.0952</p>
                  <p>0.0329</p>
                  <p>0.0174</p>
                  <p>0.0118</p>
                  <p>0.00943</p>
                  <p>0.00844</p>
                  <p>0.00819</p>
                  <p>0.00846</p>
                  <p>11</p>
                  <p>7.62</p>
                  <p>0.0869</p>
                  <p>0.0276</p>
                  <p>0.0136</p>
                  <p>0.00864</p>
                  <p>0.0065</p>
                  <p>0.00552</p>
                  <p>0.00513</p>
                  <p>0.00509</p>
                  <p>12</p>
                  <p>8.32</p>
                  <p>0.08</p>
                  <p>0.0236</p>
                  <p>0.0108</p>
                  <p>0.00646</p>
                  <p>0.00459</p>
                  <p>0.00371</p>
                  <p>0.00329</p>
                  <p>0.00314</p>
                  <p>13</p>
                  <p>9.01</p>
                  <p>0.074</p>
                  <p>0.0203</p>
                  <p>0.00875</p>
                  <p>0.00492</p>
                  <p>0.00332</p>
                  <p>0.00255</p>
                  <p>0.00217</p>
                  <p>0.00199</p>
                  <p>14</p>
                  <p>9.7</p>
                  <p>0.0689</p>
                  <p>0.0177</p>
                  <p>0.00718</p>
                  <p>0.00381</p>
                  <p>0.00244</p>
                  <p>0.00179</p>
                  <p>0.00146</p>
                  <p>0.00129</p>
                  <p>15</p>
                  <p>10.4</p>
                  <p>0.0645</p>
                  <p>0.0156</p>
                  <p>0.00596</p>
                  <p>0.003</p>
                  <p>0.00183</p>
                  <p>0.00128</p>
                  <p>0.001</p>
                  <p>0.000852</p>
                  <p>16</p>
                  <p>11.1</p>
                  <p>0.0606</p>
                  <p>0.0138</p>
                  <p>0.005</p>
                  <p>0.00239</p>
                  <p>0.00139</p>
                  <p>0.000935</p>
                  <p>0.000702</p>
                  <p>0.000574</p>
                  <p>17</p>
                  <p>11.8</p>
                  <p>0.0571</p>
                  <p>0.0123</p>
                  <p>0.00423</p>
                  <p>0.00193</p>
                  <p>0.00107</p>
                  <p>0.000692</p>
                  <p>0.000499</p>
                  <p>0.000394</p>
                  <p>18</p>
                  <p>12.5</p>
                  <p>0.054</p>
                  <p>0.0111</p>
                  <p>0.00362</p>
                  <p>0.00158</p>
                  <p>0.000839</p>
                  <p>0.000519</p>
                  <p>0.00036</p>
                  <p>0.000275</p>
                  <p>19</p>
                  <p>13.2</p>
                  <p>0.0513</p>
                  <p>0.00998</p>
                  <p>0.00312</p>
                  <p>0.0013</p>
                  <p>0.000663</p>
                  <p>0.000394</p>
                  <p>0.000264</p>
                  <p>0.000194</p>
                  <p>20</p>
                  <p>13.9</p>
                  <p>0.0488</p>
                  <p>0.00906</p>
                  <p>0.0027</p>
                  <p>0.00108</p>
                  <p>0.00053</p>
                  <p>0.000303</p>
                  <p>0.000196</p>
                  <p>0.00014</p>
                  <p>21</p>
                  <p>14.6</p>
                  <p>0.0465</p>
                  <p>0.00825</p>
                  <p>0.00236</p>
                  <p>0.000905</p>
                  <p>0.000427</p>
                  <p>0.000236</p>
                  <p>0.000147</p>
                  <p>0.000101</p>
                  <p>22</p>
                  <p>15.2</p>
                  <p>0.0444</p>
                  <p>0.00755</p>
                  <p>0.00207</p>
                  <p>0.000764</p>
                  <p>0.000347</p>
                  <p>0.000185</p>
                  <p>0.000112</p>
                  <p>7.46e-05</p>
                  <p>23</p>
                  <p>15.9</p>
                  <p>0.0425</p>
                  <p>0.00694</p>
                  <p>0.00183</p>
                  <p>0.000649</p>
                  <p>0.000285</p>
                  <p>0.000147</p>
                  <p>8.56e-05</p>
                  <p>5.55e-05</p>
                  <p>24</p>
                  <p>16.6</p>
                  <p>0.0408</p>
                  <p>0.00639</p>
                  <p>0.00162</p>
                  <p>0.000555</p>
                  <p>0.000235</p>
                  <p>0.000117</p>
                  <p>6.63e-05</p>
                  <p>4.17e-05</p>
                  <p>25</p>
                  <p>17.3</p>
                  <p>0.0392</p>
                  <p>0.00591</p>
                  <p>0.00145</p>
                  <p>0.000478</p>
                  <p>0.000196</p>
                  <p>9.44e-05</p>
                  <p>5.18e-05</p>
                  <p>3.16e-05</p>
                  <p>26</p>
                  <p>18</p>
                  <p>0.0377</p>
                  <p>0.00548</p>
                  <p>0.00129</p>
                  <p>0.000413</p>
                  <p>0.000164</p>
                  <p>7.66e-05</p>
                  <p>4.08e-05</p>
                  <p>2.42e-05</p>
                  <p>27</p>
                  <p>18.7</p>
                  <p>0.0364</p>
                  <p>0.0051</p>
                  <p>0.00116</p>
                  <p>0.000359</p>
                  <p>0.000138</p>
                  <p>6.26e-05</p>
                  <p>3.24e-05</p>
                  <p>1.87e-05</p>
                  <p>28</p>
                  <p>19.4</p>
                  <p>0.0351</p>
                  <p>0.00475</p>
                  <p>0.00105</p>
                  <p>0.000314</p>
                  <p>0.000117</p>
                  <p>5.15e-05</p>
                  <p>2.59e-05</p>
                  <p>1.46e-05</p>
                  <p>29</p>
                  <p>20.1</p>
                  <p>0.0339</p>
                  <p>0.00444</p>
                  <p>0.000949</p>
                  <p>0.000276</p>
                  <p>9.96e-05</p>
                  <p>4.26e-05</p>
                  <p>2.09e-05</p>
                  <p>1.14e-05</p>
                  <p>30</p>
                  <p>20.8</p>
                  <p>0.0328</p>
                  <p>0.00416</p>
                  <p>0.000862</p>
                  <p>0.000243</p>
                  <p>8.53e-05</p>
                  <p>3.55e-05</p>
                  <p>1.69e-05</p>
                  <p>9.01e-06</p>
                  <p>31</p>
                  <p>21.5</p>
                  <p>0.0317</p>
                  <p>0.0039</p>
                  <p>0.000785</p>
                  <p>0.000215</p>
                  <p>7.33e-05</p>
                  <p>2.97e-05</p>
                  <p>1.38e-05</p>
                  <p>7.16e-06</p>
                  <p>32</p>
                  <p>22.2</p>
                  <p>0.0308</p>
                  <p>0.00367</p>
                  <p>0.000717</p>
                  <p>0.000191</p>
                  <p>6.33e-05</p>
                  <p>2.5e-05</p>
                  <p>1.13e-05</p>
                  <p>5.73e-06</p>
                  <p>表 14-1 中第一列为 m/n 的值，第二列为最优 k 值，其后列为不同 k 值的误判概率，可以看到当 k 值确定时，随着 m/n 的增大，误判概率逐渐变小。当 m/n 的值确定时，当 k 越靠近最优 K 值，误判概率越小。另外误判概率总体来看都是极小的，在容忍此误判概率的情况下，大幅减小存储空间和判定速度是完全值得的。 接下来我们就将 BloomFilter 算法应用到 Scrapy-Redis 分布式爬虫的去重过程中，以解决 Redis 内存不足的问题。</p>
                  <h3 id="3-对接-Scrapy-Redis"><a href="#3-对接-Scrapy-Redis" class="headerlink" title="3. 对接 Scrapy-Redis"></a>3. 对接 Scrapy-Redis</h3>
                  <p>实现 BloomFilter 时，我们首先要保证不能破坏 Scrapy-Redis 分布式爬取的运行架构，所以我们需要修改 Scrapy-Redis 的源码，将它的去重类替换掉。同时 BloomFilter 的实现需要借助于一个位数组，所以既然当前架构还是依赖于 Redis 的，那么正好位数组的维护直接使用 Redis 就好了。 首先我们实现一个基本的哈希算法，可以实现将一个值经过哈希运算后映射到一个 m 位位数组的某一位上，代码实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, m, seed)</span>:</span></span><br><span class="line">        self.m = m</span><br><span class="line">        self.seed = seed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Hash Algorithm</span></span><br><span class="line"><span class="string">        :param value: Value</span></span><br><span class="line"><span class="string">        :return: Hash Value</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span><br><span class="line">            ret += self.seed * ret + ord(value[i])</span><br><span class="line">        <span class="keyword">return</span> (self.m - <span class="number">1</span>) &amp; ret</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里新建了一个 HashMap 类，构造函数传入两个值，一个是 m 位数组的位数，另一个是种子值 seed，不同的哈希函数需要有不同的 seed，这样可以保证不同的哈希函数的结果不会碰撞。 在 hash() 方法的实现中，value 是要被处理的内容，在这里我们遍历了该字符的每一位并利用 ord() 方法取到了它的 ASCII 码值，然后混淆 seed 进行迭代求和运算，最终会得到一个数值。这个数值的结果就由 value 和 seed 唯一确定，然后我们再将它和 m 进行按位与运算，即可获取到 m 位数组的映射结果，这样我们就实现了一个由字符串和 seed 来确定的哈希函数。当 m 固定时，只要 seed 值相同，就代表是同一个哈希函数，相同的 value 必然会映射到相同的位置。所以如果我们想要构造几个不同的哈希函数，只需要改变其 seed 就好了，以上便是一个简易的哈希函数的实现。 接下来我们再实现 BloomFilter，BloomFilter 里面需要用到 k 个哈希函数，所以在这里我们需要对这几个哈希函数指定相同的 m 值和不同的 seed 值，在这里构造如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">BLOOMFILTER_HASH_NUMBER = 6</span><br><span class="line">BLOOMFILTER_BIT = 30</span><br><span class="line"></span><br><span class="line">class BloomFilter(object):</span><br><span class="line">    def __init__(self, server, key, <span class="attribute">bit</span>=BLOOMFILTER_BIT, <span class="attribute">hash_number</span>=BLOOMFILTER_HASH_NUMBER):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        Initialize BloomFilter</span></span><br><span class="line"><span class="string">        :param server: Redis Server</span></span><br><span class="line"><span class="string">        :param key: BloomFilter Key</span></span><br><span class="line"><span class="string">        :param bit: m = 2 ^ bit</span></span><br><span class="line"><span class="string">        :param hash_number: the number of hash function</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        #<span class="built_in"> default </span><span class="keyword">to</span> 1 &lt;&lt; 30 = 10,7374,1824 = 2^30 = 128MB, max<span class="built_in"> filter </span>2^30/hash_number = 1,7895,6970 fingerprints</span><br><span class="line">        self.m = 1 &lt;&lt; bit</span><br><span class="line">        self.seeds = range(hash_number)</span><br><span class="line">        self.maps = [HashMap(self.m, seed) <span class="keyword">for</span> seed <span class="keyword">in</span> self.seeds]</span><br><span class="line">        self.server = server</span><br><span class="line">        self.key = key</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于我们需要亿级别的数据的去重，即前文介绍的算法中的 n 为 1 亿以上，哈希函数的个数 k 大约取 10 左右的量级，而 m&gt;kn，所以这里 m 值大约保底在 10 亿，由于这个数值比较大，所以这里用移位操作来实现，传入位数 bit，定义 30，然后做一个移位操作 1 &lt;&lt; 30，相当于 2 的 30 次方，等于 1073741824，量级也是恰好在 10 亿左右，由于是位数组，所以这个位数组占用的大小就是 2^30b=128MB，而本文开头我们计算过 Scrapy-Redis 集合去重的占用空间大约在 2G 左右，可见 BloomFilter 的空间利用效率之高。 随后我们再传入哈希函数的个数，用它来生成几个不同的 seed，用不同的 seed 来定义不同的哈希函数，这样我们就可以构造一个哈希函数列表，遍历 seed，构造带有不同 seed 值的 HashMap 对象，保存成变量 maps 供后续使用。 另外 server 就是 Redis 连接对象，key 就是这个 m 位数组的名称。 接下来我们就要实现比较关键的两个方法了，一个是判定元素是否重复的方法 exists()，另一个是添加元素到集合中的方法 insert()，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    if value exists</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    exist = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> map <span class="keyword">in</span> self.maps:</span><br><span class="line">        offset = map.hash(value)</span><br><span class="line">        exist = exist &amp; self.server.getbit(self.key, offset)</span><br><span class="line">    <span class="keyword">return</span> exist</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    add value to bloom</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> self.maps:</span><br><span class="line">        offset = f.hash(value)</span><br><span class="line">        self.server.setbit(self.key, offset, <span class="number">1</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先我们先看下 insert() 方法，BloomFilter 算法中会逐个调用哈希函数对放入集合中的元素进行运算得到在 m 位位数组中的映射位置，然后将位数组对应的位置置 1，所以这里在代码中我们遍历了初始化好的哈希函数，然后调用其 hash() 方法算出映射位置 offset，再利用 Redis 的 setbit() 方法将该位置 1。 在 exists() 方法中我们就需要实现判定是否重复的逻辑了，方法参数 value 即为待判断的元素，在这里我们首先定义了一个变量 exist，然后遍历了所有哈希函数对 value 进行哈希运算，得到映射位置，然后我们用 getbit() 方法取得该映射位置的结果，依次进行与运算。这样只有每次 getbit() 得到的结果都为 1 时，最后的 exist 才为 True，即代表 value 属于这个集合。如果其中只要有一次 getbit() 得到的结果为 0，即 m 位数组中有对应的 0 位，那么最终的结果 exist 就为 False，即代表 value 不属于这个集合。这样此方法最后的返回结果就是判定重复与否的结果了。 到现在为止 BloomFilter 的实现就已经完成了，我们可以用一个实例来测试一下，代码如下：</p>
                  <figure class="highlight vim">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">conn = StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, password=<span class="string">'foobared'</span>)</span><br><span class="line"><span class="keyword">bf</span> = BloomFilter(conn, <span class="string">'testbf'</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">bf</span>.<span class="keyword">insert</span>(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="keyword">bf</span>.<span class="keyword">insert</span>(<span class="string">'World'</span>)</span><br><span class="line">result = <span class="keyword">bf</span>.<span class="built_in">exists</span>(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="keyword">print</span>(bool(result))</span><br><span class="line">result = <span class="keyword">bf</span>.<span class="built_in">exists</span>(<span class="string">'Python'</span>)</span><br><span class="line"><span class="keyword">print</span>(bool(result))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们首先定义了一个 Redis 连接对象，然后传递给 BloomFilter，为了避免内存占用过大这里传的位数 bit 比较小，设置为 5，哈希函数的个数设置为 6。 首先我们调用 insert() 方法插入了 Hello 和 World 两个字符串，随后判断了一下 Hello 和 Python 这两个字符串是否存在，最后输出它的结果，运行结果如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>很明显，结果完全没有问题，这样我们就借助于 Redis 成功实现了 BloomFilter 的算法。 接下来我们需要继续修改 Scrapy-Redis 的源码，将它的 dupefilter 逻辑替换为 BloomFilter 的逻辑，在这里主要是修改 RFPDupeFilter 类的 request_seen() 方法，实现如下：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">    fp = <span class="keyword">self</span>.request_fingerprint(request)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.bf.exists(fp)<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    <span class="keyword">self</span>.bf.insert(fp)</span><br><span class="line">    <span class="keyword">return</span> False</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先还是利用 request_fingerprint() 方法获取了 Request 的指纹，然后调用 BloomFilter 的 exists() 方法判定了该指纹是否存在，如果存在，则证明该 Request 是重复的，返回 True，否则调用 BloomFilter 的 insert() 方法将该指纹添加并返回 False，这样就成功利用 BloomFilter 替换了 Scrapy-Redis 的集合去重。 对于 BloomFilter 的初始化定义，我们可以将 <strong>init</strong>() 方法修改为如下内容：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def __init__(self, server, key, debug, bit, hash_number):</span><br><span class="line">    self.server = server</span><br><span class="line">    self.key = key</span><br><span class="line">    self.<span class="builtin-name">debug</span> = debug</span><br><span class="line">    self.bit = bit</span><br><span class="line">    self.hash_number = hash_number</span><br><span class="line">    self.logdupes = <span class="literal">True</span></span><br><span class="line">    self.bf = BloomFilter(server, self.key, bit, hash_number)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中 bit 和 hash_number 需要使用 from_settings() 方法传递，修改如下：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">@classmethod</span><br><span class="line">def from_settings(cls, settings):</span><br><span class="line">    <span class="keyword">server</span> = get_redis_from_settings(settings)</span><br><span class="line">    key = defaults.DUPEFILTER_KEY % &#123;<span class="string">'timestamp'</span>: <span class="type">int</span>(<span class="type">time</span>.time())&#125;</span><br><span class="line">    <span class="keyword">debug</span> = settings.getbool(<span class="string">'DUPEFILTER_DEBUG'</span>, DUPEFILTER_DEBUG)</span><br><span class="line">    <span class="type">bit</span> = settings.getint(<span class="string">'BLOOMFILTER_BIT'</span>, BLOOMFILTER_BIT)</span><br><span class="line">    hash_number = settings.getint(<span class="string">'BLOOMFILTER_HASH_NUMBER'</span>, BLOOMFILTER_HASH_NUMBER)</span><br><span class="line">    <span class="keyword">return</span> cls(<span class="keyword">server</span>, key=key, <span class="keyword">debug</span>=<span class="keyword">debug</span>, <span class="type">bit</span>=<span class="type">bit</span>, hash_number=hash_number)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中常量的定义 DUPEFILTER_DEBUG 和 BLOOMFILTER_BIT 统一定义在 defaults.py 中，默认如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">BLOOMFILTER_HASH_NUMBER</span> = <span class="number">6</span></span><br><span class="line"><span class="attr">BLOOMFILTER_BIT</span> = <span class="number">30</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>到此为止我们就成功实现了 BloomFilter 和 Scrapy-Redis 的对接。</p>
                  <h3 id="4-本节代码"><a href="#4-本节代码" class="headerlink" title="4. 本节代码"></a>4. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/ScrapyRedisBloomFilter" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyRedisBloomFilter</a>。</p>
                  <h3 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h3>
                  <p>为了方便使用，本节的代码已经打包成了一个 Python 包并发布到了 PyPi，链接为：<a href="https://pypi.python.org/pypi/scrapy-redis-bloomfilter" target="_blank" rel="noopener">https://pypi.python.org/pypi/scrapy-redis-bloomfilter</a>，因此我们以后如果想使用 ScrapyRedisBloomFilter 直接使用就好了，不需要再自己实现一遍。 我们可以直接使用 Pip 来安装，命令如下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> scrapy-redis-bloomfilter</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>使用的方法和 Scrapy-Redis 基本相似，在这里说明几个关键配置：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 去重类，要使用 BloomFilter 请替换 DUPEFILTER_CLASS</span></span><br><span class="line"><span class="attr">DUPEFILTER_CLASS</span> = <span class="string">"scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter"</span></span><br><span class="line"><span class="comment"># 哈希函数的个数，默认为 6，可以自行修改</span></span><br><span class="line"><span class="attr">BLOOMFILTER_HASH_NUMBER</span> = <span class="number">6</span></span><br><span class="line"><span class="comment"># BloomFilter 的 bit 参数，默认 30，占用 128MB 空间，去重量级 1 亿</span></span><br><span class="line"><span class="attr">BLOOMFILTER_BIT</span> = <span class="number">30</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>DUPEFILTER_CLASS 是去重类，如果要使用 BloomFilter 需要将 DUPEFILTER_CLASS 修改为该包的去重类。 BLOOMFILTER_HASH_NUMBER 是 BloomFilter 使用的哈希函数的个数，默认为 6，可以根据去重量级自行修改。 BLOOMFILTER_BIT 即前文所介绍的 BloomFilter 类的 bit 参数，它决定了位数组的位数，如果 BLOOMFILTER_BIT 为 30，那么位数组位数为 2 的 30 次方，将占用 Redis 128MB 的存储空间，去重量级在 1 亿左右，即对应爬取量级 1 亿左右。如果爬取量级在 10 亿、20 亿甚至 100 亿，请务必将此参数对应调高。</p>
                  <h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h3>
                  <p>在源代码中附有一个测试项目，放在 tests 文件夹，该项目使用了 Scrapy-RedisBloomFilter 来去重，Spider 的实现如下：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy import Request, Spider</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSpider</span>(<span class="title">Spider</span>):</span></span><br><span class="line">    name = <span class="string">'test'</span></span><br><span class="line">    base_url = <span class="string">'https://www.baidu.com/s?wd='</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="symbol">:</span></span><br><span class="line">            url = <span class="keyword">self</span>.base_url + str(i)</span><br><span class="line">            <span class="keyword">yield</span> Request(url, callback=<span class="keyword">self</span>.parse)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Here contains 10 duplicated Requests</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)<span class="symbol">:</span></span><br><span class="line">            url = <span class="keyword">self</span>.base_url + str(i)</span><br><span class="line">            <span class="keyword">yield</span> Request(url, callback=<span class="keyword">self</span>.parse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.logger.debug(<span class="string">'Response of '</span> + response.url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在 start_requests() 方法中首先循环 10 次，构造参数为 0-9 的 URL，然后重新循环了 100 次，构造了参数为 0-99 的 URL，那么这里就会包含 10 个重复的 Request，我们运行项目测试一下：</p>
                  <figure class="highlight bash">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl <span class="built_in">test</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到最后的输出结果如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">&#123;'bloomfilter/filtered':</span> <span class="number">10</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/request_bytes':</span> <span class="number">34021</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/request_count':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/request_method_count/GET':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/response_bytes':</span> <span class="number">72943</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/response_count':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'downloader/response_status_count/200':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'finish_reason':</span> <span class="string">'finished'</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'finish_time':</span> <span class="string">datetime.datetime(2017,</span> <span class="number">8</span><span class="string">,</span> <span class="number">11</span><span class="string">,</span> <span class="number">9</span><span class="string">,</span> <span class="number">34</span><span class="string">,</span> <span class="number">30</span><span class="string">,</span> <span class="number">419597</span><span class="string">),</span></span><br><span class="line"> <span class="attr">'log_count/DEBUG':</span> <span class="number">202</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'log_count/INFO':</span> <span class="number">7</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'memusage/max':</span> <span class="number">54153216</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'memusage/startup':</span> <span class="number">54153216</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'response_received_count':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'scheduler/dequeued/redis':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'scheduler/enqueued/redis':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'start_time':</span> <span class="string">datetime.datetime(2017,</span> <span class="number">8</span><span class="string">,</span> <span class="number">11</span><span class="string">,</span> <span class="number">9</span><span class="string">,</span> <span class="number">34</span><span class="string">,</span> <span class="number">26</span><span class="string">,</span> <span class="number">495018</span><span class="string">)&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到最后统计的第一行的结果：</p>
                  <figure class="highlight sml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">'bloomfilter</span>/filtered': <span class="number">10</span>,</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是 BloomFilter 过滤后的统计结果，可以看到它的过滤个数为 10 个，也就是它成功将重复的 10 个 Reqeust 识别出来了，测试通过。</p>
                  <h3 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h3>
                  <p>以上便是 BloomFilter 的原理及对接实现，使用了 BloomFilter 可以大大节省 Redis 内存，在数据量大的情况下推荐使用此方案。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-10 09:24:45" itemprop="dateCreated datePublished" datetime="2019-12-10T09:24:45+08:00">2019-12-10</time>
                </span>
                <span id="/8472.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 14.4–Bloom Filter 的对接" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>10k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>9 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8468.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8468.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 14.3–Scrapy 分布式实现</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="14-3-Scrapy-分布式实现"><a href="#14-3-Scrapy-分布式实现" class="headerlink" title="14.3 Scrapy 分布式实现"></a>14.3 Scrapy 分布式实现</h1>
                  <p>接下来，我们会利用 Scrapy-Redis 来实现分布式的对接。</p>
                  <h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3>
                  <p>请确保已经成功实现了 Scrapy 新浪微博爬虫，Scrapy-Redis 库已经正确安装，如果还没安装，请参考第 1 章的安装说明。</p>
                  <h3 id="2-搭建-Redis-服务器"><a href="#2-搭建-Redis-服务器" class="headerlink" title="2. 搭建 Redis 服务器"></a>2. 搭建 Redis 服务器</h3>
                  <p>要实现分布式部署，多台主机需要共享爬取队列和去重集合，而这两部分内容都是存于 Redis 数据库中的，我们需要搭建一个可公网访问的 Redis 服务器。 推荐使用 Linux 服务器，可以购买阿里云、腾讯云、Azure 等提供的云主机，一般都会配有公网 IP，具体的搭建方式可以参考第 1 章中 Redis 数据库的安装方式。 Redis 安装完成之后就可以远程连接了，注意部分商家（如阿里云、腾讯云）的服务器需要配置安全组放通 Redis 运行端口才可以远程访问。如果遇到不能远程连接的问题，可以排查安全组的设置。 需要记录 Redis 的运行 IP、端口、地址，供后面配置分布式爬虫使用。当前配置好的 Redis 的 IP 为服务器的 IP 120.27.34.25，端口为默认的 6379，密码为 foobared。</p>
                  <h3 id="3-部署代理池和-Cookies-池"><a href="#3-部署代理池和-Cookies-池" class="headerlink" title="3. 部署代理池和 Cookies 池"></a>3. 部署代理池和 Cookies 池</h3>
                  <p>新浪微博项目需要用到代理池和 Cookies 池，而之前我们的代理池和 Cookies 池都是在本地运行的。所以我们需要将二者放到可以被公网访问的服务器上运行，将代码上传到服务器，修改 Redis 的连接信息配置，用同样的方式运行代理池和 Cookies 池。 远程访问代理池和 Cookies 池提供的接口，来获取随机代理和 Cookies。如果不能远程访问，先确保其在 0.0.0.0 这个 Host 上运行，再检查安全组的配置。 如我当前配置好的代理池和 Cookies 池的运行 IP 都是服务器的 IP，120.27.34.25，端口分别为 5555 和 5556，如图 14-3 和图 14-4 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-113501.jpg" alt=""> 图 14-3 代理池接口 <img src="https://cdn.cuiqingcai.com/2019-11-29-113506.jpg" alt=""> 图 14-4 Cookies 池接口 所以接下来我们就需要把 Scrapy 新浪微博项目中的访问链接修改如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">PROXY_URL</span> = <span class="string">'http://120.27.34.25:5555/random'</span></span><br><span class="line"><span class="attr">COOKIES_URL</span> = <span class="string">'http://120.27.34.25:5556/weibo/random'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>具体的修改方式根据实际配置的 IP 和端口做相应调整。</p>
                  <h3 id="4-配置-Scrapy-Redis"><a href="#4-配置-Scrapy-Redis" class="headerlink" title="4. 配置 Scrapy-Redis"></a>4. 配置 Scrapy-Redis</h3>
                  <p>配置 Scrapy-Redis 非常简单，只需要修改一下 settings.py 配置文件即可。</p>
                  <h4 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h4>
                  <p>首先最主要的是，需要将调度器的类和去重的类替换为 Scrapy-Redis 提供的类，在 settings.py 里面添加如下配置即可：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SCHEDULER</span> = <span class="string">"scrapy_redis.scheduler.Scheduler"</span></span><br><span class="line"><span class="attr">DUPEFILTER_CLASS</span> = <span class="string">"scrapy_redis.dupefilter.RFPDupeFilter"</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="Redis-连接配置"><a href="#Redis-连接配置" class="headerlink" title="Redis 连接配置"></a>Redis 连接配置</h4>
                  <p>接下来配置 Redis 的连接信息，这里有两种配置方式。 第一种方式是通过连接字符串配置。我们可以用 Redis 的地址、端口、密码来构造一个 Redis 连接字符串，支持的连接形式如下所示：</p>
                  <figure class="highlight dts">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">redis:</span><span class="comment">//[:password]@host:port/db</span></span><br><span class="line"><span class="symbol">rediss:</span><span class="comment">//[:password]@host:port/db</span></span><br><span class="line"><span class="symbol">unix:</span><span class="comment">//[:password]@/path/to/socket.sock?db=db</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>password 是密码，比如要以冒号开头，中括号代表此选项可有可无，host 是 Redis 的地址，port 是运行端口，db 是数据库代号，其值默认是 0。 根据上文中提到我的 Redis 连接信息，构造这个 Redis 的连接字符串如下所示：</p>
                  <figure class="highlight avrasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">redis:</span>//:foobared<span class="subst">@120</span><span class="number">.27</span><span class="number">.34</span><span class="number">.25</span>:<span class="number">6379</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>直接在 settings.py 里面配置为 REDIS_URL 变量即可：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">REDIS_URL</span> = <span class="string">'redis://:foobared@120.27.34.25:6379'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第二种配置方式是分项单独配置。这个配置就更加直观明了，如根据我的 Redis 连接信息，可以在 settings.py 中配置如下代码：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">REDIS_HOST</span> = <span class="string">'120.27.34.25'</span></span><br><span class="line"><span class="attr">REDIS_PORT</span> = <span class="number">6379</span></span><br><span class="line"><span class="attr">REDIS_PASSWORD</span> = <span class="string">'foobared'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这段代码分开配置了 Redis 的地址、端口和密码。 注意，如果配置了 REDIS_URL，那么 Scrapy-Redis 将优先使用 REDIS_URL 连接，会覆盖上面的三项配置。如果想要分项单独配置的话，请不要配置 REDIS_URL。 在本项目中，我选择的是配置 REDIS_URL。</p>
                  <h4 id="配置调度队列"><a href="#配置调度队列" class="headerlink" title="配置调度队列"></a>配置调度队列</h4>
                  <p>此项配置是可选的，默认使用 PriorityQueue。如果想要更改配置，可以配置 SCHEDULER_QUEUE_CLASS 变量，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SCHEDULER_QUEUE_CLASS</span> = <span class="string">'scrapy_redis.queue.PriorityQueue'</span></span><br><span class="line"><span class="attr">SCHEDULER_QUEUE_CLASS</span> = <span class="string">'scrapy_redis.queue.FifoQueue'</span></span><br><span class="line"><span class="attr">SCHEDULER_QUEUE_CLASS</span> = <span class="string">'scrapy_redis.queue.LifoQueue'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>以上三行任选其一配置，即可切换爬取队列的存储方式。 在本项目中不进行任何配置，我们使用默认配置。</p>
                  <h4 id="配置持久化"><a href="#配置持久化" class="headerlink" title="配置持久化"></a>配置持久化</h4>
                  <p>此配置是可选的，默认是 False。Scrapy-Redis 默认会在爬取全部完成后清空爬取队列和去重指纹集合。 如果不想自动清空爬取队列和去重指纹集合，可以增加如下配置：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SCHEDULER_PERSIST</span> = <span class="literal">True</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>将 SCHEDULER_PERSIST 设置为 True 之后，爬取队列和去重指纹集合不会在爬取完成后自动清空，如果不配置，默认是 False，即自动清空。 值得注意的是，如果强制中断爬虫的运行，爬取队列和去重指纹集合是不会自动清空的。 在本项目中不进行任何配置，我们使用默认配置。</p>
                  <h4 id="配置重爬"><a href="#配置重爬" class="headerlink" title="配置重爬"></a>配置重爬</h4>
                  <p>此配置是可选的，默认是 False。如果配置了持久化或者强制中断了爬虫，那么爬取队列和指纹集合不会被清空，爬虫重新启动之后就会接着上次爬取。如果想重新爬取，我们可以配置重爬的选项：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SCHEDULER_FLUSH_ON_START</span> = <span class="literal">True</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样将 SCHEDULER_FLUSH_ON_START 设置为 True 之后，爬虫每次启动时，爬取队列和指纹集合都会清空。所以要做分布式爬取，我们必须保证只能清空一次，否则每个爬虫任务在启动时都清空一次，就会把之前的爬取队列清空，势必会影响分布式爬取。 注意，此配置在单机爬取的时候比较方便，分布式爬取不常用此配置。 在本项目中不进行任何配置，我们使用默认配置。</p>
                  <h4 id="Pipeline-配置"><a href="#Pipeline-配置" class="headerlink" title="Pipeline 配置"></a>Pipeline 配置</h4>
                  <p>此配置是可选的，默认不启动 Pipeline。Scrapy-Redis 实现了一个存储到 Redis 的 Item Pipeline，启用了这个 Pipeline 的话，爬虫会把生成的 Item 存储到 Redis 数据库中。在数据量比较大的情况下，我们一般不会这么做。因为 Redis 是基于内存的，我们利用的是它处理速度快的特性，用它来做存储未免太浪费了，配置如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">ITEM_PIPELINES</span> = &#123;<span class="string">'scrapy_redis.pipelines.RedisPipeline'</span>: <span class="number">300</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>本项目不进行任何配置，即不启动 Pipeline。 到此为止，Scrapy-Redis 的配置就完成了。有的选项我们没有配置，但是这些配置在其他 Scrapy 项目中可能用到，要根据具体情况而定。</p>
                  <h3 id="5-配置存储目标"><a href="#5-配置存储目标" class="headerlink" title="5. 配置存储目标"></a>5. 配置存储目标</h3>
                  <p>之前 Scrapy 新浪微博爬虫项目使用的存储是 MongoDB，而且 MongoDB 是本地运行的，即连接的是 localhost。但是，当爬虫程序分发到各台主机运行的时候，爬虫就会连接各自的的 MongoDB。所以我们需要在各台主机上都安装 MongoDB，这样有两个缺点：一是搭建 MongoDB 环境比较烦琐；二是这样各台主机的爬虫会把爬取结果分散存到各自主机上，不方便统一管理。 所以我们最好将存储目标存到同一个地方，例如都存到同一个 MongoDB 数据库中。我们可以在服务器上搭建一个 MongoDB 服务，或者直接购买 MongoDB 数据存储服务。 这里使用的就是服务器上搭建的的 MongoDB 服务，IP 仍然为 120.27.34.25，用户名为 admin，密码为 admin123。 修改配置 MONGO_URI 为如下：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MONGO_URI</span> = <span class="string">'mongodb://admin:admin123@120.27.34.25:27017'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>到此为止，我们就成功完成了 Scrapy 分布式爬虫的配置了。</p>
                  <h3 id="6-运行"><a href="#6-运行" class="headerlink" title="6. 运行"></a>6. 运行</h3>
                  <p>接下来将代码部署到各台主机上，记得每台主机都需要配好对应的 Python 环境。 每台主机上都执行如下命令，即可启动爬取：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl weibocn</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>每台主机启动了此命令之后，就会从配置的 Redis 数据库中调度 Request，做到爬取队列共享和指纹集合共享。同时每台主机占用各自的带宽和处理器，不会互相影响，爬取效率成倍提高。</p>
                  <h3 id="7-结果"><a href="#7-结果" class="headerlink" title="7. 结果"></a>7. 结果</h3>
                  <p>一段时间后，我们可以用 RedisDesktop 观察远程 Redis 数据库的信息。这里会出现两个 Key：一个叫作 weibocn:dupefilter，用来储存指纹；另一个叫作 weibocn:requests，即爬取队列，如图 14-5 和图 14-6 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-113521.jpg" alt=""> 图 14-5 去重指纹 <img src="/Users/maqian/Downloads/python3webspiderupload/assets/14-6.jpg" alt=""> 图 14-6 爬取队列 随着时间的推移，指纹集合会不断增长，爬取队列会动态变化，爬取的数据也会被储存到 MongoDB 数据库中。 至此 Scrapy 分布式的配置已全部完成。</p>
                  <h3 id="8-本节代码"><a href="#8-本节代码" class="headerlink" title="8. 本节代码"></a>8. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/Weibo/tree/distributed" target="_blank" rel="noopener">https://github.com/Python3WebSpider/Weibo/tree/distributed</a>，注意这里是 distributed 分支。</p>
                  <h3 id="9-结语"><a href="#9-结语" class="headerlink" title="9. 结语"></a>9. 结语</h3>
                  <p>本节通过对接 Scrapy-Redis 成功实现了分布式爬虫，但是部署还是有很多不方便的地方。另外，如果爬取量特别大的话，Redis 的内存也是个问题。在后文我们会继续了解相关优化方案。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-09 10:14:40" itemprop="dateCreated datePublished" datetime="2019-12-09T10:14:40+08:00">2019-12-09</time>
                </span>
                <span id="/8468.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 14.3–Scrapy 分布式实现" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>4.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>4 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8465.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8465.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 14.2–Scrapy-Redis 源码解析</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="14-2-Scrapy-Redis-源码解析"><a href="#14-2-Scrapy-Redis-源码解析" class="headerlink" title="14.2 Scrapy-Redis 源码解析"></a>14.2 Scrapy-Redis 源码解析</h1>
                  <p>Scrapy-Redis 库已经为我们提供了 Scrapy 分布式的队列、调度器、去重等功能，其 GitHub 地址为：<a href="https://github.com/rmax/scrapy-redis" target="_blank" rel="noopener">https://github.com/rmax/scrapy-redis</a>。 本节我们深入了解一下，利用 Redis 如何实现 Scrapy 分布式。</p>
                  <h3 id="1-获取源码"><a href="#1-获取源码" class="headerlink" title="1. 获取源码"></a>1. 获取源码</h3>
                  <p>可以把源码克隆下来，执行如下命令：</p>
                  <figure class="highlight crmsh">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/rmax/scrapy-redis.git</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>核心源码在 scrapy-redis/src/scrapy_redis 目录下。</p>
                  <h3 id="2-爬取队列"><a href="#2-爬取队列" class="headerlink" title="2. 爬取队列"></a>2. 爬取队列</h3>
                  <p>从爬取队列入手，看看它的具体实现。源码文件为 queue.py，它有三个队列的实现，首先它实现了一个父类 Base，提供一些基本方法和属性，如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Per-spider base queue class"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, spider, key, serializer=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> serializer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = picklecompat</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(serializer, <span class="string">'loads'</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"serializer does not implement 'loads' function: % r"</span></span><br><span class="line">                            % serializer)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(serializer, <span class="string">'dumps'</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"serializer '% s' does not implement 'dumps' function: % r"</span></span><br><span class="line">                            % serializer)</span><br><span class="line">        self.server = server</span><br><span class="line">        self.spider = spider</span><br><span class="line">        self.key = key % &#123;<span class="string">'spider'</span>: spider.name&#125;</span><br><span class="line">        self.serializer = serializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_encode_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        obj = request_to_dict(request, self.spider)</span><br><span class="line">        <span class="keyword">return</span> self.serializer.dumps(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_decode_request</span><span class="params">(self, encoded_request)</span>:</span></span><br><span class="line">        obj = self.serializer.loads(encoded_request)</span><br><span class="line">        <span class="keyword">return</span> request_from_dict(obj, self.spider)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the length of the queue"""</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Push a request"""</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Pop a request"""</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Clear queue/stack"""</span></span><br><span class="line">        self.server.delete(self.key)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先看一下 <em>encode<em>request() 和 _decode_request() 方法，因为我们需要把一 个 Request 对象存储到数据库中，但数据库无法直接存储对象，所以需要将 Request 序列化转成字符串再存储，而这两个方法就分别是序列化和反序列化的操作，利用 pickle 库来实现，一般在调用 push() 将 Request 存入数据库时会调用 _encode_request() 方法进行序列化，在调用 pop() 取出 Request 的时候会调用 _decode_request() 进行反序列化。 在父类中 __len</em></em>()、push() 和 pop() 方法都是未实现的，会直接抛出 NotImplementedError，因此这个类是不能直接被使用的，所以必须要实现一个子类来重写这三个方法，而不同的子类就会有不同的实现，也就有着不同的功能。 那么接下来就需要定义一些子类来继承 Base 类，并重写这几个方法，那在源码中就有三个子类的实现，它们分别是 FifoQueue、PriorityQueue、LifoQueue，我们分别来看下它们的实现原理。 首先是 FifoQueue：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoQueue</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="string">"""Per-spider FIFO queue"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the length of the queue"""</span></span><br><span class="line">        <span class="keyword">return</span> self.server.llen(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Push a request"""</span></span><br><span class="line">        self.server.lpush(self.key, self._encode_request(request))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Pop a request"""</span></span><br><span class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">            data = self.server.brpop(self.key, timeout)</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, tuple):</span><br><span class="line">                data = data[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = self.server.rpop(self.key)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> self._decode_request(data)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到这个类继承了 Base 类，并重写了 <strong>len</strong>()、push()、pop() 这三个方法，在这三个方法中都是对 server 对象的操作，而 server 对象就是一个 Redis 连接对象，我们可以直接调用其操作 Redis 的方法对数据库进行操作，可以看到这里的操作方法有 llen()、lpush()、rpop() 等，那这就代表此爬取队列是使用的 Redis 的列表，序列化后的 Request 会被存入列表中，就是列表的其中一个元素，<strong>len</strong>() 方法是获取列表的长度，push() 方法中调用了 lpush() 操作，这代表从列表左侧存入数据，pop() 方法中调用了 rpop() 操作，这代表从列表右侧取出数据。 所以 Request 在列表中的存取顺序是左侧进、右侧出，所以这是有序的进出，即先进先出，英文叫做 First Input First Output，也被简称作 Fifo，而此类的名称就叫做 FifoQueue。 另外还有一个与之相反的实现类，叫做 LifoQueue，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifoQueue</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="string">"""Per-spider LIFO queue."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the length of the stack"""</span></span><br><span class="line">        <span class="keyword">return</span> self.server.llen(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Push a request"""</span></span><br><span class="line">        self.server.lpush(self.key, self._encode_request(request))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Pop a request"""</span></span><br><span class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">            data = self.server.blpop(self.key, timeout)</span><br><span class="line">            <span class="keyword">if</span> isinstance(data, tuple):</span><br><span class="line">                data = data[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = self.server.lpop(self.key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> self._decode_request(data)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>与 FifoQueue 不同的就是它的 pop() 方法，在这里使用的是 lpop() 操作，也就是从左侧出，而 push() 方法依然是使用的 lpush() 操作，是从左侧入。那么这样达到的效果就是先进后出、后进先出，英文叫做 Last In First Out，简称为 Lifo，而此类名称就叫做 LifoQueue。同时这个存取方式类似栈的操作，所以其实也可以称作 StackQueue。 另外在源码中还有一个子类实现，叫做 PriorityQueue，顾名思义，它叫做优先级队列，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="string">"""Per-spider priority queue abstraction using redis' sorted set"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the length of the queue"""</span></span><br><span class="line">        <span class="keyword">return</span> self.server.zcard(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Push a request"""</span></span><br><span class="line">        data = self._encode_request(request)</span><br><span class="line">        score = -request.priority</span><br><span class="line">        self.server.execute_command(<span class="string">'ZADD'</span>, self.key, score, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Pop a request</span></span><br><span class="line"><span class="string">        timeout not support in this queue class</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pipe = self.server.pipeline()</span><br><span class="line">        pipe.multi()</span><br><span class="line">        pipe.zrange(self.key, <span class="number">0</span>, <span class="number">0</span>).zremrangebyrank(self.key, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        results, count = pipe.execute()</span><br><span class="line">        <span class="keyword">if</span> results:</span><br><span class="line">            <span class="keyword">return</span> self._decode_request(results[<span class="number">0</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们可以看到 <strong>len</strong>()、push()、pop() 方法中使用了 server 对象的 zcard()、zadd()、zrange() 操作，可以知道这里使用的存储结果是有序集合 Sorted Set，在这个集合中每个元素都可以设置一个分数，那么这个分数就代表优先级。 在 <strong>len</strong>() 方法里调用了 zcard() 操作，返回的就是有序集合的大小，也就是爬取队列的长度，在 push() 方法中调用了 zadd() 操作，就是向集合中添加元素，这里的分数指定成 Request 的优先级的相反数，因为分数低的会排在集合的前面，所以这里高优先级的 Request 就会存在集合的最前面。pop() 方法是首先调用了 zrange() 操作取出了集合的第一个元素，因为最高优先级的 Request 会存在集合最前面，所以第一个元素就是最高优先级的 Request，然后再调用 zremrangebyrank() 操作将这个元素删除，这样就完成了取出并删除的操作。 此队列是默认使用的队列，也就是爬取队列默认是使用有序集合来存储的。</p>
                  <h3 id="3-去重过滤"><a href="#3-去重过滤" class="headerlink" title="3. 去重过滤"></a>3. 去重过滤</h3>
                  <p>前面说过 Scrapy 的去重是利用集合来实现的，而在 Scrapy 分布式中的去重就需要利用共享的集合，那么这里使用的就是 Redis 中的集合数据结构。我们来看看去重类是怎样实现的，源码文件是 dupefilter.py，其内实现了一个 RFPDupeFilter 类，如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RFPDupeFilter</span><span class="params">(BaseDupeFilter)</span>:</span></span><br><span class="line">    <span class="string">"""Redis-based request duplicates filter.</span></span><br><span class="line"><span class="string">    This class can also be used with default Scrapy's scheduler.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    logger = logger</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, key, debug=False)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize the duplicates filter.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        server : redis.StrictRedis</span></span><br><span class="line"><span class="string">            The redis server instance.</span></span><br><span class="line"><span class="string">        key : str</span></span><br><span class="line"><span class="string">            Redis key Where to store fingerprints.</span></span><br><span class="line"><span class="string">        debug : bool, optional</span></span><br><span class="line"><span class="string">            Whether to log filtered requests.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.key = key</span><br><span class="line">        self.debug = debug</span><br><span class="line">        self.logdupes = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_settings</span><span class="params">(cls, settings)</span>:</span></span><br><span class="line">        <span class="string">"""Returns an instance from given settings.</span></span><br><span class="line"><span class="string">        This uses by default the key ``dupefilter:&lt;timestamp&gt;``. When using the</span></span><br><span class="line"><span class="string">        ``scrapy_redis.scheduler.Scheduler`` class, this method is not used as</span></span><br><span class="line"><span class="string">        it needs to pass the spider name in the key.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        settings : scrapy.settings.Settings</span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        RFPDupeFilter</span></span><br><span class="line"><span class="string">            A RFPDupeFilter instance.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        server = get_redis_from_settings(settings)</span><br><span class="line">        key = defaults.DUPEFILTER_KEY % &#123;<span class="string">'timestamp'</span>: int(time.time())&#125;</span><br><span class="line">        debug = settings.getbool(<span class="string">'DUPEFILTER_DEBUG'</span>)</span><br><span class="line">        <span class="keyword">return</span> cls(server, key=key, debug=debug)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="string">"""Returns instance from crawler.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        crawler : scrapy.crawler.Crawler</span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        RFPDupeFilter</span></span><br><span class="line"><span class="string">            Instance of RFPDupeFilter.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> cls.from_settings(crawler.settings)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Returns True if request was already seen.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        request : scrapy.http.Request</span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fp = self.request_fingerprint(request)</span><br><span class="line">        added = self.server.sadd(self.key, fp)</span><br><span class="line">        <span class="keyword">return</span> added == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""Returns a fingerprint for a given request.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        request : scrapy.http.Request</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        str</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> request_fingerprint(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self, reason=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Delete data on close. Called by Scrapy's scheduler.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        reason : str, optional</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.clear()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Clears fingerprints data."""</span></span><br><span class="line">        self.server.delete(self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="string">"""Logs given request.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        request : scrapy.http.Request</span></span><br><span class="line"><span class="string">        spider : scrapy.spiders.Spider</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.debug:</span><br><span class="line">            msg = <span class="string">"Filtered duplicate request: %(request) s"</span></span><br><span class="line">            self.logger.debug(msg, &#123;<span class="string">'request'</span>: request&#125;, extra=&#123;<span class="string">'spider'</span>: spider&#125;)</span><br><span class="line">        <span class="keyword">elif</span> self.logdupes:</span><br><span class="line">            msg = (<span class="string">"Filtered duplicate request %(request) s"</span></span><br><span class="line">                   <span class="string">"- no more duplicates will be shown"</span></span><br><span class="line">                   <span class="string">"(see DUPEFILTER_DEBUG to show all duplicates)"</span>)</span><br><span class="line">            self.logger.debug(msg, &#123;<span class="string">'request'</span>: request&#125;, extra=&#123;<span class="string">'spider'</span>: spider&#125;)</span><br><span class="line">            self.logdupes = <span class="literal">False</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里同样实现了一个 request_seen() 方法，和 Scrapy 中的 request_seen() 方法实现极其类似。不过这里集合使用的是 server 对象的 sadd() 操作，也就是集合不再是一个简单数据结构了，而是直接换成了数据库的存储方式。 鉴别重复的方式还是使用指纹，指纹同样是依靠 request_fingerprint() 方法来获取的。获取指纹之后就直接向集合添加指纹，如果添加成功，说明这个指纹原本不存在于集合中，返回值 1。代码中最后的返回结果是判定添加结果是否为 0，如果刚才的返回值为 1，那这个判定结果就是 False，也就是不重复，否则判定为重复。 这样我们就成功利用 Redis 的集合完成了指纹的记录和重复的验证。</p>
                  <h3 id="4-调度器"><a href="#4-调度器" class="headerlink" title="4. 调度器"></a>4. 调度器</h3>
                  <p>Scrapy-Redis 还帮我们实现了配合 Queue、DupeFilter 使用的调度器 Scheduler，源文件名称是 scheduler.py。我们可以指定一些配置，如 SCHEDULER_FLUSH_ON_START 即是否在爬取开始的时候清空爬取队列，SCHEDULER_PERSIST 即是否在爬取结束后保持爬取队列不清除。我们可以在 settings.py 里自由配置，而此调度器很好地实现了对接。 接下来我们看看两个核心的存取方法，实现如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue_request</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.dont_filter <span class="keyword">and</span> <span class="keyword">self</span>.df.request_seen(request)<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.df.log(request, <span class="keyword">self</span>.spider)</span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">stats:</span></span><br><span class="line">        <span class="keyword">self</span>.stats.inc_value(<span class="string">'scheduler/enqueued/redis'</span>, spider=<span class="keyword">self</span>.spider)</span><br><span class="line">    <span class="keyword">self</span>.queue.push(request)</span><br><span class="line">    <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_request</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    block_pop_timeout = <span class="keyword">self</span>.idle_before_close</span><br><span class="line">    request = <span class="keyword">self</span>.queue.pop(block_pop_timeout)</span><br><span class="line">    <span class="keyword">if</span> request <span class="keyword">and</span> <span class="keyword">self</span>.<span class="symbol">stats:</span></span><br><span class="line">        <span class="keyword">self</span>.stats.inc_value(<span class="string">'scheduler/dequeued/redis'</span>, spider=<span class="keyword">self</span>.spider)</span><br><span class="line">    <span class="keyword">return</span> request</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>enqueue_request() 可以向队列中添加 Request，核心操作就是调用 Queue 的 push() 操作，还有一些统计和日志操作。next_request() 就是从队列中取 Request，核心操作就是调用 Queue 的 pop() 操作，此时如果队列中还有 Request，则 Request 会直接取出来，爬取继续，否则如果队列为空，爬取则会重新开始。</p>
                  <h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3>
                  <p>那么到现在为止我们就把之前所说的三个分布式的问题解决了，总结如下：</p>
                  <ul>
                    <li>爬取队列的实现，在这里提供了三种队列，使用了 Redis 的列表或有序集合来维护。</li>
                    <li>去重的实现，使用了 Redis 的集合来保存 Request 的指纹来提供重复过滤。</li>
                    <li>中断后重新爬取的实现，中断后 Redis 的队列没有清空，再次启动时调度器的 next_request() 会从队列中取到下一个 Request，继续爬取。</li>
                  </ul>
                  <h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h3>
                  <p>以上内容便是 Scrapy-Redis 的核心源码解析。Scrapy-Redis 中还提供了 Spider、Item Pipeline 的实现，不过它们并不是必须使用。 在下一节，我们会将 Scrapy-Redis 集成到之前所实现的 Scrapy 新浪微博项目中，实现多台主机协同爬取。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-09 10:08:42" itemprop="dateCreated datePublished" datetime="2019-12-09T10:08:42+08:00">2019-12-09</time>
                </span>
                <span id="/8465.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 14.2–Scrapy-Redis 源码解析" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>8.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>8 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8456.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8456.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 14.1–分布式爬虫原理</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="14-1-分布式爬虫原理"><a href="#14-1-分布式爬虫原理" class="headerlink" title="14.1 分布式爬虫原理"></a>14.1 分布式爬虫原理</h1>
                  <p>我们在前面已经实现了 Scrapy 微博爬虫，虽然爬虫是异步加多线程的，但是我们只能在一台主机上运行，所以爬取效率还是有限的，分布式爬虫则是将多台主机组合起来，共同完成一个爬取任务，这将大大提高爬取的效率。</p>
                  <h3 id="1-分布式爬虫架构"><a href="#1-分布式爬虫架构" class="headerlink" title="1. 分布式爬虫架构"></a>1. 分布式爬虫架构</h3>
                  <p>在了解分布式爬虫架构之前，首先回顾一下 Scrapy 的架构，如图 13-1 所示。 Scrapy 单机爬虫中有一个本地爬取队列 Queue，这个队列是利用 deque 模块实现的。如果新的 Request 生成就会放到队列里面，随后 Request 被 Scheduler 调度。之后，Request 交给 Downloader 执行爬取，简单的调度架构如图 14-1 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-113355.jpg" alt=""> 图 14-1 调度架构 如果两个 Scheduler 同时从队列里面取 Request，每个 Scheduler 都有其对应的 Downloader，那么在带宽足够、正常爬取且不考虑队列存取压力的情况下，爬取效率会有什么变化？没错，爬取效率会翻倍。 这样，Scheduler 可以扩展多个，Downloader 也可以扩展多个。而爬取队列 Queue 必须始终为一个，也就是所谓的共享爬取队列。这样才能保证 Scheduer 从队列里调度某个 Request 之后，其他 Scheduler 不会重复调度此 Request，就可以做到多个 Schduler 同步爬取。这就是分布式爬虫的基本雏形，简单调度架构如图 14-2 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-29-113406.jpg" alt=""> 图 14-2 调度架构 我们需要做的就是在多台主机上同时运行爬虫任务协同爬取，而协同爬取的前提就是共享爬取队列。这样各台主机就不需要各自维护爬取队列，而是从共享爬取队列存取 Request。但是各台主机还是有各自的 Scheduler 和 Downloader，所以调度和下载功能分别完成。如果不考虑队列存取性能消耗，爬取效率还是会成倍提高。</p>
                  <h3 id="2-维护爬取队列"><a href="#2-维护爬取队列" class="headerlink" title="2. 维护爬取队列"></a>2. 维护爬取队列</h3>
                  <p>那么这个队列用什么维护来好呢？我们首先需要考虑的就是性能问题，什么数据库存取效率高？我们自然想到基于内存存储的 Redis，而且 Redis 还支持多种数据结构，例如列表 List、集合 Set、有序集合 Sorted Set 等等，存取的操作也非常简单，所以在这里我们采用 Redis 来维护爬取队列。 这几种数据结构存储实际各有千秋，分析如下：</p>
                  <ul>
                    <li>列表数据结构有 lpush()、lpop()、rpush()、rpop() 方法，所以我们可以用它来实现一个先进先出式爬取队列，也可以实现一个先进后出栈式爬取队列。</li>
                    <li>集合的元素是无序的且不重复的，这样我们可以非常方便地实现一个随机排序的不重复的爬取队列。</li>
                    <li>有序集合带有分数表示，而 Scrapy 的 Request 也有优先级的控制，所以用有集合我们可以实现一个带优先级调度的队列。</li>
                  </ul>
                  <p>这些不同的队列我们需要根据具体爬虫的需求灵活选择。</p>
                  <h3 id="3-怎样来去重"><a href="#3-怎样来去重" class="headerlink" title="3. 怎样来去重"></a>3. 怎样来去重</h3>
                  <p>Scrapy 有自动去重，它的去重使用了 Python 中的集合。这个集合记录了 Scrapy 中每个 Request 的指纹，这个指纹实际上就是 Request 的散列值。我们可以看看 Scrapy 的源代码，如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import hashlib</span><br><span class="line">def request<span class="constructor">_fingerprint(<span class="params">request</span>, <span class="params">include_headers</span>=None)</span>:</span><br><span class="line">    <span class="keyword">if</span> include_headers:</span><br><span class="line">        include_headers = tuple(<span class="keyword">to</span><span class="constructor">_bytes(<span class="params">h</span>.<span class="params">lower</span>()</span>)</span><br><span class="line">                                 for h <span class="keyword">in</span> sorted(include_headers))</span><br><span class="line">    cache = <span class="module-access"><span class="module"><span class="identifier">_fingerprint_cache</span>.</span></span>setdefault(request, &#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> include_headers not <span class="keyword">in</span> cache:</span><br><span class="line">        fp = hashlib.sha1<span class="literal">()</span></span><br><span class="line">        fp.update(<span class="keyword">to</span><span class="constructor">_bytes(<span class="params">request</span>.<span class="params">method</span>)</span>)</span><br><span class="line">        fp.update(<span class="keyword">to</span><span class="constructor">_bytes(<span class="params">canonicalize_url</span>(<span class="params">request</span>.<span class="params">url</span>)</span>))</span><br><span class="line">        fp.update(request.body <span class="keyword">or</span> b'')</span><br><span class="line">        <span class="keyword">if</span> include_headers:</span><br><span class="line">            for hdr <span class="keyword">in</span> include_headers:</span><br><span class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</span><br><span class="line">                    fp.update(hdr)</span><br><span class="line">                    for v <span class="keyword">in</span> request.headers.getlist(hdr):</span><br><span class="line">                        fp.update(v)</span><br><span class="line">        cache<span class="literal">[<span class="identifier">include_headers</span>]</span> = fp.hexdigest<span class="literal">()</span></span><br><span class="line">    return cache<span class="literal">[<span class="identifier">include_headers</span>]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>request_fingerprint() 就是计算 Request 指纹的方法，其方法内部使用的是 hashlib 的 sha1() 方法。计算的字段包括 Request 的 Method、URL、Body、Headers 这几部分内容，这里只要有一点不同，那么计算的结果就不同。计算得到的结果是加密后的字符串，也就是指纹。每个 Request 都有独有的指纹，指纹就是一个字符串，判定字符串是否重复比判定 Request 对象是否重复容易得多，所以指纹可以作为判定 Request 是否重复的依据。 那么我们如何判定重复呢？Scrapy 是这样实现的，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.fingerprints = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">    fp = <span class="keyword">self</span>.request_fingerprint(request)</span><br><span class="line">    <span class="keyword">if</span> fp <span class="keyword">in</span> <span class="keyword">self</span>.<span class="symbol">fingerprints:</span></span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    <span class="keyword">self</span>.fingerprints.add(fp)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在去重的类 RFPDupeFilter 中，有一个 request_seen() 方法，这个方法有一个参数 request，它的作用就是检测该 Request 对象是否重复。这个方法调用 request_fingerprint() 获取该 Request 的指纹，检测这个指纹是否存在于 fingerprints 变量中，而 fingerprints 是一个集合，集合的元素都是不重复的。如果指纹存在，那么就返回 True，说明该 Request 是重复的，否则这个指纹加入到集合中。如果下次还有相同的 Request 传递过来，指纹也是相同的，那么这时指纹就已经存在于集合中，Request 对象就会直接判定为重复。这样去重的目的就实现了。 Scrapy 的去重过程就是，利用集合元素的不重复特性来实现 Request 的去重。 对于分布式爬虫来说，我们肯定不能再用每个爬虫各自的集合来去重了。因为这样还是每个主机单独维护自己的集合，不能做到共享。多台主机如果生成了相同的 Request，只能各自去重，各个主机之间就无法做到去重了。 那么要实现去重，这个指纹集合也需要是共享的，Redis 正好有集合的存储数据结构，我们可以利用 Redis 的集合作为指纹集合，那么这样去重集合也是利用 Redis 共享的。每台主机新生成 Request 之后，把该 Request 的指纹与集合比对，如果指纹已经存在，说明该 Request 是重复的，否则将 Request 的指纹加入到这个集合中即可。利用同样的原理不同的存储结构我们也实现了分布式 Reqeust 的去重。</p>
                  <h3 id="4-防止中断"><a href="#4-防止中断" class="headerlink" title="4. 防止中断"></a>4. 防止中断</h3>
                  <p>在 Scrapy 中，爬虫运行时的 Request 队列放在内存中。爬虫运行中断后，这个队列的空间就被释放，此队列就被销毁了。所以一旦爬虫运行中断，爬虫再次运行就相当于全新的爬取过程。 要做到中断后继续爬取，我们可以将队列中的 Request 保存起来，下次爬取直接读取保存数据即可获取上次爬取的队列。我们在 Scrapy 中指定一个爬取队列的存储路径即可，这个路径使用 JOB_DIR 变量来标识，我们可以用如下命令来实现：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl spider -s <span class="attribute">JOBDIR</span>=crawls/spider</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更加详细的使用方法可以参见官方文档，链接为：<a href="https://doc.scrapy.org/en/latest/topics/jobs.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/jobs.html</a>。 在 Scrapy 中，我们实际是把爬取队列保存到本地，第二次爬取直接读取并恢复队列即可。那么在分布式架构中我们还用担心这个问题吗？不需要。因为爬取队列本身就是用数据库保存的，如果爬虫中断了，数据库中的 Request 依然是存在的，下次启动就会接着上次中断的地方继续爬取。 所以，当 Redis 的队列为空时，爬虫会重新爬取；当 Redis 的队列不为空时，爬虫便会接着上次中断之处继续爬取。</p>
                  <h3 id="5-架构实现"><a href="#5-架构实现" class="headerlink" title="5. 架构实现"></a>5. 架构实现</h3>
                  <p>我们接下来就需要在程序中实现这个架构了。首先实现一个共享的爬取队列，还要实现去重的功能。另外，重写一个 Scheduer 的实现，使之可以从共享的爬取队列存取 Request。 幸运的是，已经有人实现了这些逻辑和架构，并发布成叫 Scrapy-Redis 的 Python 包。接下来，我们看看 Scrapy-Redis 的源码实现，以及它的详细工作原理。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-08 09:52:07" itemprop="dateCreated datePublished" datetime="2019-12-08T09:52:07+08:00">2019-12-08</time>
                </span>
                <span id="/8456.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 14.1–分布式爬虫原理" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8453.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8453.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.13–Scrapy 爬取新浪微博</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-13-Scrapy-爬取新浪微博"><a href="#13-13-Scrapy-爬取新浪微博" class="headerlink" title="13.13 Scrapy 爬取新浪微博"></a>13.13 Scrapy 爬取新浪微博</h1>
                  <p>前面讲解了 Scrapy 中各个模块基本使用方法以及代理池、Cookies 池。接下来我们以一个反爬比较强的网站新浪微博为例，来实现一下 Scrapy 的大规模爬取。</p>
                  <h3 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h3>
                  <p>本次爬取的目标是新浪微博用户的公开基本信息，如用户昵称、头像、用户的关注、粉丝列表以及发布的微博等，这些信息抓取之后保存至 MongoDB。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>请确保前文所讲的代理池、Cookies 池已经实现并可以正常运行，安装 Scrapy、PyMongo 库，如没有安装可以参考前文内容。</p>
                  <h3 id="3-爬取思路"><a href="#3-爬取思路" class="headerlink" title="3. 爬取思路"></a>3. 爬取思路</h3>
                  <p>首先我们要实现用户的大规模爬取。这里采用的爬取方式是，以微博的几个大 V 为起始点，爬取他们各自的粉丝和关注列表，然后获取粉丝和关注列表的粉丝和关注列表，以此类推，这样下去就可以实现递归爬取。如果一个用户与其他用户有社交网络上的关联，那他们的信息就会被爬虫抓取到，这样我们就可以做到对所有用户的爬取。通过这种方式，我们可以得到用户的唯一 ID，再根据 ID 获取每个用户发布的微博即可。</p>
                  <h3 id="4-爬取分析"><a href="#4-爬取分析" class="headerlink" title="4. 爬取分析"></a>4. 爬取分析</h3>
                  <p>这里我们选取的爬取站点是：<a href="https://m.weibo.cn，此站点是微博移动端的站点。打开该站点会跳转到登录页面，这是因为主页做了登录限制。不过我们可以直接打开某个用户详情页面，如图" target="_blank" rel="noopener">https://m.weibo.cn，此站点是微博移动端的站点。打开该站点会跳转到登录页面，这是因为主页做了登录限制。不过我们可以直接打开某个用户详情页面，如图</a> 13-32 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034836.jpg" alt=""> 图 13-32 个人详情页面 我们在页面最上方可以看到她的关注和粉丝数量。我们点击关注，进入到她的关注列表，如图 13-33 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034839.jpg" alt=""> 图 13-33 关注列表 我们打开开发者工具，切换到 XHR 过滤器，一直下拉关注列表，即可看到下方会出现很多 Ajax 请求，这些请求就是获取关注列表的 Ajax 请求，如图 13-34 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034852.png" alt=""> 图 13-34 请求列表 我们打开第一个 Ajax 请求看一下，发现它的链接为：<a href="https://m.weibo.cn/api/container/getIndex?containerid=231051_-_followers_-_1916655407&amp;luicode=10000011&amp;lfid=1005051916655407&amp;featurecode=20000320&amp;type=uid&amp;value=1916655407&amp;page=2" target="_blank" rel="noopener">https://m.weibo.cn/api/container/getIndex?containerid=231051<em>-_followers</em>-_1916655407&amp;luicode=10000011&amp;lfid=1005051916655407&amp;featurecode=20000320&amp;type=uid&amp;value=1916655407&amp;page=2</a>，详情如图 13-35 和 13-36 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034901.jpg" alt=""> 图 13-35 请求详情 <img src="https://cdn.cuiqingcai.com/2019-11-27-034906.jpg" alt=""> 图 13-36 响应结果 请求类型是 GET 类型，返回结果是 JSON 格式，我们将其展开之后即可看到其关注的用户的基本信息。接下来我们只需要构造这个请求的参数。此链接一共有 7 个参数，如图 13-37 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034931.jpg" alt=""> 图 13-37 参数信息 其中最主要的参数就是 containerid 和 page。有了这两个参数，我们同样可以获取请求结果。我们可以将接口精简为：<a href="https://m.weibo.cn/api/container/getIndex?containerid=231051_-_followers_-_1916655407&amp;page=2" target="_blank" rel="noopener">https://m.weibo.cn/api/container/getIndex?containerid=231051<em>-_followers</em>-_1916655407&amp;page=2</a>，这里的 containerid 的前半部分是固定的，后半部分是用户的 id。所以这里参数就可以构造出来了，只需要修改 containerid 最后的 id 和 page 参数即可获取分页形式的关注列表信息。 利用同样的方法，我们也可以分析用户详情的 Ajax 链接、用户微博列表的 Ajax 链接，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 用户详情 API</span></span><br><span class="line"><span class="attr">user_url</span> = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;value=&#123;uid&#125;&amp;containerid=100505&#123;uid&#125;'</span></span><br><span class="line"><span class="comment"># 关注列表 API</span></span><br><span class="line"><span class="attr">follow_url</span> = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_followers_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line"><span class="comment"># 粉丝列表 API</span></span><br><span class="line"><span class="attr">fan_url</span> = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_fans_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line"><span class="comment"># 微博列表 API</span></span><br><span class="line"><span class="attr">weibo_url</span> = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;page=&#123;page&#125;&amp;containerid=107603&#123;uid&#125;'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此处的 uid 和 page 分别代表用户 ID 和分页页码。 注意，这个 API 可能随着时间的变化或者微博的改版而变化，以实测为准。 我们从几个大 V 开始抓取，抓取他们的粉丝、关注列表、微博信息，然后递归抓取他们的粉丝和关注列表的粉丝、关注列表、微博信息，递归抓取，最后保存微博用户的基本信息、关注和粉丝列表、发布的微博。 我们选择 MongoDB 作为存储的数据库，可以更方便地存储用户的粉丝和关注列表。</p>
                  <h3 id="5-新建项目"><a href="#5-新建项目" class="headerlink" title="5. 新建项目"></a>5. 新建项目</h3>
                  <p>接下来，我们用 Scrapy 来实现这个抓取过程。首先创建一个项目，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject weibo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>进入项目中，新建一个 Spider，名为 weibocn，命令如下所示：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">weibocn</span> <span class="selector-tag">m</span><span class="selector-class">.weibo</span><span class="selector-class">.cn</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们首先修改 Spider，配置各个 Ajax 的 URL，选取几个大 V，将他们的 ID 赋值成一个列表，实现 start_requests() 方法，也就是依次抓取各个大 V 的个人详情，然后用 parse_user() 进行解析，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy import Request, Spider</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiboSpider</span>(<span class="title">Spider</span>):</span></span><br><span class="line">    name = <span class="string">'weibocn'</span></span><br><span class="line">    allowed_domains = [<span class="string">'m.weibo.cn'</span>]</span><br><span class="line">    user_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;value=&#123;uid&#125;&amp;containerid=100505&#123;uid&#125;'</span></span><br><span class="line">    follow_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_followers_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line">    fan_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?containerid=231051_-_fans_-_&#123;uid&#125;&amp;page=&#123;page&#125;'</span></span><br><span class="line">    weibo_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?uid=&#123;uid&#125;&amp;type=uid&amp;page=&#123;page&#125;&amp;containerid=107603&#123;uid&#125;'</span></span><br><span class="line">    start_users = [<span class="string">'3217179555'</span>, <span class="string">'1742566624'</span>, <span class="string">'2282991915'</span>, <span class="string">'1288739185'</span>, <span class="string">'3952070245'</span>, <span class="string">'5878659096'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">for</span> uid <span class="keyword">in</span> <span class="keyword">self</span>.<span class="symbol">start_users:</span></span><br><span class="line">            <span class="keyword">yield</span> Request(<span class="keyword">self</span>.user_url.format(uid=uid), callback=<span class="keyword">self</span>.parse_user)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_user</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.logger.debug(response)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="6-创建-Item"><a href="#6-创建-Item" class="headerlink" title="6. 创建 Item"></a>6. 创建 Item</h3>
                  <p>接下来，我们解析用户的基本信息并生成 Item。这里我们先定义几个 Item，如用户、用户关系、微博的 Item，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">UserItem</span>(<span class="symbol">Item</span>):</span><br><span class="line">    <span class="symbol">collection</span> = '<span class="symbol">users</span>'</span><br><span class="line">    <span class="symbol">id</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">name</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">avatar</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">cover</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">gender</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">description</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">fans_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">follows_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">weibos_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">verified</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">verified_reason</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">verified_type</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">follows</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">fans</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">crawled_at</span> = <span class="symbol">Field</span>()</span><br><span class="line"></span><br><span class="line"><span class="symbol">class</span> <span class="symbol">UserRelationItem</span>(<span class="symbol">Item</span>):</span><br><span class="line">    <span class="symbol">collection</span> = '<span class="symbol">users</span>'</span><br><span class="line">    <span class="symbol">id</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">follows</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">fans</span> = <span class="symbol">Field</span>()</span><br><span class="line"></span><br><span class="line"><span class="symbol">class</span> <span class="symbol">WeiboItem</span>(<span class="symbol">Item</span>):</span><br><span class="line">    <span class="symbol">collection</span> = '<span class="symbol">weibos</span>'</span><br><span class="line">    <span class="symbol">id</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">attitudes_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">comments_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">reposts_count</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">picture</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">pictures</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">source</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">text</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">raw_text</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">thumbnail</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">user</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">created_at</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">crawled_at</span> = <span class="symbol">Field</span>()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了 collection 字段，指明保存的 Collection 的名称。用户的关注和粉丝列表直接定义为一个单独的 UserRelationItem，其中 id 就是用户的 ID，follows 就是用户关注列表，fans 是粉丝列表，但这并不意味着我们会将关注和粉丝列表存到一个单独的 Collection 里。后面我们会用 Pipeline 对各个 Item 进行处理、合并存储到用户的 Collection 里，因此 Item 和 Collection 并不一定是完全对应的。</p>
                  <h3 id="7-提取数据"><a href="#7-提取数据" class="headerlink" title="7. 提取数据"></a>7. 提取数据</h3>
                  <p>我们开始解析用户的基本信息，实现 parse_user() 方法，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_user(self, response):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    解析用户信息</span></span><br><span class="line"><span class="string">    :param response: Response 对象</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">if</span> result.<span class="builtin-name">get</span>(<span class="string">'userInfo'</span>):</span><br><span class="line">        user_info = result.<span class="builtin-name">get</span>(<span class="string">'userInfo'</span>)</span><br><span class="line">        user_item = UserItem()</span><br><span class="line">        field_map = &#123;</span><br><span class="line">            <span class="string">'id'</span>: <span class="string">'id'</span>, <span class="string">'name'</span>: <span class="string">'screen_name'</span>, <span class="string">'avatar'</span>: <span class="string">'profile_image_url'</span>, <span class="string">'cover'</span>: <span class="string">'cover_image_phone'</span>,</span><br><span class="line">            <span class="string">'gender'</span>: <span class="string">'gender'</span>, <span class="string">'description'</span>: <span class="string">'description'</span>, <span class="string">'fans_count'</span>: <span class="string">'followers_count'</span>,</span><br><span class="line">            <span class="string">'follows_count'</span>: <span class="string">'follow_count'</span>, <span class="string">'weibos_count'</span>: <span class="string">'statuses_count'</span>, <span class="string">'verified'</span>: <span class="string">'verified'</span>,</span><br><span class="line">            <span class="string">'verified_reason'</span>: <span class="string">'verified_reason'</span>, <span class="string">'verified_type'</span>: <span class="string">'verified_type'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> field, attr <span class="keyword">in</span> field_map.items():</span><br><span class="line">            user_item[field] = user_info.<span class="builtin-name">get</span>(attr)</span><br><span class="line">        yield user_item</span><br><span class="line">        # 关注</span><br><span class="line">        uid = user_info.<span class="builtin-name">get</span>(<span class="string">'id'</span>)</span><br><span class="line">        yield Request(self.follow_url.format(<span class="attribute">uid</span>=uid, <span class="attribute">page</span>=1), <span class="attribute">callback</span>=self.parse_follows,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: 1, <span class="string">'uid'</span>: uid&#125;)</span><br><span class="line">        # 粉丝</span><br><span class="line">        yield Request(self.fan_url.format(<span class="attribute">uid</span>=uid, <span class="attribute">page</span>=1), <span class="attribute">callback</span>=self.parse_fans,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: 1, <span class="string">'uid'</span>: uid&#125;)</span><br><span class="line">        # 微博</span><br><span class="line">        yield Request(self.weibo_url.format(<span class="attribute">uid</span>=uid, <span class="attribute">page</span>=1), <span class="attribute">callback</span>=self.parse_weibos,</span><br><span class="line">                      meta=&#123;<span class="string">'page'</span>: 1, <span class="string">'uid'</span>: uid&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们一共完成了两个操作。</p>
                  <ul>
                    <li>解析 JSON 提取用户信息并生成 UserItem 返回。我们并没有采用常规的逐个赋值的方法，而是定义了一个字段映射关系。我们定义的字段名称可能和 JSON 中用户的字段名称不同，所以在这里定义成一个字典，然后遍历字典的每个字段实现逐个字段的赋值。</li>
                    <li>构造用户的关注、粉丝、微博的第一页的链接，并生成 Request，这里需要的参数只有用户的 ID。另外，初始分页页码直接设置为 1 即可。</li>
                  </ul>
                  <p>接下来，我们还需要保存用户的关注和粉丝列表。以关注列表为例，其解析方法为 parse_follows()，实现如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_follows(self, response):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    解析用户关注</span></span><br><span class="line"><span class="string">    :param response: Response 对象</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">if</span> result.<span class="builtin-name">get</span>(<span class="string">'ok'</span>) <span class="keyword">and</span> result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>) <span class="keyword">and</span> len(result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>)) <span class="keyword">and</span> result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>)[-1].<span class="builtin-name">get</span>(<span class="string">'card_group'</span>):</span><br><span class="line">        # 解析用户</span><br><span class="line">        follows = result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>)[-1].<span class="builtin-name">get</span>(<span class="string">'card_group'</span>)</span><br><span class="line">        <span class="keyword">for</span> follow <span class="keyword">in</span> follows:</span><br><span class="line">            <span class="keyword">if</span> follow.<span class="builtin-name">get</span>(<span class="string">'user'</span>):</span><br><span class="line">                uid = follow.<span class="builtin-name">get</span>(<span class="string">'user'</span>).<span class="builtin-name">get</span>(<span class="string">'id'</span>)</span><br><span class="line">                yield Request(self.user_url.format(<span class="attribute">uid</span>=uid), <span class="attribute">callback</span>=self.parse_user)</span><br><span class="line">        # 关注列表</span><br><span class="line">        uid = response.meta.<span class="builtin-name">get</span>(<span class="string">'uid'</span>)</span><br><span class="line">        user_relation_item = UserRelationItem()</span><br><span class="line">        follows = [&#123;<span class="string">'id'</span>: follow.<span class="builtin-name">get</span>(<span class="string">'user'</span>).<span class="builtin-name">get</span>(<span class="string">'id'</span>), <span class="string">'name'</span>: follow.<span class="builtin-name">get</span>(<span class="string">'user'</span>).<span class="builtin-name">get</span>(<span class="string">'screen_name'</span>)&#125; <span class="keyword">for</span> follow <span class="keyword">in</span></span><br><span class="line">                   follows]</span><br><span class="line">        user_relation_item[<span class="string">'id'</span>] = uid</span><br><span class="line">        user_relation_item[<span class="string">'follows'</span>] = follows</span><br><span class="line">        user_relation_item[<span class="string">'fans'</span>] = []</span><br><span class="line">        yield user_relation_item</span><br><span class="line">        # 下一页关注</span><br><span class="line">       <span class="built_in"> page </span>= response.meta.<span class="builtin-name">get</span>(<span class="string">'page'</span>) + 1</span><br><span class="line">        yield Request(self.follow_url.format(<span class="attribute">uid</span>=uid, <span class="attribute">page</span>=page),</span><br><span class="line">                      <span class="attribute">callback</span>=self.parse_follows, meta=&#123;<span class="string">'page'</span>: page, <span class="string">'uid'</span>: uid&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>那么在这个方法里面我们做了如下三件事。</p>
                  <ul>
                    <li>解析关注列表中的每个用户信息并发起新的解析请求。我们首先解析关注列表的信息，得到用户的 ID，然后再利用 user_url 构造访问用户详情的 Request，回调就是刚才所定义的 parse_user() 方法。</li>
                    <li>提取用户关注列表内的关键信息并生成 UserRelationItem。id 字段直接设置成用户的 ID，JSON 返回数据中的用户信息有很多冗余字段。在这里我们只提取了关注用户的 ID 和用户名，然后把它们赋值给 follows 字段，fans 字段设置成空列表。这样我们就建立了一个存有用户 ID 和用户部分关注列表的 UserRelationItem，之后合并且保存具有同一个 ID 的 UserRelationItem 的关注和粉丝列表。</li>
                    <li>提取下一页关注。只需要将此请求的分页页码加 1 即可。分页页码通过 Request 的 meta 属性进行传递，Response 的 meta 来接收。这样我们构造并返回下一页的关注列表的 Request。</li>
                  </ul>
                  <p>抓取粉丝列表的原理和抓取关注列表原理相同，在此不再赘述。 接下来我们还差一个方法的实现，即 parse_weibos()，它用来抓取用户的微博信息，实现如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_weibos(self, response):</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    解析微博列表</span></span><br><span class="line"><span class="string">    :param response: Response 对象</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">if</span> result.<span class="builtin-name">get</span>(<span class="string">'ok'</span>) <span class="keyword">and</span> result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>):</span><br><span class="line">        weibos = result.<span class="builtin-name">get</span>(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> weibo <span class="keyword">in</span> weibos:</span><br><span class="line">            mblog = weibo.<span class="builtin-name">get</span>(<span class="string">'mblog'</span>)</span><br><span class="line">            <span class="keyword">if</span> mblog:</span><br><span class="line">                weibo_item = WeiboItem()</span><br><span class="line">                field_map = &#123;</span><br><span class="line">                    <span class="string">'id'</span>: <span class="string">'id'</span>, <span class="string">'attitudes_count'</span>: <span class="string">'attitudes_count'</span>, <span class="string">'comments_count'</span>: <span class="string">'comments_count'</span>, <span class="string">'created_at'</span>: <span class="string">'created_at'</span>,</span><br><span class="line">                    <span class="string">'reposts_count'</span>: <span class="string">'reposts_count'</span>, <span class="string">'picture'</span>: <span class="string">'original_pic'</span>, <span class="string">'pictures'</span>: <span class="string">'pics'</span>,</span><br><span class="line">                    <span class="string">'source'</span>: <span class="string">'source'</span>, <span class="string">'text'</span>: <span class="string">'text'</span>, <span class="string">'raw_text'</span>: <span class="string">'raw_text'</span>, <span class="string">'thumbnail'</span>: <span class="string">'thumbnail_pic'</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> field, attr <span class="keyword">in</span> field_map.items():</span><br><span class="line">                    weibo_item[field] = mblog.<span class="builtin-name">get</span>(attr)</span><br><span class="line">                weibo_item[<span class="string">'user'</span>] = response.meta.<span class="builtin-name">get</span>(<span class="string">'uid'</span>)</span><br><span class="line">                yield weibo_item</span><br><span class="line">        # 下一页微博</span><br><span class="line">        uid = response.meta.<span class="builtin-name">get</span>(<span class="string">'uid'</span>)</span><br><span class="line">       <span class="built_in"> page </span>= response.meta.<span class="builtin-name">get</span>(<span class="string">'page'</span>) + 1</span><br><span class="line">        yield Request(self.weibo_url.format(<span class="attribute">uid</span>=uid, <span class="attribute">page</span>=page), <span class="attribute">callback</span>=self.parse_weibos,</span><br><span class="line">                      meta=&#123;<span class="string">'uid'</span>: uid, <span class="string">'page'</span>: page&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 parse_weibos() 方法完成了两件事。</p>
                  <ul>
                    <li>提取用户的微博信息，并生成 WeiboItem。这里同样建立了一个字段映射表，实现批量字段赋值。</li>
                    <li>提取下一页的微博列表。这里同样需要传入用户 ID 和分页页码。</li>
                  </ul>
                  <p>到目前为止，微博的 Spider 已经完成。后面还需要对数据进行数据清洗存储，以及对接代理池、Cookies 池来防止反爬虫。</p>
                  <h3 id="8-数据清洗"><a href="#8-数据清洗" class="headerlink" title="8. 数据清洗"></a>8. 数据清洗</h3>
                  <p>有些微博的时间可能不是标准的时间，比如它可能显示为刚刚、几分钟前、几小时前、昨天等。这里我们需要统一转化这些时间，实现一个 parse_time() 方法，如下所示：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_time(self, <span class="type">date</span>):</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">' 刚刚 '</span>, <span class="type">date</span>):</span><br><span class="line">        <span class="type">date</span> = <span class="type">time</span>.strftime(<span class="string">'% Y-% m-% d % H:% M'</span>, <span class="type">time</span>.<span class="built_in">localtime</span>(<span class="type">time</span>.time()))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'d + 分钟前 '</span>, <span class="type">date</span>):</span><br><span class="line">        minute = re.match(<span class="string">'(d+)'</span>, <span class="type">date</span>).<span class="keyword">group</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="type">date</span> = <span class="type">time</span>.strftime(<span class="string">'% Y-% m-% d % H:% M'</span>, <span class="type">time</span>.<span class="built_in">localtime</span>(<span class="type">time</span>.time() - <span class="type">float</span>(minute) * <span class="number">60</span>))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'d + 小时前 '</span>, <span class="type">date</span>):</span><br><span class="line">        hour = re.match(<span class="string">'(d+)'</span>, <span class="type">date</span>).<span class="keyword">group</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="type">date</span> = <span class="type">time</span>.strftime(<span class="string">'% Y-% m-% d % H:% M'</span>, <span class="type">time</span>.<span class="built_in">localtime</span>(<span class="type">time</span>.time() - <span class="type">float</span>(hour) * <span class="number">60</span> * <span class="number">60</span>))</span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">' 昨天.*'</span>, <span class="type">date</span>):</span><br><span class="line">        <span class="type">date</span> = re.match(<span class="string">' 昨天 (.*)'</span>, <span class="type">date</span>).<span class="keyword">group</span>(<span class="number">1</span>).strip()</span><br><span class="line">        <span class="type">date</span> = <span class="type">time</span>.strftime(<span class="string">'% Y-% m-% d'</span>, <span class="type">time</span>.<span class="built_in">localtime</span>() - <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>) + <span class="string">' '</span> + <span class="type">date</span></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">'d&#123;2&#125;-d&#123;2&#125;'</span>, <span class="type">date</span>):</span><br><span class="line">        <span class="type">date</span> = <span class="type">time</span>.strftime(<span class="string">'% Y-'</span>, <span class="type">time</span>.<span class="built_in">localtime</span>()) + <span class="type">date</span> + <span class="string">' 00:00'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">date</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们用正则来提取一些关键数字，用 time 库来实现标准时间的转换。 以 X 分钟前的处理为例，爬取的时间会赋值为 created_at 字段。我们首先用正则匹配这个时间，表达式写作 d + 分钟前，如果提取到的时间符合这个表达式，那么就提取出其中的数字，这样就可以获取分钟数了。接下来使用 time 模块的 strftime() 方法，第一个参数传入要转换的时间格式，第二个参数就是时间戳。这里我们用当前的时间戳减去此分钟数乘以 60 就是当时的时间戳，这样我们就可以得到格式化后的正确时间了。 然后 Pipeline 可以实现如下处理：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">class WeiboPipeline():</span><br><span class="line">    def process_item(self, <span class="keyword">item</span>, spider):</span><br><span class="line">        <span class="keyword">if</span> isinstance(<span class="keyword">item</span>, WeiboItem):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">item</span>.<span class="built_in">get</span>(<span class="string">'created_at'</span>):</span><br><span class="line">                <span class="keyword">item</span>[<span class="string">'created_at'</span>] = <span class="keyword">item</span>[<span class="string">'created_at'</span>].strip()</span><br><span class="line">                <span class="keyword">item</span>[<span class="string">'created_at'</span>] = self.parse_time(<span class="keyword">item</span>.<span class="built_in">get</span>(<span class="string">'created_at'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们在 Spider 里没有对 crawled_at 字段赋值，它代表爬取时间，我们可以统一将其赋值为当前时间，实现如下所示：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">TimePipeline</span>():</span></span><br><span class="line"><span class="class">    def process_item(<span class="title">self</span>, <span class="title">item</span>, <span class="title">spider</span>):</span></span><br><span class="line"><span class="class">        if isinstance(<span class="title">item</span>, <span class="type">UserItem</span>) or isinstance(<span class="title">item</span>, <span class="type">WeiboItem</span>):</span></span><br><span class="line"><span class="class">            now = time.strftime('% <span class="type">Y</span>-% <span class="title">m</span>-% <span class="title">d</span> % <span class="type">H</span>:% <span class="type">M</span>', <span class="title">time</span>.<span class="title">localtime</span>())</span></span><br><span class="line"><span class="class">            item['crawled_at'] = now</span></span><br><span class="line"><span class="class">        return item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们判断了 item 如果是 UserItem 或 WeiboItem 类型，那么就给它的 crawled_at 字段赋值为当前时间。 通过上面的两个 Pipeline，我们便完成了数据清洗工作，这里主要是时间的转换。</p>
                  <h3 id="9-数据存储"><a href="#9-数据存储" class="headerlink" title="9. 数据存储"></a>9. 数据存储</h3>
                  <p>数据清洗完毕之后，我们就要将数据保存到 MongoDB 数据库。我们在这里实现 MongoPipeline 类，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, mongo_uri, mongo_db)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.mongo_uri = mongo_uri</span><br><span class="line">        <span class="keyword">self</span>.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> cls(mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>), mongo_db=crawler.settings.get(<span class="string">'MONGO_DATABASE'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client = pymongo.MongoClient(<span class="keyword">self</span>.mongo_uri)</span><br><span class="line">        <span class="keyword">self</span>.db = <span class="keyword">self</span>.client[<span class="keyword">self</span>.mongo_db]</span><br><span class="line">        <span class="keyword">self</span>.db[UserItem.collection].create_index([(<span class="string">'id'</span>, pymongo.ASCENDING)])</span><br><span class="line">        <span class="keyword">self</span>.db[WeiboItem.collection].create_index([(<span class="string">'id'</span>, pymongo.ASCENDING)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(item, UserItem) <span class="keyword">or</span> isinstance(item, WeiboItem)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.db[item.collection].update(&#123;<span class="string">'id'</span>: item.get(<span class="string">'id'</span>)&#125;, &#123;<span class="string">'$set'</span>: item&#125;, True)</span><br><span class="line">        <span class="keyword">if</span> isinstance(item, UserRelationItem)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">self</span>.db[item.collection].update(&#123;<span class="string">'id'</span>: item.get(<span class="string">'id'</span>)&#125;,</span><br><span class="line">                &#123;<span class="string">'$addToSet'</span><span class="symbol">:</span></span><br><span class="line">                    &#123;<span class="string">'follows'</span>: &#123;<span class="string">'$each'</span>: item[<span class="string">'follows'</span>]&#125;,</span><br><span class="line">                        <span class="string">'fans'</span>: &#123;<span class="string">'$each'</span>: item[<span class="string">'fans'</span>]&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, True)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当前的 MongoPipeline 和前面我们所写的有所不同，主要有以下几点。</p>
                  <ul>
                    <li>在 open_spider() 方法里面添加了 Collection 的索引，在这里为两个 Item 都做了索引，索引的字段是 id，由于我们这次是大规模爬取，同时在爬取过程中涉及到数据的更新问题，所以我们为每个 Collection 建立了索引，建立了索引之后可以大大提高检索效率。</li>
                    <li>在 process_item() 方法里存储使用的是 update() 方法，第一个参数是查询条件，第二个参数是爬取的 Item，这里我们使用了 $set 操作符，这样我们如果爬取到了重复的数据即可对数据进行更新，同时不会删除已存在的字段，如果这里不加 $set 操作符，那么会直接进行 item 替换，这样可能会导致已存在的字段如关注和粉丝列表清空，所以这里必须要加上 $set 操作符。第三个参数我们设置为了 True，这个参数起到的作用是如果数据不存在，则插入数据。这样我们就可以做到数据存在即更新、数据不存在即插入，这样就达到了去重的效果。</li>
                    <li>对于用户的关注和粉丝列表，我们在这里使用了一个新的操作符，叫做 $addToSet，这个操作符可以向列表类型的字段插入数据同时去重，接下来它的值就是需要操作的字段名称，我们在这里又利用了 $each 操作符对需要插入的列表数据进行了遍历，这样就可以逐条插入用户的关注或粉丝数据到指定的字段了，关于该操作更多的解释可以参考 MongoDB 的官方文档，链接为：<a href="https://docs.mongodb.com/manual/reference/operator/update/addToSet/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/update/addToSet/</a>。</li>
                  </ul>
                  <h3 id="10-Cookies-池对接"><a href="#10-Cookies-池对接" class="headerlink" title="10. Cookies 池对接"></a>10. Cookies 池对接</h3>
                  <p>新浪微博的反爬能力非常强，我们需要做一些防范反爬虫的措施才可以顺利完成数据爬取。 如果没有登录而直接请求微博的 API 接口，这非常容易导致 403 状态码。这个情况我们在 10.2 节也提过。所以在这里我们实现一个 Middleware，为每个 Request 添加随机的 Cookies。 我们先开启 Cookies 池，使 API 模块正常运行。例如在本地运行 5000 端口，访问：<a href="http://localhost:5000/weibo/random" target="_blank" rel="noopener">http://localhost:5000/weibo/random</a> 即可获取随机的 Cookies，当然也可以将 Cookies 池部署到远程的服务器，这样只需要更改一下访问的链接就好了。 那么在这里我们将 Cookies 池在本地启动起来，再实现一个 Middleware 如下：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CookiesMiddleware</span>():</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, cookies_url)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="keyword">self</span>.logger = logging.getLogger(__name_<span class="number">_</span>)</span><br><span class="line">       <span class="keyword">self</span>.cookies_url = cookies_url</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_random_cookies</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="symbol">try:</span></span><br><span class="line">           response = requests.get(<span class="keyword">self</span>.cookies_url)</span><br><span class="line">           <span class="keyword">if</span> response.status_code == <span class="number">200</span><span class="symbol">:</span></span><br><span class="line">               cookies = json.loads(response.text)</span><br><span class="line">               <span class="keyword">return</span> cookies</span><br><span class="line">       except requests.<span class="symbol">ConnectionError:</span></span><br><span class="line">           <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(<span class="keyword">self</span>, request, spider)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="keyword">self</span>.logger.debug(<span class="string">' 正在获取 Cookies'</span>)</span><br><span class="line">       cookies = <span class="keyword">self</span>.get_random_cookies()</span><br><span class="line">       <span class="keyword">if</span> <span class="symbol">cookies:</span></span><br><span class="line">           request.cookies = cookies</span><br><span class="line">           <span class="keyword">self</span>.logger.debug(<span class="string">' 使用 Cookies '</span> + json.dumps(cookies))</span><br><span class="line"></span><br><span class="line">   @classmethod</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">       settings = crawler.settings</span><br><span class="line">       <span class="keyword">return</span> cls(cookies_url=settings.get(<span class="string">'COOKIES_URL'</span>)</span><br><span class="line">       )</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们首先利用 from_crawler() 方法获取了 COOKIES_URL 变量，它定义在 settings.py 里，这就是刚才我们所说的接口。接下来实现 get_random_cookies() 方法，这个方法主要就是请求此 Cookies 池接口并获取接口返回的随机 Cookies。如果成功获取，则返回 Cookies；否则返回 False。 接下来，在 process_request() 方法里，我们给 request 对象的 cookies 属性赋值，其值就是获取的随机 Cookies，这样我们就成功地为每一次请求赋值 Cookies 了。 如果启用了该 Middleware，每个请求都会被赋值随机的 Cookies。这样我们就可以模拟登录之后的请求，403 状态码基本就不会出现。</p>
                  <h3 id="11-代理池对接"><a href="#11-代理池对接" class="headerlink" title="11. 代理池对接"></a>11. 代理池对接</h3>
                  <p>微博还有一个反爬措施就是，检测到同一 IP 请求量过大时就会出现 414 状态码。如果遇到这样的情况可以切换代理。例如，在本地 5555 端口运行，获取随机可用代理的地址为：<a href="http://localhost:5555/random" target="_blank" rel="noopener">http://localhost:5555/random</a>，访问这个接口即可获取一个随机可用代理。接下来我们再实现一个 Middleware，代码如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">class ProxyMiddleware():</span><br><span class="line">    def __init__(self, proxy_url):</span><br><span class="line">        self.logger = logging.getLogger(__name__)</span><br><span class="line">        self.proxy_url = proxy_url</span><br><span class="line"></span><br><span class="line">    def get_random_proxy(self):</span><br><span class="line">        try:</span><br><span class="line">            response = requests.<span class="builtin-name">get</span>(self.proxy_url)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == 200:</span><br><span class="line">               <span class="built_in"> proxy </span>= response.text</span><br><span class="line">                return proxy</span><br><span class="line">        except requests.ConnectionError:</span><br><span class="line">            return <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        <span class="keyword">if</span> request.meta.<span class="builtin-name">get</span>(<span class="string">'retry_times'</span>):</span><br><span class="line">           <span class="built_in"> proxy </span>= self.get_random_proxy()</span><br><span class="line">            <span class="keyword">if</span> proxy:</span><br><span class="line">                uri = <span class="string">'https://&#123;proxy&#125;'</span>.format(<span class="attribute">proxy</span>=proxy)</span><br><span class="line">                self.logger.<span class="builtin-name">debug</span>(<span class="string">' 使用代理 '</span> + proxy)</span><br><span class="line">                request.meta[<span class="string">'proxy'</span>] = uri</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">       <span class="built_in"> settings </span>= crawler.settings</span><br><span class="line">        return cls(<span class="attribute">proxy_url</span>=settings.get('PROXY_URL')</span><br><span class="line">        )</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>同样的原理，我们实现了一个 get_random_proxy() 方法用于请求代理池的接口获取随机代理。如果获取成功，则返回改代理，否则返回 False。在 process_request() 方法中，我们给 request 对象的 meta 属性赋值一个 proxy 字段，该字段的值就是代理。 另外，赋值代理的判断条件是当前 retry_times 不为空，也就是说第一次请求失败之后才启用代理，因为使用代理后访问速度会慢一些。所以我们在这里设置了只有重试的时候才启用代理，否则直接请求。这样就可以保证在没有被封禁的情况下直接爬取，保证了爬取速度。</p>
                  <h3 id="12-启用-Middleware"><a href="#12-启用-Middleware" class="headerlink" title="12. 启用 Middleware"></a>12. 启用 Middleware</h3>
                  <p>接下来，我们在配置文件中启用这两个 Middleware，修改 settings.py 如下所示：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">DOWNLOADER_MIDDLEWARES</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'weibo.middlewares.CookiesMiddleware':</span> <span class="number">554</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'weibo.middlewares.ProxyMiddleware':</span> <span class="number">555</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>注意这里的优先级设置，前文提到了 Scrapy 的默认 Downloader Middleware 的设置如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware':</span> <span class="number">300</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware':</span> <span class="number">350</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware':</span> <span class="number">400</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware':</span> <span class="number">500</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.retry.RetryMiddleware':</span> <span class="number">550</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware':</span> <span class="number">560</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware':</span> <span class="number">580</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware':</span> <span class="number">590</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.redirect.RedirectMiddleware':</span> <span class="number">600</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.cookies.CookiesMiddleware':</span> <span class="number">700</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware':</span> <span class="number">750</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.stats.DownloaderStats':</span> <span class="number">850</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware':</span> <span class="number">900</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>要使得我们自定义的 CookiesMiddleware 生效，它在内置的 CookiesMiddleware 之前调用。内置的 CookiesMiddleware 的优先级为 700，所以这里我们设置一个比 700 小的数字即可。 要使得我们自定义的 ProxyMiddleware 生效，它在内置的 HttpProxyMiddleware 之前调用。内置的 HttpProxyMiddleware 的优先级为 750，所以这里我们设置一个比 750 小的数字即可。</p>
                  <h3 id="13-运行"><a href="#13-运行" class="headerlink" title="13. 运行"></a>13. 运行</h3>
                  <p>到此为止，整个微博爬虫就实现完毕了，我们运行如下命令启动一下爬虫：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl weibocn</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>类似的输出结果如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-11</span> <span class="number">17</span><span class="string">:27:34</span> <span class="string">[urllib3.connectionpool]</span> <span class="attr">DEBUG:</span> <span class="string">http://localhost:5000</span> <span class="string">"GET /weibo/random HTTP/1.1"</span> <span class="number">200</span> <span class="number">339</span></span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-11</span> <span class="number">17</span><span class="string">:27:34</span> <span class="string">[weibo.middlewares]</span> <span class="attr">DEBUG:</span> <span class="string">使用</span> <span class="string">Cookies</span> <span class="string">&#123;"SCF":</span> <span class="string">"AhzwTr_DxIGjgri_dt46_DoPzUqq-PSupu545JdozdHYJ7HyEb4pD3pe05VpbIpVyY1ciKRRWwUgojiO3jYwlBE."</span><span class="string">,</span> <span class="attr">"_T_WM":</span> <span class="string">"8fe0bc1dad068d09b888d8177f1c1218"</span><span class="string">,</span> <span class="attr">"SSOLoginState":</span> <span class="string">"1501496388"</span><span class="string">,</span> <span class="attr">"M_WEIBOCN_PARAMS":</span> <span class="string">"uicode%3D20000174"</span><span class="string">,</span> <span class="attr">"SUHB":</span> <span class="string">"0tKqV4asxqYl4J"</span><span class="string">,</span> <span class="attr">"SUB":</span> <span class="string">"_2A250e3QUDeRhGeBM6VYX8y7NwjiIHXVXhBxcrDV6PUJbkdBeLXjckW2fUT8MWloekO4FCWVlIYJGJdGLnA.."</span><span class="string">&#125;</span></span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-11</span> <span class="number">17</span><span class="string">:27:34</span> <span class="string">[weibocn]</span> <span class="attr">DEBUG:</span> <span class="string">&lt;200</span> <span class="string">https://m.weibo.cn/api/container/getIndex?uid=1742566624&amp;type=uid&amp;value=1742566624&amp;containerid=1005051742566624&gt;</span></span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-11</span> <span class="number">17</span><span class="string">:27:34</span> <span class="string">[scrapy.core.scraper]</span> <span class="attr">DEBUG:</span> <span class="string">Scraped</span> <span class="string">from</span> <span class="string">&lt;200</span> <span class="string">https://m.weibo.cn/api/container/getIndex?uid=1742566624&amp;type=uid&amp;value=1742566624&amp;containerid=1005051742566624&gt;</span></span><br><span class="line"><span class="string">&#123;'avatar':</span> <span class="string">'https://tva4.sinaimg.cn/crop.0.0.180.180.180/67dd74e0jw1e8qgp5bmzyj2050050aa8.jpg'</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'cover':</span> <span class="string">'https://tva3.sinaimg.cn/crop.0.0.640.640.640/6ce2240djw1e9oaqhwllzj20hs0hsdir.jpg'</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'crawled_at':</span> <span class="string">'2017-07-11 17:27'</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'description':</span> <span class="string">' 成长，就是一个不断觉得以前的自己是个傻逼的过程 '</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'fans_count':</span> <span class="number">19202906</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'follows_count':</span> <span class="number">1599</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'gender':</span> <span class="string">'m'</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'id':</span> <span class="number">1742566624</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'name':</span> <span class="string">' 思想聚焦 '</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'verified':</span> <span class="literal">True</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'verified_reason':</span> <span class="string">' 微博知名博主，校导网编辑 '</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'verified_type':</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line"> <span class="attr">'weibos_count':</span> <span class="number">58393</span><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行一段时间后，我们便可以到 MongoDB 数据库查看数据，爬取下来的数据如图 13-38 和图 13-39 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034947.jpg" alt=""> 图 13-38 用户信息 <img src="https://cdn.cuiqingcai.com/2019-11-27-035001.jpg" alt=""> 图 13-39 微博信息 针对用户信息，我们不仅爬取了其基本信息，还把关注和粉丝列表加到了 follows 和 fans 字段并做了去重操作。针对微博信息，我们成功进行了时间转换处理，同时还保存了微博的图片列表信息。</p>
                  <h3 id="14-本节代码"><a href="#14-本节代码" class="headerlink" title="14. 本节代码"></a>14. 本节代码</h3>
                  <p>本节代码地址：<a href="https://github.com/Python3WebSpider/Weibo" target="_blank" rel="noopener">https://github.com/Python3WebSpider/Weibo</a>。</p>
                  <h3 id="15-结语"><a href="#15-结语" class="headerlink" title="15. 结语"></a>15. 结语</h3>
                  <p>本节实现了新浪微博的用户及其粉丝关注列表和微博信息的爬取，还对接了 Cookies 池和代理池来处理反爬虫。不过现在是针对单机的爬取，后面我们会将此项目修改为分布式爬虫，以进一步提高抓取效率。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-08 09:50:48" itemprop="dateCreated datePublished" datetime="2019-12-08T09:50:48+08:00">2019-12-08</time>
                </span>
                <span id="/8453.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.13–Scrapy 爬取新浪微博" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>17k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>15 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8448.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8448.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.12–Scrapy 对接 Docker</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-12-Scrapy-对接-Docker"><a href="#13-12-Scrapy-对接-Docker" class="headerlink" title="13.12 Scrapy 对接 Docker"></a>13.12 Scrapy 对接 Docker</h1>
                  <p>环境配置问题可能一直是我们头疼的，我们可能遇到过如下的情况：</p>
                  <ul>
                    <li>我们在本地写好了一个 Scrapy 爬虫项目，想要把它放到服务器上运行，但是服务器上没有安装 Python 环境。</li>
                    <li>别人给了我们一个 Scrapy 爬虫项目，项目中使用包的版本和我们本地环境版本不一致，无法直接运行。</li>
                    <li>我们需要同时管理不同版本的 Scrapy 项目，如早期的项目依赖于 Scrapy 0.25，现在的项目依赖于 Scrapy 1.4.0。</li>
                  </ul>
                  <p>在这些情况下，我们需要解决的就是环境的安装配置、环境的版本冲突解决等问题。 对于 Python 来说，VirtualEnv 的确可以解决版本冲突的问题。但是，VirtualEnv 不太方便做项目部署，我们还是需要安装 Python 环境， 如何解决上述问题呢？答案是用 Docker。Docker 可以提供操作系统级别的虚拟环境，一个 Docker 镜像一般都包含一个完整的操作系统，而这些系统内也有已经配置好的开发环境，如 Python 3.6 环境等。 我们可以直接使用此 Docker 的 Python 3 镜像运行一个容器，将项目直接放到容器里运行，就不用再额外配置 Python 3 环境。这样就解决了环境配置的问题。 我们也可以进一步将 Scrapy 项目制作成一个新的 Docker 镜像，镜像里只包含适用于本项目的 Python 环境。如果要部署到其他平台，只需要下载该镜像并运行就好了，因为 Docker 运行时采用虚拟环境，和宿主机是完全隔离的，所以也不需要担心环境冲突问题。 如果我们能够把 Scrapy 项目制作成一个 Docker 镜像，只要其他主机安装了 Docker，那么只要将镜像下载并运行即可，而不必再担心环境配置问题或版本冲突问题。 接下来，我们尝试把一个 Scrapy 项目制作成一个 Docker 镜像。</p>
                  <h3 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h3>
                  <p>我们要实现把前文 Scrapy 的入门项目打包成一个 Docker 镜像的过程。项目爬取的网址为：<a href="http://quotes.toscrape.com/" target="_blank" rel="noopener">http://quotes.toscrape.com/</a>，本章 Scrapy 入门一节已经实现了 Scrapy 对此站点的爬取过程，项目代码为：<a href="https://github.com/Python3WebSpider/ScrapyTutorial" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyTutorial</a>，如果本地不存在的话可以 Clone 下来。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>请确保已经安装好 Docker 和 MongoDB 并可以正常运行，如果没有安装可以参考第 1 章的安装说明。</p>
                  <h3 id="3-创建-Dockerfile"><a href="#3-创建-Dockerfile" class="headerlink" title="3. 创建 Dockerfile"></a>3. 创建 Dockerfile</h3>
                  <p>首先在项目的根目录下新建一个 requirements.txt 文件，将整个项目依赖的 Python 环境包都列出来，如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy</span></span><br><span class="line"><span class="attribute">pymongo</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果库需要特定的版本，我们还可以指定版本号，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy&gt;=<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">pymongo&gt;=<span class="number">3.4</span><span class="number">.0</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在项目根目录下新建一个 Dockerfile 文件，文件不加任何后缀名，修改内容如下所示：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/bin:$PATH</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> scrapy crawl quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一行的 FROM 代表使用的 Docker 基础镜像，在这里我们直接使用 python:3.6 的镜像，在此基础上运行 Scrapy 项目。 第二行 ENV 是环境变量设置，将 /usr/local/bin:$PATH 赋值给 PATH，即增加 /usr/local/bin 这个环境变量路径。 第三行 ADD 是将本地的代码放置到虚拟容器中。它有两个参数：第一个参数是.，代表本地当前路径；第二个参数是 /code，代表虚拟容器中的路径，也就是将本地项目所有内容放置到虚拟容器的 /code 目录下，以便于在虚拟容器中运行代码。 第四行 WORKDIR 是指定工作目录，这里将刚才添加的代码路径设成工作路径。这个路径下的目录结构和当前本地目录结构是相同的，所以我们可以直接执行库安装命令、爬虫运行命令等。 第五行 RUN 是执行某些命令来做一些环境准备工作。由于 Docker 虚拟容器内只有 Python 3 环境，而没有所需要的 Python 库，所以我们运行此命令来在虚拟容器中安装相应的 Python 库如 Scrapy，这样就可以在虚拟容器中执行 Scrapy 命令了。 第六行 CMD 是容器启动命令。在容器运行时，此命令会被执行。在这里我们直接用 scrapy crawl quotes 来启动爬虫。</p>
                  <h3 id="4-修改-MongoDB-连接"><a href="#4-修改-MongoDB-连接" class="headerlink" title="4. 修改 MongoDB 连接"></a>4. 修改 MongoDB 连接</h3>
                  <p>接下来我们需要修改 MongoDB 的连接信息。如果我们继续用 localhost 是无法找到 MongoDB 的，因为在 Docker 虚拟容器里 localhost 实际指向容器本身的运行 IP，而容器内部并没有安装 MongoDB，所以爬虫无法连接 MongoDB。 这里的 MongoDB 地址可以有如下两种选择。</p>
                  <ul>
                    <li>如果只想在本机测试，我们可以将地址修改为宿主机的 IP，也就是容器外部的本机 IP，一般是一个局域网 IP，使用 ifconfig 命令即可查看。</li>
                    <li>如果要部署到远程主机运行，一般 MongoDB 都是可公网访问的地址，修改为此地址即可。</li>
                  </ul>
                  <p>在本节中，我们的目标是将项目打包成一个镜像，让其他远程主机也可运行这个项目。所以我们直接将此处 MongoDB 地址修改为某个公网可访问的远程数据库地址，修改 MONGO_URI 如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MONGO_URI</span> = <span class="string">'mongodb://admin:admin123@120.27.34.25:27017'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此处地址可以修改为自己的远程 MongoDB 数据库地址。 这样项目的配置就完成了。</p>
                  <h3 id="5-构建镜像"><a href="#5-构建镜像" class="headerlink" title="5. 构建镜像"></a>5. 构建镜像</h3>
                  <p>接下来我们便可以构建镜像了，执行如下命令：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t quotes:latest .</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样的输出就说明镜像构建成功。这时我们查看一下构建的镜像，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Sending build context to Docker daemon <span class="number">191.5</span> kB</span><br><span class="line">Step <span class="number">1</span>/<span class="number">6</span> : FROM python:<span class="number">3.6</span></span><br><span class="line"> ---&gt; <span class="number">968120</span>d8cbe8</span><br><span class="line">Step <span class="number">2</span>/<span class="number">6</span> : ENV PATH /usr/local/bin:$PATH</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; <span class="number">387</span>abbba1189</span><br><span class="line">Step <span class="number">3</span>/<span class="number">6</span> : ADD . /code</span><br><span class="line"> ---&gt; a844ee0db9c6</span><br><span class="line">Removing <span class="built_in">int</span>ermediate container <span class="number">4</span>dc41779c573</span><br><span class="line">Step <span class="number">4</span>/<span class="number">6</span> : WORKDIR /code</span><br><span class="line"> ---&gt; <span class="number">619</span>b2c064ae9</span><br><span class="line">Removing <span class="built_in">int</span>ermediate container bcd7cd7f7337</span><br><span class="line">Step <span class="number">5</span>/<span class="number">6</span> : RUN pip3 install -r requirements.txt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> <span class="number">9452</span>c83a12c5</span><br><span class="line">...</span><br><span class="line">Removing <span class="built_in">int</span>ermediate container <span class="number">9452</span>c83a12c5</span><br><span class="line">Step <span class="number">6</span>/<span class="number">6</span> : CMD scrapy crawl quotes</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c092b5557ab8</span><br><span class="line"> ---&gt; c8101aca6e2a</span><br><span class="line">Removing <span class="built_in">int</span>ermediate container c092b5557ab8</span><br><span class="line">Successfully built c8101aca6e2a</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>出现类似输出就证明镜像构建成功了，这时执行如我们查看一下构建的镜像：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">docker images</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回结果中其中有一行就是：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">quotes  latest  <span class="number">41</span>c8499ce210    <span class="number">2</span> minutes ago   <span class="number">769</span> MB</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是我们新构建的镜像。</p>
                  <h3 id="6-运行"><a href="#6-运行" class="headerlink" title="6. 运行"></a>6. 运行</h3>
                  <p>我们可以先在本地测试运行，执行如下命令：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker <span class="keyword">run</span><span class="bash"> quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就利用此镜像新建并运行了一个 Docker 容器，运行效果完全一致，如图 13-29 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034816.jpg" alt=""> 图 13-32 运行结果 如果出现类似图 13-29 的运行结果，这就证明构建的镜像没有问题。</p>
                  <h3 id="7-推送至-Docker-Hub"><a href="#7-推送至-Docker-Hub" class="headerlink" title="7. 推送至 Docker Hub"></a>7. 推送至 Docker Hub</h3>
                  <p>构建完成之后，我们可以将镜像 Push 到 Docker 镜像托管平台，如 Docker Hub 或者私有的 Docker Registry 等，这样我们就可以从远程服务器下拉镜像并运行了。 以 Docker Hub 为例，如果项目包含一些私有的连接信息（如数据库），我们最好将 Repository 设为私有或者直接放到私有的 Docker Registry。 首先在 <a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 注册一个账号，新建一个 Repository，名为 quotes。比如，我的用户名为 germey，新建的 Repository 名为 quotes，那么此 Repository 的地址就可以用 germey/quotes 来表示。 为新建的镜像打一个标签，命令如下所示：</p>
                  <figure class="highlight crmsh">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker <span class="keyword">tag</span> <span class="title">quotes</span>:latest germey/quotes:latest</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>推送镜像到 Docker Hub 即可，命令如下所示：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">docker</span> <span class="keyword">push </span>germey/quotes</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>Docker Hub 便会出现新推送的 Docker 镜像了，如图 13-30 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034823.png" alt=""> 图 13-30 推送结果 如果我们想在其他的主机上运行这个镜像，主机上装好 Docker 后，可以直接执行如下命令：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker <span class="keyword">run</span><span class="bash"> germey/quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就会自动下载镜像，然后启动容器运行，不需要配置 Python 环境，不需要关心版本冲突问题。 运行效果如图 13-31 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034829.jpg" alt=""> 图 13-31 运行效果 整个项目爬取完成后，数据就可以存储到指定的数据库中。</p>
                  <h3 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h3>
                  <p>我们讲解了将 Scrapy 项目制作成 Docker 镜像并部署到远程服务器运行的过程。使用此种方式，我们在本节开头所列出的问题都迎刃而解。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-07 10:23:45" itemprop="dateCreated datePublished" datetime="2019-12-07T10:23:45+08:00">2019-12-07</time>
                </span>
                <span id="/8448.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.12–Scrapy 对接 Docker" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>4 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8445.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8445.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.11–Scrapyrt 的使用</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-11-Scrapyrt-的使用"><a href="#13-11-Scrapyrt-的使用" class="headerlink" title="13.11 Scrapyrt 的使用"></a>13.11 Scrapyrt 的使用</h1>
                  <p>Scrapyrt 为 Scrapy 提供了一个调度的 HTTP 接口。有了它我们不需要再执行 Scrapy 命令，而是通过请求一个 HTTP 接口即可调度 Scrapy 任务，我们就不需要借助于命令行来启动项目了。如果项目是在远程服务器运行，利用它来启动项目是个不错的选择。</p>
                  <h3 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h3>
                  <p>我们以本章 Scrapy 入门项目为例来说明 Scrapyrt 的使用方法，项目源代码地址为：<a href="https://github.com/Python3WebSpider/ScrapyTutorial" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyTutorial</a>。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>请确保 Scrapyrt 已经正确安装并正常运行，具体安装可以参考第 1 章的说明。</p>
                  <h3 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3. 启动服务"></a>3. 启动服务</h3>
                  <p>首先将项目下载下来，在项目目录下运行 Scrapyrt，假设当前服务运行在 9080 端口上。下面将简单介绍 Scrapyrt 的使用方法。</p>
                  <h3 id="4-GET-请求"><a href="#4-GET-请求" class="headerlink" title="4. GET 请求"></a>4. GET 请求</h3>
                  <p>目前，GET 请求方式支持如下的参数。</p>
                  <ul>
                    <li>spider_name，Spider 名称，字符串类型，必传参数，如果传递的 Spider 名称不存在则会返回 404 错误。</li>
                    <li>url，爬取链接，字符串类型，如果起始链接没有定义的话就必须要传递，如果传递了该参数，Scrapy 会直接用该 URL 生成 Request，而直接忽略 start_requests() 方法和 start_urls 属性的定义。</li>
                    <li>callback，回调函数名称，字符串类型，可选参数，如果传递了就会使用此回调函数处理，否则会默认使用 Spider 内定义的回调函数。</li>
                    <li>max_requests，最大请求数量，数值类型，可选参数，它定义了 Scrapy 执行请求的 Request 的最大限制，如定义为 5，则最多只执行 5 次 Request 请求，其余的则会被忽略。</li>
                    <li>start_requests，是否要执行 start_request() 函数，布尔类型，可选参数，在 Scrapy 项目中如果定义了 start_requests() 方法，那么在项目启动时会默认调用该方法，但是在 Scrapyrt 就不一样了，它默认不执行 start_requests() 方法，如果要执行，需要将它设置为 true。</li>
                  </ul>
                  <p>例如我们执行如下命令：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl http:<span class="regexp">//</span>localhost:<span class="number">9080</span><span class="regexp">/crawl.json?spider_name=quotes&amp;url=http:/</span><span class="regexp">/quotes.toscrape.com/</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>得到类似如下结果，如图 13-28 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034631.jpg" alt=""> 图 13-28 输出结果 返回的是一个 JSON 格式的字符串，我们解析它的结构，如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"ok"</span>,</span><br><span class="line">  <span class="attr">"items"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"“The world as we have created it is a process of o..."</span>,</span><br><span class="line">      <span class="attr">"author"</span>: <span class="string">"Albert Einstein"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [</span><br><span class="line">        <span class="string">"change"</span>,</span><br><span class="line">        <span class="string">"deep-thoughts"</span>,</span><br><span class="line">        <span class="string">"thinking"</span>,</span><br><span class="line">        <span class="string">"world"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"“... a mind needs books as a sword needs a whetsto..."</span>,</span><br><span class="line">      <span class="attr">"author"</span>: <span class="string">"George R.R. Martin"</span>,</span><br><span class="line">      <span class="attr">"tags"</span>: [</span><br><span class="line">        <span class="string">"books"</span>,</span><br><span class="line">        <span class="string">"mind"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"items_dropped"</span>: [],</span><br><span class="line">  <span class="attr">"stats"</span>: &#123;</span><br><span class="line">    <span class="attr">"downloader/request_bytes"</span>: <span class="number">2892</span>,</span><br><span class="line">    <span class="attr">"downloader/request_count"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"downloader/request_method_count/GET"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"downloader/response_bytes"</span>: <span class="number">24812</span>,</span><br><span class="line">    <span class="attr">"downloader/response_count"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"downloader/response_status_count/200"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"downloader/response_status_count/404"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"dupefilter/filtered"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"finish_reason"</span>: <span class="string">"finished"</span>,</span><br><span class="line">    <span class="attr">"finish_time"</span>: <span class="string">"2017-07-12 15:09:02"</span>,</span><br><span class="line">    <span class="attr">"item_scraped_count"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"log_count/DEBUG"</span>: <span class="number">112</span>,</span><br><span class="line">    <span class="attr">"log_count/INFO"</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">"memusage/max"</span>: <span class="number">52510720</span>,</span><br><span class="line">    <span class="attr">"memusage/startup"</span>: <span class="number">52510720</span>,</span><br><span class="line">    <span class="attr">"request_depth_max"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"response_received_count"</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="attr">"scheduler/dequeued"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"scheduler/dequeued/memory"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"scheduler/enqueued"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"scheduler/enqueued/memory"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"start_time"</span>: <span class="string">"2017-07-12 15:08:56"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"spider_name"</span>: <span class="string">"quotes"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里省略了 items 绝大部分。status 显示了爬取的状态，items 部分是 Scrapy 项目的爬取结果，items_dropped 是被忽略的 Item 列表，stats 是爬取结果的统计情况。此结果和直接运行 Scrapy 项目得到的统计是相同的。 这样一来，我们就通过 HTTP 接口调度 Scrapy 项目并获取爬取结果，如果 Scrapy 项目部署在服务器上，我们可以通过开启一个 Scrapyrt 服务实现任务的调度并直接取到爬取结果，这很方便。</p>
                  <h3 id="5-POST-请求"><a href="#5-POST-请求" class="headerlink" title="5. POST 请求"></a>5. POST 请求</h3>
                  <p>除了 GET 请求，我们还可以通过 POST 请求来请求 Scrapyrt。但是此处 Request Body 必须是一个合法的 JSON 配置，在 JSON 里面可以配置相应的参数，支持的配置参数更多。 目前，JSON 配置支持如下参数。</p>
                  <ul>
                    <li><strong>spider_name</strong>：Spider 名称，字符串类型，必传参数。如果传递的 Spider 名称不存在，则返回 404 错误。</li>
                    <li><strong>max_requests</strong>：最大请求数量，数值类型，可选参数。它定义了 Scrapy 执行请求的 Request 的最大限制，如定义为 5，则表示最多只执行 5 次 Request 请求，其余的则会被忽略。</li>
                    <li><strong>request</strong>：Request 配置，JSON 对象，必传参数。通过该参数可以定义 Request 的各个参数，必须指定 url 字段来指定爬取链接，其他字段可选。</li>
                  </ul>
                  <p>我们看一个 JSON 配置实例，如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"request"</span>: &#123;</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://quotes.toscrape.com/"</span>,</span><br><span class="line">        <span class="attr">"callback"</span>: <span class="string">"parse"</span>,</span><br><span class="line">        <span class="attr">"dont_filter"</span>: <span class="string">"True"</span>,</span><br><span class="line">        <span class="attr">"cookies"</span>: &#123;<span class="attr">"foo"</span>: <span class="string">"bar"</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"max_requests"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"spider_name"</span>: <span class="string">"quotes"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们执行如下命令传递该 Json 配置并发起 POST 请求：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl http:<span class="regexp">//</span>localhost:<span class="number">9080</span><span class="regexp">/crawl.json -d '&#123;"request": &#123;"url": "http:/</span><span class="regexp">/quotes.toscrape.com/</span><span class="string">", "</span>dont_filte<span class="string">r": "</span>True<span class="string">", "</span>callback<span class="string">": "</span>parse<span class="string">", "</span>cookies<span class="string">": &#123;"</span>foo<span class="string">": "</span>ba<span class="string">r"&#125;&#125;, "</span>max_requests<span class="string">": 2, "</span>spider_name<span class="string">": "</span>quotes<span class="string">"&#125;'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果和上文类似，同样是输出了爬取状态、结果、统计信息等内容。</p>
                  <h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h3>
                  <p>以上内容便是 Scrapyrt 的相关用法介绍。通过它，我们方便地调度 Scrapy 项目的运行并获取爬取结果。更多的使用方法可以参考官方文档：<a href="http://scrapyrt.readthedocs.io" target="_blank" rel="noopener">http://scrapyrt.readthedocs.io</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-07 10:20:01" itemprop="dateCreated datePublished" datetime="2019-12-07T10:20:01+08:00">2019-12-07</time>
                </span>
                <span id="/8445.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.11–Scrapyrt 的使用" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8443.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8443.html" class="post-title-link" itemprop="url">Nginx 反向代理返回结果为空的问题</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>最近在开发过程中遇到了这么一个问题： 现在有一个 Web 项目，前端是使用 Vue.js 开发的，整个前端需要部署到 K8S 上，后端和前端分开，同样也需要部署到 K8S 上，因此二者需要打包为 Docker 镜像。 对前端来说，打包 Docker 就遇到了一个问题：跨域访问问题。 因此一个普遍的解决方案就是使用 Nginx 做反向代理。 一般来说，我们需要在打包时配置一下 nginx.conf 文件，然后在 Dockerfile 里面指定即可。</p>
                  <h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2>
                  <p>首先看下 Dockerfile：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># build stage</span></span><br><span class="line"><span class="keyword">FROM</span> node:lts-alpine as build-stage</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># production stage</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:lts-alpine as production-stage</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build-stage /app/dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/conf.d/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm /etc/nginx/conf.d/default.conf</span></span><br><span class="line">    &amp;&amp; mv /etc/nginx/conf.d/nginx.conf /etc/nginx/conf.d/default.conf</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>一般来说，对于常规的 Vue.js 前端项目，Dockerfile 就这么写就行了。 简单介绍一下：</p>
                  <ul>
                    <li>第一步，使用 Node.js 镜像，在 Node.js 环境下对项目进行编译，默认会输出到 dist 文件夹下。</li>
                    <li>第二步，使用新的 Nginx 镜像，将编译得到的前端文件拷贝到 nginx 默认 serve 的目录，然后把自定义的 nginx.conf 文件替换为 Nginx 默认的 conf 文件，运行即可。</li>
                  </ul>
                  <h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2>
                  <p>这里比较关键的就是 nginx.conf 文件了，为了解决跨域问题，我们一般会将后端的接口进行反向代理。 一般来说，后端的 API 接口都是以 api 为开头的，所以我们需要代理 api 开头的接口地址，nginx.conf 内容一般可以这么写：</p>
                  <figure class="highlight nginx">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api/ &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://domain.com/api/;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span>              /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>一般来说，以上的写法是没有问题的，proxy_set_header 也把一些 Header 进行设置，转发到后端服务器。 如果你这么写，打包 Docker 之后，测试没有遇到问题，那就完事了。</p>
                  <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>
                  <p>但我遇到了一个奇怪的问题，某个接口在请求的时候，状态码还是 200，但其返回值总是为空，即 Response Data 的内容完全为空。 但是服务器端看 Log 确实有正常返回 Response，使用 Vue 的 devServer 也是正常的，使用 Postman 来请求也是正常的，但是经过 Nginx 这么一反向代理就不行了，什么 Response 都接收不到。 部署到 Prod 环境之后，浏览器上面可以得到这么个错误：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">ERR_INCOMPLETE_CHUNKED_ENCODING</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p><img src="https://cdn.cuiqingcai.com/2019-12-06-202934.png" alt="image-20191207042932549"> 最后经排查，发现后端接口使用时设定了 <code>Transfer-Encoding: chunked</code> 响应头：</p>
                  <figure class="highlight fortran">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="built_in">Transfer</span>-Encoding: chunked</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这是啥？这时候就需要引出 Keep-Alive 的相关问题了。</p>
                  <h2 id="什么是-Keep-Alive？"><a href="#什么是-Keep-Alive？" class="headerlink" title="什么是 Keep-Alive？"></a>什么是 Keep-Alive？</h2>
                  <p>我们知道 HTTP 协议采用「请求-应答」模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）。当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>
                  <ul>
                    <li>HTTP 1.0 中默认是关闭 Keep-Alive 的，需要在 HTTP 头加入<code>Connection: Keep-Alive</code>，才能启用 Keep-Alive</li>
                    <li>HTTP 1.1 中默认启用 Keep-Alive，如果请求头中加入 <code>Connection: close</code>，Keep-Alive 才关闭。</li>
                  </ul>
                  <p>目前大部分浏览器都是用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。 启用 Keep-Alive 模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。</p>
                  <h2 id="Keep-Alive-模式下如何传输数据"><a href="#Keep-Alive-模式下如何传输数据" class="headerlink" title="Keep-Alive 模式下如何传输数据"></a>Keep-Alive 模式下如何传输数据</h2>
                  <p>Keep-Alive 模式，客户端如何判断请求所得到的响应数据已经接收完成呢？或者说如何知道服务器已经发生完了数据？ 我们已经知道了，Keep-Alive 模式发送完数据，HTTP 服务器不会自动断开连接，所有不能再使用返回 EOF（-1）来判断。 那么怎么判断呢？一个是使用 Content-Length ，一个是使用 Transfer-Encoding。</p>
                  <h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3>
                  <p>顾名思义，Conent-Length 表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。 由于 <code>Content-Length</code> 字段必须真实反映实体长度，但实际应用中，有些时候实体长度并没那么好获得，例如实体来自于网络文件，或者由动态语言生成。这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。 我们在做 WEB 性能优化时，有一个重要的指标叫 TTFB（Time To First Byte），它代表的是从客户端发出请求到收到响应的第一个字节所花费的时间。大部分浏览器自带的 Network 面板都可以看到这个指标，越短的 TTFB 意味着用户可以越早看到页面内容，体验越好。可想而知，服务端为了计算响应实体长度而缓存所有内容，跟更短的 TTFB 理念背道而驰。但在 HTTP 报文中，实体一定要在头部之后，顺序不能颠倒，为此我们需要一个新的机制：不依赖头部的长度信息，也能知道实体的边界。 但是如果消息中没有 Conent-Length，那该如何来判断呢？又在什么情况下会没有 Conent-Length 呢？</p>
                  <h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3>
                  <p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚地知道内容大小，然后通过 Content-length 消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用 分块编码模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要在请求头中使用<code>Transfer-Encoding: chunked</code> 这样的方式来代替 Content-Length，这就是分块编码。 分块编码相当简单，在头部加入 <code>Transfer-Encoding: chunked</code> 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（rn），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。</p>
                  <h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2>
                  <p>那么我说了这么一大通有什么用呢？ OK，在我遇到的业务场景中，我发现服务器的响应头中就包含了<code>Transfer-Encoding: chunked</code> 这个字段。 而这个字段，在 HTTP 1.0 是不被支持的。 而 Nginx 的反向代理，默认用的就是 HTTP 1.0，那就导致了数据无法获取的问题，可以参考 Nginx 的官方文档说明：<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass</a>。 原文中：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Syntax: proxy_http_version <span class="number">1.0</span> | <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">Default</span>: proxy_http_version <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">By</span> <span class="keyword">default</span>, <span class="keyword">version</span> <span class="number">1.0</span> <span class="keyword">is</span> used. <span class="keyword">Version</span> <span class="number">1.1</span> <span class="keyword">is</span> recommended <span class="keyword">for</span> use <span class="keyword">with</span> keepalive connections <span class="keyword">and</span> NTLM authentication.</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>所以，我们如果要解决这个问题，只需要设置一下 HTTP 版本为 1.1 就好了： 修改 nginx.conf 文件如下：</p>
                  <figure class="highlight nginx">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://domain.com/api/;</span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里就增加了一行：</p>
                  <figure class="highlight abnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">proxy_http_version <span class="number">1.1</span><span class="comment">;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样再测试，反向代理就会支持 <code>Transfer-Encoding: chunked</code> 模式了，这也就呼应了之前在浏览器中遇到的 ERR_INCOMPLETE_CHUNKED_ENCODING 错误。 自此，问题完美解决。</p>
                  <h2 id="复盘记录"><a href="#复盘记录" class="headerlink" title="复盘记录"></a>复盘记录</h2>
                  <p>一开始本来只想简单一记录就了事的，但一边写，发现某个地方还可以展开写得更详细。 所以干脆最后我对这个问题进行了详细的复盘和记录。在写本文之前，我其实只思考到了 Keep-Alive 和 HTTP 1.1 的问题，其实我对 Transfer-Encoding 这个并没有去深入思考。在边写边总结的过程中，为了把整个脉络讲明白，我又查询了一些 Transfer-Encoding 和 Nginx 的官方文档，对这块的了解变得更加深入，相当于我在整个记录的过程中，又对整个流程梳理了一遍，同时又有额外的收获。 所以，遇到问题，深入去思考、总结和复盘，是很有帮助的，这会让我们对问题的看法和理解更加透彻。 怎么说呢？在开发过程中，难免会遇到一些奇奇怪怪的 Bug，但这其实只是技术问题，总会解决的。 但怎样在开发过程中，不断提高自己的技术能力，我觉得需要从每一个细节出发，去思考一些事情的来龙去脉。思考得越多，我们对整个事件的把握也会越清晰，以后如果再遇到类似的或者关联的事情，就会迎刃而解了。 平时我们可能很多情况下都在写业务代码，可能比较枯燥，感觉对技术没有实质性的提升，但如果我们能从中提炼出一些核心的问题或解决方案，这才是能真正提高技术的时候，这才是最有价值的。</p>
                  <h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>
                  <p>本文部分内容改写或摘自下列内容。</p>
                  <ul>
                    <li>HTTP Keep-Alive 模式：<a href="https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a></li>
                    <li>Nginx proxy_set_header 理解：<a href="https://www.jianshu.com/p/cc5167032525" target="_blank" rel="noopener">https://www.jianshu.com/p/cc5167032525</a></li>
                    <li>使用 Docker 打造超溜的前端环境：<a href="https://github.com/axetroy/blog/issues/178" target="_blank" rel="noopener">https://github.com/axetroy/blog/issues/178</a></li>
                    <li>HTTP 协议中的 Transfer-Encoding：<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="noopener">https://imququ.com/post/transfer-encoding-header-in-http.html</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-07 06:26:39" itemprop="dateCreated datePublished" datetime="2019-12-07T06:26:39+08:00">2019-12-07</time>
                </span>
                <span id="/8443.html" class="post-meta-item leancloud_visitors" data-flag-title="Nginx 反向代理返回结果为空的问题" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>5 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8418.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 技术杂谈 <i class="label-arrow"></i>
                  </a>
                  <a href="/8418.html" class="post-title-link" itemprop="url">阿里云服务器活动！阿里云代金券 + 1 折优惠码</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>阿里云作为国内最大的云服务商家，个人与企业上云都纷纷首选阿里云。但是在价格方面比整个市场有些许昂贵，让不少用户却而止步。因此<a href="https://www.xingsuyun58.com/" target="_blank" rel="noopener">星速云</a>小编呕心沥血整理阿里云最新优惠折扣【汇总篇】，让大家不用花时间到处寻找优惠信息，帮助站长、开发者和企业们上云购节省项目开支。</p>
                  <hr>
                  <h1 id="最全：阿里云最新优惠获取教程【长期有效】"><a href="#最全：阿里云最新优惠获取教程【长期有效】" class="headerlink" title="最全：阿里云最新优惠获取教程【长期有效】"></a>最全：阿里云最新优惠获取教程【长期有效】</h1>
                  <hr>
                  <h2 id="①：阿里云代金券2000元红包"><a href="#①：阿里云代金券2000元红包" class="headerlink" title="①：阿里云代金券2000元红包"></a>①：阿里云代金券2000元红包</h2>
                  <p>阿里云代金券领取很简单，点击下面链接进行领取。 <a href="https://www.xingsuyun58.com/wp-content/uploads/2019/11/1575037236.png" target="_blank" rel="noopener"><img src="https://www.xingsuyun58.com/wp-content/uploads/2019/11/1575037236.png" alt="阿里云代金券领取和使用步骤教程"></a> 阿里云代金券领取地址：<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=ahxhg8oc" target="_blank" rel="noopener">点击领取2000元代金券礼包</a> 点击“立即领取”按钮就可以一键领取到所有满减代金券，最高2000元。别忘记通过购物车一键批量购买哟！</p>
                  <h2 id="②：阿里云9折优惠码"><a href="#②：阿里云9折优惠码" class="headerlink" title="②：阿里云9折优惠码"></a>②：阿里云9折优惠码</h2>
                  <p>新用户还可以使用手机扫码领取一个阿里云9折折扣码叠加上述阿里云代金券使用。该9折码只能通过阿里云手机客户端扫描领取，PC端无法领取，（限ECS首购并且优惠高于7折才可以使用，比如优惠已经为5折，则该折扣码无效） <a href="https://www.xingsuyun58.com/wp-content/uploads/2019/11/15750316201.png" target="_blank" rel="noopener"><img src="https://www.xingsuyun58.com/wp-content/uploads/2019/11/15750316201.png" alt="阿里云代金券"></a> 注明：阿里云9折优惠码与阿里云2000元红包可叠加优惠折扣。</p>
                  <hr>
                  <h1 id="阿里云双12期间（2019-12-3-2019-12-31）最新优惠活动"><a href="#阿里云双12期间（2019-12-3-2019-12-31）最新优惠活动" class="headerlink" title="阿里云双12期间（2019.12.3-2019.12.31）最新优惠活动"></a>阿里云双12期间（2019.12.3-2019.12.31）最新优惠活动</h1>
                  <hr>
                  <p>阿里云双12优惠活动终于开启了，新用户1折甩卖，老用户五折，还可以领取2000元红包，优惠力度不亚于双11优惠活动哟！还不赶紧上云呢？错过双11优惠活动，那么双12不容错过了！ <a href="https://www.aliyun.com/minisite/goods?userCode=ahxhg8oc&amp;share_source=copy_link" target="_blank" rel="noopener"><img src="https://www.xingsuyun58.com/wp-content/uploads/2019/12/aliyun12pintuan.jpg" alt="阿里云双12活动"></a></p>
                  <h2 id="什么？您还不知道云服务器用途"><a href="#什么？您还不知道云服务器用途" class="headerlink" title="什么？您还不知道云服务器用途"></a>什么？您还不知道云服务器用途</h2>
                  <p>不管是做web网站、APP程序后端部署、应用程序后端、小程序后端等，还是打算创业的小伙伴，或者传统IDC自建机房的企业，上云已成为趋势。云服务器更便捷省心、节约IT运维的成本。</p>
                  <h2 id="新用户1折优惠售卖："><a href="#新用户1折优惠售卖：" class="headerlink" title="新用户1折优惠售卖："></a>新用户1折优惠售卖：</h2>
                  <p>实例规格</p>
                  <p>配置</p>
                  <p>带宽</p>
                  <p>时长</p>
                  <p>价格</p>
                  <p>官网购买</p>
                  <p>ECS突发性能型t5</p>
                  <p>1核2G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>89.00元</p>
                  <p>【<a href="https://www.aliyun.com/minisite/goods?userCode=ahxhg8oc&amp;share_source=copy_link" target="_blank" rel="noopener">立即抢购</a>】</p>
                  <p>ECS突发性能型t5</p>
                  <p>1核2G40G高效云盘</p>
                  <p>1M</p>
                  <p>3年</p>
                  <p>229.00元</p>
                  <p>ECS共享型n4</p>
                  <p>2核4G40G高效云盘</p>
                  <p>3M</p>
                  <p>2年</p>
                  <p>469.00元</p>
                  <p>ECS突发性能t5</p>
                  <p>2核4G40G高效云盘</p>
                  <p>5M</p>
                  <p>3年</p>
                  <p>899.00元</p>
                  <p>ECS突发性能t5</p>
                  <p>2核4G40G高效云盘</p>
                  <p>3M</p>
                  <p>3年</p>
                  <p>639.00元</p>
                  <p>ECS共享型n4</p>
                  <p>2核4G40G高效云盘</p>
                  <p>3M</p>
                  <p>3年</p>
                  <p>799.00元</p>
                  <p>ECS共享通用型mn4</p>
                  <p>2核8G40G高效云盘</p>
                  <p>5M</p>
                  <p>3年</p>
                  <p>1399.00元</p>
                  <p>ECS突发性能t5（香港）</p>
                  <p>1核1G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>119.00元</p>
                  <p>ECS网络增强型sn1ne</p>
                  <p>4核8G40G高效云盘</p>
                  <p>5M</p>
                  <p>3年</p>
                  <p>5621.00元</p>
                  <p>8核16G40G高效云盘</p>
                  <p>8M</p>
                  <p>3年</p>
                  <p>12209.00元</p>
                  <hr>
                  <p>注明：突发性t5实例，别看到价格比较便宜就直接购买，里面很多套路，购买页面有提示：限制20%性能基线。释义：依靠CPU 积分来提升 CPU 性能，满足业务需求。当实例实际工作性能高于基准 CPU 计算性能时，会把服务器 CPU 的性能限制在 20%以下，如果这时20%CPU性能满足不了业务需求，云服务器CPU会跑满100%，到那时候你以为是被某大佬攻击了，很有可能是你突发性t5实例CPU 积分消耗完了。笔者建议：如果用户业务对 CPU 要求高的，可以直接略过，选择t5实例（无限制CPU性能）、n4共享型、通用型mn4。以下笔者建议爆款：</p>
                  <h2 id="个人博客与企业微服务首选"><a href="#个人博客与企业微服务首选" class="headerlink" title="个人博客与企业微服务首选"></a>个人博客与企业微服务首选</h2>
                  <p><a href="https://www.aliyun.com/minisite/goods?userCode=ahxhg8oc&amp;share_source=copy_link" target="_blank" rel="noopener"><img src="https://www.xingsuyun58.com/wp-content/uploads/2019/12/15754425651.png" alt="阿里云双12云服务器爆款"></a></p>
                  <h2 id="老用户五折优惠甩卖："><a href="#老用户五折优惠甩卖：" class="headerlink" title="老用户五折优惠甩卖："></a>老用户五折优惠甩卖：</h2>
                  <p>实例规格</p>
                  <p>CPU/内存/云盘</p>
                  <p>带宽</p>
                  <p>时长</p>
                  <p>价格</p>
                  <p>老用户优惠购买</p>
                  <p>云服务器计算型ic5</p>
                  <p>8核8G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>4433.94元</p>
                  <p>【<a href="https://www.aliyun.com/minisite/goods?userCode=ahxhg8oc&amp;share_source=copy_link" target="_blank" rel="noopener">立即抢购</a>】</p>
                  <p>计算网络增强型sn1ne</p>
                  <p>8核16G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>3751.20元</p>
                  <p>通用网络增强型sn2ne</p>
                  <p>8核32G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>5353.20元</p>
                  <p>内存网络增强型se1ne</p>
                  <p>8核64G40G高效云盘</p>
                  <p>1M</p>
                  <p>1年</p>
                  <p>6793.20元</p>
                  <blockquote>
                    <p>注明：本文为星速云原创版权所有，禁止转载，一经发现将追究版权责任！</p>
                  </blockquote>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-06 18:43:17" itemprop="dateCreated datePublished" datetime="2019-12-06T18:43:17+08:00">2019-12-06</time>
                </span>
                <span id="/8418.html" class="post-meta-item leancloud_visitors" data-flag-title="阿里云服务器活动！阿里云代金券 + 1 折优惠码" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8413.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8413.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.10–Scrapy 通用爬虫</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-10-Scrapy-通用爬虫"><a href="#13-10-Scrapy-通用爬虫" class="headerlink" title="13.10 Scrapy 通用爬虫"></a>13.10 Scrapy 通用爬虫</h1>
                  <p>通过 Scrapy，我们可以轻松地完成一个站点爬虫的编写。但如果抓取的站点量非常大，比如爬取各大媒体的新闻信息，多个 Spider 则可能包含很多重复代码。 如果我们将各个站点的 Spider 的公共部分保留下来，不同的部分提取出来作为单独的配置，如爬取规则、页面解析方式等抽离出来做成一个配置文件，那么我们在新增一个爬虫的时候，只需要实现这些网站的爬取规则和提取规则即可。 本节我们就来探究一下 Scrapy 通用爬虫的实现方法。</p>
                  <h3 id="1-CrawlSpider"><a href="#1-CrawlSpider" class="headerlink" title="1. CrawlSpider"></a>1. CrawlSpider</h3>
                  <p>在实现通用爬虫之前我们需要先了解一下 CrawlSpider，其官方文档链接为：<a href="http://scrapy.readthedocs.io/en/latest/topics/spiders.html#crawlspider" target="_blank" rel="noopener">http://scrapy.readthedocs.io/en/latest/topics/spiders.html#crawlspider</a>。 CrawlSpider 是 Scrapy 提供的一个通用 Spider。在 Spider 里，我们可以指定一些爬取规则来实现页面的提取，这些爬取规则由一个专门的数据结构 Rule 表示。Rule 里包含提取和跟进页面的配置，Spider 会根据 Rule 来确定当前页面中的哪些链接需要继续爬取、哪些页面的爬取结果需要用哪个方法解析等。 CrawlSpider 继承自 Spider 类。除了 Spider 类的所有方法和属性，它还提供了一个非常重要的属性和方法。</p>
                  <ul>
                    <li>rules，它是爬取规则属性，是包含一个或多个 Rule 对象的列表。每个 Rule 对爬取网站的动作都做了定义，CrawlSpider 会读取 rules 的每一个 Rule 并进行解析。</li>
                    <li>parse_start_url()，它是一个可重写的方法。当 start_urls 里对应的 Request 得到 Response 时，该方法被调用，它会分析 Response 并必须返回 Item 对象或者 Request 对象。</li>
                  </ul>
                  <p>这里最重要的内容莫过于 Rule 的定义了，它的定义和参数如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">class scrapy.contrib.spiders.Rule(link_extractor, <span class="attribute">callback</span>=None, <span class="attribute">cb_kwargs</span>=None, <span class="attribute">follow</span>=None, <span class="attribute">process_links</span>=None, <span class="attribute">process_request</span>=None)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>下面对其参数依次说明：</p>
                  <ul>
                    <li>link_extractor，是一个 Link Extractor 对象。通过它，Spider 可以知道从爬取的页面中提取哪些链接。提取出的链接会自动生成 Request。它又是一个数据结构，一般常用 LxmlLinkExtractor 对象作为参数，其定义和参数如下所示：</li>
                  </ul>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">class scrapy.linkextractors.lxmlhtml.LxmlLinkExtractor(allow=(), deny=(), allow_domains=(), deny_domains=(), <span class="attribute">deny_extensions</span>=None, restrict_xpaths=(), restrict_css=(), tags=(<span class="string">'a'</span>, <span class="string">'area'</span>), attrs=(<span class="string">'href'</span>,), <span class="attribute">canonicalize</span>=<span class="literal">False</span>, <span class="attribute">unique</span>=<span class="literal">True</span>, <span class="attribute">process_value</span>=None, <span class="attribute">strip</span>=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>allow 是一个正则表达式或正则表达式列表，它定义了从当前页面提取出的链接哪些是符合要求的，只有符合要求的链接才会被跟进。deny 则相反。allow_domains 定义了符合要求的域名，只有此域名的链接才会被跟进生成新的 Request，它相当于域名白名单。deny_domains 则相反，相当于域名黑名单。restrict_xpaths 定义了从当前页面中 XPath 匹配的区域提取链接，其值是 XPath 表达式或 XPath 表达式列表。restrict_css 定义了从当前页面中 CSS 选择器匹配的区域提取链接，其值是 CSS 选择器或 CSS 选择器列表。还有一些其他参数代表了提取链接的标签、是否去重、链接的处理等内容，使用的频率不高。可以参考文档的参数说明：<a href="http://scrapy.readthedocs.io/en/latest/topics/link-extractors.html#module-scrapy.linkextractors.lxmlhtml" target="_blank" rel="noopener">http://scrapy.readthedocs.io/en/latest/topics/link-extractors.html#module-scrapy.linkextractors.lxmlhtml</a>。</p>
                  <ul>
                    <li>callback，即回调函数，和之前定义 Request 的 callback 有相同的意义。每次从 link_extractor 中获取到链接时，该函数将会调用。该回调函数接收一个 response 作为其第一个参数，并返回一个包含 Item 或 Request 对象的列表。注意，避免使用 parse() 作为回调函数。由于 CrawlSpider 使用 parse() 方法来实现其逻辑，如果 parse() 方法覆盖了，CrawlSpider 将会运行失败。</li>
                    <li>cb_kwargs，字典，它包含传递给回调函数的参数。</li>
                    <li>follow，布尔值，即 True 或 False，它指定根据该规则从 response 提取的链接是否需要跟进。如果 callback 参数为 None，follow 默认设置为 True，否则默认为 False。</li>
                    <li>process_links，指定处理函数，从 link_extractor 中获取到链接列表时，该函数将会调用，它主要用于过滤。</li>
                    <li>process_request，同样是指定处理函数，根据该 Rule 提取到每个 Request 时，该函数都会调用，对 Request 进行处理。该函数必须返回 Request 或者 None。</li>
                  </ul>
                  <p>以上内容便是 CrawlSpider 中的核心 Rule 的基本用法。但这些内容可能还不足以完成一个 CrawlSpider 爬虫。下面我们利用 CrawlSpider 实现新闻网站的爬取实例，来更好地理解 Rule 的用法。</p>
                  <h3 id="2-Item-Loader"><a href="#2-Item-Loader" class="headerlink" title="2. Item Loader"></a>2. Item Loader</h3>
                  <p>我们了解了利用 CrawlSpider 的 Rule 来定义页面的爬取逻辑，这是可配置化的一部分内容。但是，Rule 并没有对 Item 的提取方式做规则定义。对于 Item 的提取，我们需要借助另一个模块 Item Loader 来实现。 Item Loader 提供一种便捷的机制来帮助我们方便地提取 Item。它提供的一系列 API 可以分析原始数据对 Item 进行赋值。Item 提供的是保存抓取数据的容器，而 Item Loader 提供的是填充容器的机制。有了它，数据的提取会变得更加规则化。 Item Loader 的 API 如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">class</span> scrapy.loader.<span class="constructor">ItemLoader([<span class="params">item</span>, <span class="params">selector</span>, <span class="params">response</span>,] <span class="operator">**</span><span class="params">kwargs</span>)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>Item Loader 的 API 返回一个新的 Item Loader 来填充给定的 Item。如果没有给出 Item，则使用 default_item_class 中的类自动实例化。另外，它传入 selector 和 response 参数来使用选择器或响应参数实例化。 下面将依次说明 Item Loader 的 API 参数。</p>
                  <ul>
                    <li>item，Item 对象，可以调用 add_xpath()、add_css() 或 add_value() 等方法来填充 Item 对象。</li>
                    <li>selector，Selector 对象，用来提取填充数据的选择器。</li>
                    <li>response，Response 对象，用于使用构造选择器的 Response。</li>
                  </ul>
                  <p>一个比较典型的 Item Loader 实例如下：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy.loader import ItemLoader</span><br><span class="line">from project.items import Product</span><br><span class="line"></span><br><span class="line">def parse(self, response):</span><br><span class="line">    loader = <span class="constructor">ItemLoader(<span class="params">item</span>=Product()</span>, response=response)</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">name</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">class</span>=<span class="string">"product_name"</span>]')</span></span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">name</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">class</span>=<span class="string">"product_title"</span>]')</span></span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">price</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">p</span>[@<span class="params">id</span>=<span class="string">"price"</span>]')</span></span><br><span class="line">    loader.add<span class="constructor">_css('<span class="params">stock</span>', '<span class="params">p</span>#<span class="params">stock</span>]')</span></span><br><span class="line">    loader.add<span class="constructor">_value('<span class="params">last_updated</span>', '<span class="params">today</span>')</span></span><br><span class="line">    return loader.load<span class="constructor">_item()</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先声明一个 Product Item，用该 Item 和 Response 对象实例化 ItemLoader，调用 add_xpath() 方法把来自两个不同位置的数据提取出来，分配给 name 属性，再用 add_xpath()、add_css()、add_value() 等方法对不同属性依次赋值，最后调用 load_item() 方法实现 Item 的解析。这种方式比较规则化，我们可以把一些参数和规则单独提取出来做成配置文件或存到数据库，即可实现可配置化。 另外，Item Loader 每个字段中都包含了一个 Input Processor（输入处理器）和一个 Output Processor（输出处理器）。Input Processor 收到数据时立刻提取数据，Input Processor 的结果被收集起来并且保存在 ItemLoader 内，但是不分配给 Item。收集到所有的数据后，load_item() 方法被调用来填充再生成 Item 对象。在调用时会先调用 Output Processor 来处理之前收集到的数据，然后再存入 Item 中，这样就生成了 Item。 下面将介绍一些内置的 Processor。</p>
                  <h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4>
                  <p>Identity 是最简单的 Processor，不进行任何处理，直接返回原来的数据。</p>
                  <h4 id="TakeFirst"><a href="#TakeFirst" class="headerlink" title="TakeFirst"></a>TakeFirst</h4>
                  <p>TakeFirst 返回列表的第一个非空值，类似 extract_first() 的功能，常用作 Output Processor，如下所示：</p>
                  <figure class="highlight stylus">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy<span class="selector-class">.loader</span><span class="selector-class">.processors</span> import TakeFirst</span><br><span class="line">processor = TakeFirst()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(processor([<span class="string">''</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>经过此 Processor 处理后的结果返回了第一个不为空的值。</p>
                  <h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4>
                  <p>Join 方法相当于字符串的 join() 方法，可以把列表拼合成字符串，字符串默认使用空格分隔，如下所示：</p>
                  <figure class="highlight gradle">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> <span class="keyword">Join</span></span><br><span class="line">processor = <span class="keyword">Join</span>()</span><br><span class="line"><span class="keyword">print</span>(processor([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下所示：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="literal">one</span> <span class="literal">two</span> <span class="literal">three</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>它也可以通过参数更改默认的分隔符，例如改成逗号：</p>
                  <figure class="highlight gradle">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> <span class="keyword">Join</span></span><br><span class="line">processor = <span class="keyword">Join</span>(<span class="string">','</span>)</span><br><span class="line"><span class="keyword">print</span>(processor([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下所示：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="literal">one</span>,<span class="literal">two</span>,<span class="literal">three</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h4>
                  <p>Compose 是用给定的多个函数的组合而构造的 Processor，每个输入值被传递到第一个函数，其输出再传递到第二个函数，依次类推，直到最后一个函数返回整个处理器的输出，如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy.loader.processors import Compose</span><br><span class="line">processor = <span class="constructor">Compose(<span class="params">str</span>.<span class="params">upper</span>, <span class="params">lambda</span> <span class="params">s</span>: <span class="params">s</span>.<span class="params">strip</span>()</span>)</span><br><span class="line">print(processor(' hello world'))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">HELLO WORLD</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们构造了一个 Compose Processor，传入一个开头带有空格的字符串。Compose Processor 的参数有两个：第一个是 str.upper，它可以将字母全部转为大写；第二个是一个匿名函数，它调用 strip() 方法去除头尾空白字符。Compose 会顺次调用两个参数，最后返回结果的字符串全部转化为大写并且去除了开头的空格。</p>
                  <h4 id="MapCompose"><a href="#MapCompose" class="headerlink" title="MapCompose"></a>MapCompose</h4>
                  <p>与 Compose 类似，MapCompose 可以迭代处理一个列表输入值，如下所示：</p>
                  <figure class="highlight stylus">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy<span class="selector-class">.loader</span><span class="selector-class">.processors</span> import MapCompose</span><br><span class="line">processor = MapCompose(str<span class="selector-class">.upper</span>, lambda s: s.strip())</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(processor([<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'Python'</span>])</span></span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下所示：</p>
                  <figure class="highlight scheme">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="symbol">'HELLO</span>', <span class="symbol">'WORLD</span>', <span class="symbol">'PYTHON</span>']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>被处理的内容是一个可迭代对象，MapCompose 会将该对象遍历然后依次处理。</p>
                  <h4 id="SelectJmes"><a href="#SelectJmes" class="headerlink" title="SelectJmes"></a>SelectJmes</h4>
                  <p>SelectJmes 可以查询 JSON，传入 Key，返回查询所得的 Value。不过需要先安装 jmespath 库才可以使用它，命令如下所示：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> jmespath</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>安装好 jmespath 之后，便可以使用这个 Processor 了，如下所示：</p>
                  <figure class="highlight isbl">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="variable">from</span> <span class="variable">scrapy.loader.processors</span> <span class="variable">import</span> <span class="variable">SelectJmes</span></span><br><span class="line"><span class="variable">proc</span> = <span class="function"><span class="title">SelectJmes</span>(<span class="string">'foo'</span>)</span></span><br><span class="line"><span class="variable">processor</span> = <span class="function"><span class="title">SelectJmes</span>(<span class="string">'foo'</span>)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="title">processor</span>(&#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;))</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">bar</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>以上内容便是一些常用的 Processor，在本节的实例中我们会使用 Processor 来进行数据的处理。 接下来，我们用一个实例来了解 Item Loader 的用法。</p>
                  <h3 id="3-本节目标"><a href="#3-本节目标" class="headerlink" title="3. 本节目标"></a>3. 本节目标</h3>
                  <p>我们以中华网科技类新闻为例，来了解 CrawlSpider 和 Item Loader 的用法，再提取其可配置信息实现可配置化。官网链接为：<a href="http://tech.china.com/。我们需要爬取它的科技类新闻内容，链接为：http://tech.china.com/articles/，页面如图" target="_blank" rel="noopener">http://tech.china.com/。我们需要爬取它的科技类新闻内容，链接为：http://tech.china.com/articles/，页面如图</a> 13-19 所示。 我们要抓取新闻列表中的所有分页的新闻详情，包括标题、正文、时间、来源等信息。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034144.png" alt=""> 图 13-19 爬取站点</p>
                  <h3 id="4-新建项目"><a href="#4-新建项目" class="headerlink" title="4. 新建项目"></a>4. 新建项目</h3>
                  <p>首先新建一个 Scrapy 项目，名为 scrapyuniversal，如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject scrapyuniversal</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>创建一个 CrawlSpider，需要先制定一个模板。我们可以先看看有哪些可用模板，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy genspider -l</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下所示：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">Available</span> templates:</span><br><span class="line">  <span class="keyword">basic</span></span><br><span class="line"><span class="keyword"> </span> crawl</span><br><span class="line">  csvfeed</span><br><span class="line">  xmlfeed</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>之前创建 Spider 的时候，我们默认使用了第一个模板 basic。这次要创建 CrawlSpider，就需要使用第二个模板 crawl，创建命令如下所示：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">-t</span> <span class="selector-tag">crawl</span> <span class="selector-tag">china</span> <span class="selector-tag">tech</span><span class="selector-class">.china</span><span class="selector-class">.com</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行之后便会生成一个 CrawlSpider，其内容如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaSpider</span><span class="params">(CrawlSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'china'</span></span><br><span class="line">    allowed_domains = [<span class="string">'tech.china.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://tech.china.com/'</span>]</span><br><span class="line"></span><br><span class="line">    rules = (Rule(LinkExtractor(allow=<span class="string">r'Items/'</span>), callback=<span class="string">'parse_item'</span>, follow=<span class="literal">True</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        i = &#123;&#125;</span><br><span class="line">        <span class="comment">#i['domain_id'] = response.xpath('//input[@id="sid"]/@value').extract()</span></span><br><span class="line">        <span class="comment">#i['name'] = response.xpath('//div[@id="name"]').extract()</span></span><br><span class="line">        <span class="comment">#i['description'] = response.xpath('//div[@id="description"]').extract()</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这次生成的 Spider 内容多了一个 rules 属性的定义。Rule 的第一个参数是 LinkExtractor，就是上文所说的 LxmlLinkExtractor，只是名称不同。同时，默认的回调函数也不再是 parse，而是 parse_item。</p>
                  <h3 id="5-定义-Rule"><a href="#5-定义-Rule" class="headerlink" title="5. 定义 Rule"></a>5. 定义 Rule</h3>
                  <p>要实现新闻的爬取，我们需要做的就是定义好 Rule，然后实现解析函数。下面我们就来一步步实现这个过程。 首先将 start_urls 修改为起始链接，代码如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">start_urls</span> = [<span class="string">'http://tech.china.com/articles/'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>之后，Spider 爬取 start_urls 里面的每一个链接。所以这里第一个爬取的页面就是我们刚才所定义的链接。得到 Response 之后，Spider 就会根据每一个 Rule 来提取这个页面内的超链接，去生成进一步的 Request。接下来，我们就需要定义 Rule 来指定提取哪些链接。 当前页面如图 13-20 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034532.png" alt=""> 图 13-20 页面内容 这是新闻的列表页，下一步自然就是将列表中的每条新闻详情的链接提取出来。这里直接指定这些链接所在区域即可。查看源代码，所有链接都在 ID 为 left_side 的节点内，具体来说是它内部的 class 为 con_item 的节点，如图 13-21 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034527.jpg" alt=""> 图 13-21 列表源码 此处我们可以用 LinkExtractor 的 restrict_xpaths 属性来指定，之后 Spider 就会从这个区域提取所有的超链接并生成 Request。但是，每篇文章的导航中可能还有一些其他的超链接标签，我们只想把需要的新闻链接提取出来。真正的新闻链接路径都是以 article 开头的，我们用一个正则表达式将其匹配出来再赋值给 allow 参数即可。另外，这些链接对应的页面其实就是对应的新闻详情页，而我们需要解析的就是新闻的详情信息，所以此处还需要指定一个回调函数 callback。 到现在我们就可以构造出一个 Rule 了，代码如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="constructor">Rule(LinkExtractor(<span class="params">allow</span>='<span class="params">article</span><span class="operator">/</span>.<span class="operator">*</span>.<span class="params">html</span>', <span class="params">restrict_xpaths</span>='<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"left_side"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">class</span>=<span class="string">"con_item"</span>]')</span>, callback='parse_item')</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来，我们还要让当前页面实现分页功能，所以还需要提取下一页的链接。分析网页源码之后可以发现下一页链接是在 ID 为 pageStyle 的节点内，如图 13-22 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034519.jpg" alt=""> 图 13-22 分页源码 但是，下一页节点和其他分页链接区分度不高，要取出此链接我们可以直接用 XPath 的文本匹配方式，所以这里我们直接用 LinkExtractor 的 restrict_xpaths 属性来指定提取的链接即可。另外，我们不需要像新闻详情页一样去提取此分页链接对应的页面详情信息，也就是不需要生成 Item，所以不需要加 callback 参数。另外这下一页的页面如果请求成功了就需要继续像上述情况一样分析，所以它还需要加一个 follow 参数为 True，代表继续跟进匹配分析。其实，follow 参数也可以不加，因为当 callback 为空的时候，follow 默认为 True。此处 Rule 定义为如下所示：</p>
                  <figure class="highlight lisp">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Rule(<span class="name">LinkExtractor</span>(<span class="name">restrict_xpaths=</span>'//div[@id=<span class="string">"pageStyle"</span>]//a[contains(., <span class="string">"下一页"</span>)]'))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>所以现在 rules 就变成了：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">rules = (<span class="constructor">Rule(LinkExtractor(<span class="params">allow</span>='<span class="params">article</span><span class="operator">/</span>.<span class="operator">*</span>.<span class="params">html</span>', <span class="params">restrict_xpaths</span>='<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"left_side"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">class</span>=<span class="string">"con_item"</span>]')</span>, callback='parse_item'),</span><br><span class="line">    <span class="constructor">Rule(LinkExtractor(<span class="params">restrict_xpaths</span>='<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"pageStyle"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">a</span>[<span class="params">contains</span>(., <span class="string">"下一页"</span>)</span>]'))</span><br><span class="line">)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接着我们运行一下代码，命令如下：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl china</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>现在已经实现页面的翻页和详情页的抓取了，我们仅仅通过定义了两个 Rule 即实现了这样的功能，运行效果如图 13-23 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034515.jpg" alt=""> 图 13-23 运行效果</p>
                  <h3 id="6-解析页面"><a href="#6-解析页面" class="headerlink" title="6. 解析页面"></a>6. 解析页面</h3>
                  <p>接下来我们需要做的就是解析页面内容了，将标题、发布时间、正文、来源提取出来即可。首先定义一个 Item，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Field, Item</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">NewsItem</span>(<span class="symbol">Item</span>):</span><br><span class="line">    <span class="symbol">title</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">url</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">text</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">datetime</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">source</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">website</span> = <span class="symbol">Field</span>()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里的字段分别指新闻标题、链接、正文、发布时间、来源、站点名称，其中站点名称直接赋值为中华网。因为既然是通用爬虫，肯定还有很多爬虫也来爬取同样结构的其他站点的新闻内容，所以需要一个字段来区分一下站点名称。 详情页的预览图如图 13-24 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034510.png" alt=""> 图 13-24 详情页面 如果像之前一样提取内容，就直接调用 response 变量的 xpath()、css() 等方法即可。这里 parse_item() 方法的实现如下所示：</p>
                  <figure class="highlight xquery">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_item(self, response):</span><br><span class="line">    <span class="type">item</span> = NewsItem()</span><br><span class="line">    <span class="type">item</span>[<span class="string">'title'</span>] = response.xpath(<span class="string">'//h1[@id="chan_newsTitle"]/text()'</span>).extract_first()</span><br><span class="line">    <span class="type">item</span>[<span class="string">'url'</span>] = response.url</span><br><span class="line">    <span class="type">item</span>[<span class="string">'text'</span>] = <span class="string">''</span>.join(response.xpath(<span class="string">'//div[@id="chan_newsDetail"]//text()'</span>).extract()).<span class="keyword">strip</span>()</span><br><span class="line">    <span class="type">item</span>[<span class="string">'datetime'</span>] = response.xpath(<span class="string">'//div[@id="chan_newsInfo"]/text()'</span>).re_first(<span class="string">'(d+-d+-d+sd+:d+:d+)'</span>)</span><br><span class="line">    <span class="type">item</span>[<span class="string">'source'</span>] = response.xpath(<span class="string">'//div[@id="chan_newsInfo"]/text()'</span>).re_first(<span class="string">' 来源：(.*)'</span>).<span class="keyword">strip</span>()</span><br><span class="line">    <span class="type">item</span>[<span class="string">'website'</span>] = <span class="string">' 中华网 '</span></span><br><span class="line">    yield <span class="type">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就把每条新闻的信息提取形成了一个 NewsItem 对象。 这时实际上我们就已经完成了 Item 的提取。再运行一下 Spider，如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl china</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出内容如图 13-25 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034503.jpg" alt=""> 图 13-25 输出内容 现在我们就可以成功将每条新闻的信息提取出来。 不过我们发现这种提取方式非常不规整。下面我们再用 Item Loader，通过 add_xpath()、add_css()、add_value() 等方式实现配置化提取。我们可以改写 parse_item()，如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse<span class="constructor">_item(<span class="params">self</span>, <span class="params">response</span>)</span>:</span><br><span class="line">    loader = <span class="constructor">ChinaLoader(<span class="params">item</span>=NewsItem()</span>, response=response)</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">title</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">h1</span>[@<span class="params">id</span>=<span class="string">"chan_newsTitle"</span>]<span class="operator">/</span><span class="params">text</span>()</span>')</span><br><span class="line">    loader.add<span class="constructor">_value('<span class="params">url</span>', <span class="params">response</span>.<span class="params">url</span>)</span></span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">text</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsDetail"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">text</span>()</span>')</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">datetime</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsInfo"</span>]<span class="operator">/</span><span class="params">text</span>()</span>', re='(d+-d+-d+sd+:d+:d+)')</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">source</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsInfo"</span>]<span class="operator">/</span><span class="params">text</span>()</span>', re=' 来源：(.*)')</span><br><span class="line">    loader.add<span class="constructor">_value('<span class="params">website</span>', ' 中华网 ')</span></span><br><span class="line">    yield loader.load<span class="constructor">_item()</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了一个 ItemLoader 的子类，名为 ChinaLoader，其实现如下所示：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="title">from</span> scrapy.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="title">from</span> scrapy.loader.processors <span class="keyword">import</span> TakeFirst, Join, Compose</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">NewsLoader</span>(<span class="type">ItemLoader</span>):</span></span><br><span class="line"><span class="class">    default_output_processor = <span class="type">TakeFirst</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ChinaLoader</span>(<span class="type">NewsLoader</span>):</span></span><br><span class="line"><span class="class">    text_out = <span class="type">Compose</span>(<span class="type">Join</span>(), lambda s: s.strip())</span></span><br><span class="line"><span class="class">    source_out = <span class="type">Compose</span>(<span class="type">Join</span>(), lambda s: s.strip())</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>ChinaLoader 继承了 NewsLoader 类，其内定义了一个通用的 Out Processor 为 TakeFirst，这相当于之前所定义的 extract_first() 方法的功能。我们在 ChinaLoader 中定义了 text_out 和 source_out 字段。这里使用了一个 Compose Processor，它有两个参数：第一个参数 Join 也是一个 Processor，它可以把列表拼合成一个字符串；第二个参数是一个匿名函数，可以将字符串的头尾空白字符去掉。经过这一系列处理之后，我们就将列表形式的提取结果转化为去除头尾空白字符的字符串。 代码重新运行，提取效果是完全一样的。 至此，我们已经实现了爬虫的半通用化配置。</p>
                  <h3 id="7-通用配置抽取"><a href="#7-通用配置抽取" class="headerlink" title="7. 通用配置抽取"></a>7. 通用配置抽取</h3>
                  <p>为什么现在只做到了半通用化？如果我们需要扩展其他站点，仍然需要创建一个新的 CrawlSpider，定义这个站点的 Rule，单独实现 parse_item() 方法。还有很多代码是重复的，如 CrawlSpider 的变量、方法名几乎都是一样的。那么我们可不可以把多个类似的几个爬虫的代码共用，把完全不相同的地方抽离出来，做成可配置文件呢？ 当然可以。那我们可以抽离出哪些部分？所有的变量都可以抽取，如 name、allowed_domains、start_urls、rules 等。这些变量在 CrawlSpider 初始化的时候赋值即可。我们就可以新建一个通用的 Spider 来实现这个功能，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy genspider -t crawl universal universal</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个全新的 Spider 名为 universal。接下来，我们将刚才所写的 Spider 内的属性抽离出来配置成一个 JSON，命名为 china.json，放到 configs 文件夹内，和 spiders 文件夹并列，代码如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"spider"</span>: <span class="string">"universal"</span>,</span><br><span class="line">  <span class="attr">"website"</span>: <span class="string">"中华网科技"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"新闻"</span>,</span><br><span class="line">  <span class="attr">"index"</span>: <span class="string">"http://tech.china.com/"</span>,</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;<span class="attr">"USER_AGENT"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"start_urls"</span>: [<span class="string">"http://tech.china.com/articles/"</span>],</span><br><span class="line">  <span class="attr">"allowed_domains"</span>: [<span class="string">"tech.china.com"</span>],</span><br><span class="line">  <span class="attr">"rules"</span>: <span class="string">"china"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一个字段 spider 即 Spider 的名称，在这里是 universal。后面是站点的描述，比如站点名称、类型、首页等。随后的 settings 是该 Spider 特有的 settings 配置，如果要覆盖全局项目，settings.py 内的配置可以单独为其配置。随后是 Spider 的一些属性，如 start_urls、allowed_domains、rules 等。rules 也可以单独定义成一个 rules.py 文件，做成配置文件，实现 Rule 的分离，如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import Rule</span><br><span class="line"></span><br><span class="line">rules = &#123;</span><br><span class="line">    'china': (<span class="constructor">Rule(LinkExtractor(<span class="params">allow</span>='<span class="params">article</span><span class="operator">/</span>.<span class="operator">*</span>.<span class="params">html</span>', <span class="params">restrict_xpaths</span>='<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"left_side"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">class</span>=<span class="string">"con_item"</span>]')</span>,</span><br><span class="line">             callback='parse_item'),</span><br><span class="line">        <span class="constructor">Rule(LinkExtractor(<span class="params">restrict_xpaths</span>='<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"pageStyle"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">a</span>[<span class="params">contains</span>(., <span class="string">"下一页"</span>)</span>]'))</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们将基本的配置抽取出来。如果要启动爬虫，只需要从该配置文件中读取然后动态加载到 Spider 中即可。所以我们需要定义一个读取该 JSON 文件的方法，如下所示：</p>
                  <figure class="highlight xl">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from os.<span class="built_in">path</span> <span class="keyword">import</span> realpath, dirname</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">def get_config(<span class="keyword">name</span>):</span><br><span class="line">    <span class="built_in">path</span> = dirname(realpath(__file__)) + <span class="string">'/configs/'</span> + <span class="keyword">name</span> + <span class="string">'.json'</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="built_in">path</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        return json.loads(f.read())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>定义了 get_config() 方法之后，我们只需要向其传入 JSON 配置文件的名称即可获取此 JSON 配置信息。随后我们定义入口文件 run.py，把它放在项目根目录下，它的作用是启动 Spider，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import sys</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project import get_project_settings</span><br><span class="line"><span class="keyword">from</span> scrapyuniversal.spiders.universal import UniversalSpider</span><br><span class="line"><span class="keyword">from</span> scrapyuniversal.utils import get_config</span><br><span class="line"><span class="keyword">from</span> scrapy.crawler import CrawlerProcess</span><br><span class="line"></span><br><span class="line">def <span class="builtin-name">run</span>():</span><br><span class="line">    name = sys.argv[1]</span><br><span class="line">    custom_settings = get_config(name)</span><br><span class="line">    # 爬取使用的 Spider 名称</span><br><span class="line">    spider = custom_settings.<span class="builtin-name">get</span>(<span class="string">'spider'</span>, <span class="string">'universal'</span>)</span><br><span class="line">    project_settings = get_project_settings()</span><br><span class="line">   <span class="built_in"> settings </span>= dict(project_settings.copy())</span><br><span class="line">    # 合并配置</span><br><span class="line">    settings.update(custom_settings.<span class="builtin-name">get</span>(<span class="string">'settings'</span>))</span><br><span class="line">    process = CrawlerProcess(settings)</span><br><span class="line">    # 启动爬虫</span><br><span class="line">    process.crawl(spider, **&#123;<span class="string">'name'</span>: name&#125;)</span><br><span class="line">    process.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="builtin-name">run</span>()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行入口为 run()。首先获取命令行的参数并赋值为 name，name 就是 JSON 文件的名称，其实就是要爬取的目标网站的名称。我们首先利用 get_config() 方法，传入该名称读取刚才定义的配置文件。获取爬取使用的 spider 的名称、配置文件中的 settings 配置，然后将获取到的 settings 配置和项目全局的 settings 配置做了合并。新建一个 CrawlerProcess，传入爬取使用的配置。调用 crawl() 和 start() 方法即可启动爬取。 在 universal 中，我们新建一个<strong>init</strong>() 方法，进行初始化配置，实现如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy.linkextractors import LinkExtractor</span><br><span class="line"><span class="keyword">from</span> scrapy.spiders import CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapyuniversal.utils import get_config</span><br><span class="line"><span class="keyword">from</span> scrapyuniversal.rules import rules</span><br><span class="line"></span><br><span class="line">class UniversalSpider(CrawlSpider):</span><br><span class="line">    name = <span class="string">'universal'</span></span><br><span class="line">    def __init__(self, name, <span class="number">*a</span>rgs, **kwargs):</span><br><span class="line">       <span class="built_in"> config </span>= get_config(name)</span><br><span class="line">        self.config = config</span><br><span class="line">        self.rules = rules.<span class="builtin-name">get</span>(config.<span class="builtin-name">get</span>(<span class="string">'rules'</span>))</span><br><span class="line">        self.start_urls = config.<span class="builtin-name">get</span>(<span class="string">'start_urls'</span>)</span><br><span class="line">        self.allowed_domains = config.<span class="builtin-name">get</span>(<span class="string">'allowed_domains'</span>)</span><br><span class="line">        super(UniversalSpider, self).__init__(<span class="number">*a</span>rgs, **kwargs)</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        i = &#123;&#125;</span><br><span class="line">        return i</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在 <strong>init</strong>() 方法中，start_urls、allowed_domains、rules 等属性被赋值。其中，rules 属性另外读取了 rules.py 的配置，这样就成功实现爬虫的基础配置。 接下来，执行如下命令运行爬虫：</p>
                  <figure class="highlight dockerfile">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 <span class="keyword">run</span>.<span class="bash">py china</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>程序会首先读取 JSON 配置文件，将配置中的一些属性赋值给 Spider，然后启动爬取。运行效果完全相同，运行结果如图 13-26 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034600.jpg" alt=""> 图 13-26 运行结果 现在我们已经对 Spider 的基础属性实现了可配置化。剩下的解析部分同样需要实现可配置化，原来的解析函数如下所示：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse<span class="constructor">_item(<span class="params">self</span>, <span class="params">response</span>)</span>:</span><br><span class="line">    loader = <span class="constructor">ChinaLoader(<span class="params">item</span>=NewsItem()</span>, response=response)</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">title</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">h1</span>[@<span class="params">id</span>=<span class="string">"chan_newsTitle"</span>]<span class="operator">/</span><span class="params">text</span>()</span>')</span><br><span class="line">    loader.add<span class="constructor">_value('<span class="params">url</span>', <span class="params">response</span>.<span class="params">url</span>)</span></span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">text</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsDetail"</span>]<span class="operator">/</span><span class="operator">/</span><span class="params">text</span>()</span>')</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">datetime</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsInfo"</span>]<span class="operator">/</span><span class="params">text</span>()</span>', re='(d+-d+-d+sd+:d+:d+)')</span><br><span class="line">    loader.add<span class="constructor">_xpath('<span class="params">source</span>', '<span class="operator">/</span><span class="operator">/</span><span class="params">div</span>[@<span class="params">id</span>=<span class="string">"chan_newsInfo"</span>]<span class="operator">/</span><span class="params">text</span>()</span>', re=' 来源：(.*)')</span><br><span class="line">    loader.add<span class="constructor">_value('<span class="params">website</span>', ' 中华网 ')</span></span><br><span class="line">    yield loader.load<span class="constructor">_item()</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们需要将这些配置也抽离出来。这里的变量主要有 Item Loader 类的选用、Item 类的选用、Item Loader 方法参数的定义，我们可以在 JSON 文件中添加如下 item 的配置：</p>
                  <figure class="highlight prolog">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">"item"</span>: &#123;</span><br><span class="line">  <span class="string">"class"</span>: <span class="string">"NewsItem"</span>,</span><br><span class="line">  <span class="string">"loader"</span>: <span class="string">"ChinaLoader"</span>,</span><br><span class="line">  <span class="string">"attrs"</span>: &#123;</span><br><span class="line">    <span class="string">"title"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"xpath"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"//h1[@id='chan_newsTitle']/text()"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"url"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"attr"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"url"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"text"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"xpath"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"//div[@id='chan_newsDetail']//text()"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"datetime"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"xpath"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"//div[@id='chan_newsInfo']/text()"</span>],</span><br><span class="line">        <span class="string">"re"</span>: <span class="string">"(\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+)"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"source"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"xpath"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"//div[@id='chan_newsInfo']/text()"</span>],</span><br><span class="line">        <span class="string">"re"</span>: <span class="string">"来源：(.*)"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"website"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"method"</span>: <span class="string">"value"</span>,</span><br><span class="line">        <span class="string">"args"</span>: [<span class="string">"中华网"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了 class 和 loader 属性，它们分别代表 Item 和 Item Loader 所使用的类。定义了 attrs 属性来定义每个字段的提取规则，例如，title 定义的每一项都包含一个 method 属性，它代表使用的提取方法，如 xpath 即代表调用 Item Loader 的 add_xpath() 方法。args 即参数，就是 add_xpath() 的第二个参数，即 XPath 表达式。针对 datetime 字段，我们还用了一次正则提取，所以这里还可以定义一个 re 参数来传递提取时所使用的正则表达式。 我们还要将这些配置之后动态加载到 parse_item() 方法里。最后，最重要的就是实现 parse_item() 方法，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse_item(self, response):</span><br><span class="line">   item = self.config.<span class="builtin-name">get</span>(<span class="string">'item'</span>)</span><br><span class="line">   <span class="keyword">if</span> item:</span><br><span class="line">       cls = eval(item.<span class="builtin-name">get</span>(<span class="string">'class'</span>))()</span><br><span class="line">       loader = eval(item.<span class="builtin-name">get</span>(<span class="string">'loader'</span>))(cls, <span class="attribute">response</span>=response)</span><br><span class="line">       # 动态获取属性配置</span><br><span class="line">       <span class="keyword">for</span> key, value <span class="keyword">in</span> item.<span class="builtin-name">get</span>(<span class="string">'attrs'</span>).items():</span><br><span class="line">           <span class="keyword">for</span> extractor <span class="keyword">in</span> value:</span><br><span class="line">               <span class="keyword">if</span> extractor.<span class="builtin-name">get</span>(<span class="string">'method'</span>) == <span class="string">'xpath'</span>:</span><br><span class="line">                   loader.add_xpath(key, <span class="number">*e</span>xtractor.<span class="builtin-name">get</span>(<span class="string">'args'</span>), **&#123;<span class="string">'re'</span>: extractor.<span class="builtin-name">get</span>(<span class="string">'re'</span>)&#125;)</span><br><span class="line">               <span class="keyword">if</span> extractor.<span class="builtin-name">get</span>(<span class="string">'method'</span>) == <span class="string">'css'</span>:</span><br><span class="line">                   loader.add_css(key, <span class="number">*e</span>xtractor.<span class="builtin-name">get</span>(<span class="string">'args'</span>), **&#123;<span class="string">'re'</span>: extractor.<span class="builtin-name">get</span>(<span class="string">'re'</span>)&#125;)</span><br><span class="line">               <span class="keyword">if</span> extractor.<span class="builtin-name">get</span>(<span class="string">'method'</span>) == <span class="string">'value'</span>:</span><br><span class="line">                   loader.add_value(key, <span class="number">*e</span>xtractor.<span class="builtin-name">get</span>(<span class="string">'args'</span>), **&#123;<span class="string">'re'</span>: extractor.<span class="builtin-name">get</span>(<span class="string">'re'</span>)&#125;)</span><br><span class="line">               <span class="keyword">if</span> extractor.<span class="builtin-name">get</span>(<span class="string">'method'</span>) == <span class="string">'attr'</span>:</span><br><span class="line">                   loader.add_value(key, getattr(response, <span class="number">*e</span>xtractor.<span class="builtin-name">get</span>(<span class="string">'args'</span>)))</span><br><span class="line">       yield loader.load_item()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先获取 Item 的配置信息，然后获取 class 的配置，将其初始化，初始化 Item Loader，遍历 Item 的各个属性依次进行提取。判断 method 字段，调用对应的处理方法进行处理。如 method 为 css，就调用 Item Loader 的 add_css() 方法进行提取。所有配置动态加载完毕之后，调用 load_item() 方法将 Item 提取出来。 重新运行程序，结果如图 13-27 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034606.jpg" alt=""> 图 13-27 运行结果 运行结果是完全相同的。 我们再回过头看一下 start_urls 的配置。这里 start_urls 只可以配置具体的链接。如果这些链接有 100 个、1000 个，我们总不能将所有的链接全部列出来吧？在某些情况下，start_urls 也需要动态配置。我们将 start_urls 分成两种，一种是直接配置 URL 列表，一种是调用方法生成，它们分别定义为 static 和 dynamic 类型。 本例中的 start_urls 很明显是 static 类型的，所以 start_urls 配置改写如下所示： ```json”start_urls”: {“type”:”static”,”value”: [“<a href="http://tech.china.com/articles/" target="_blank" rel="noopener">http://tech.china.com/articles/</a>“] }</p>
                  <figure class="highlight autohotkey">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">如果 start_urls 是动态生成的，我们可以调用方法传参数，如下所示：</span><br><span class="line">```json</span><br><span class="line"><span class="string">"start_urls"</span>: &#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"dynamic"</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"china"</span>,</span><br><span class="line">  <span class="string">"args"</span>: [<span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 start_urls 定义为 dynamic 类型，指定方法为 urls_china()，然后传入参数 5 和 10，来生成第 5 到 10 页的链接。这样我们只需要实现该方法即可，统一新建一个 urls.py 文件，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def china(start, end):</span><br><span class="line">    <span class="keyword">for</span><span class="built_in"> page </span><span class="keyword">in</span> range(start, end + 1):</span><br><span class="line">        yield <span class="string">'http://tech.china.com/articles/index_'</span> + str(page) + <span class="string">'.html'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其他站点可以自行配置。如某些链接需要用到时间戳，加密参数等，均可通过自定义方法实现。 接下来在 Spider 的 <strong>init</strong>() 方法中，start_urls 的配置改写如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapyuniversal import urls</span><br><span class="line"></span><br><span class="line">start_urls = config.<span class="builtin-name">get</span>(<span class="string">'start_urls'</span>)</span><br><span class="line"><span class="keyword">if</span> start_urls:</span><br><span class="line">    <span class="keyword">if</span> start_urls.<span class="builtin-name">get</span>(<span class="string">'type'</span>) == <span class="string">'static'</span>:</span><br><span class="line">        self.start_urls = start_urls.<span class="builtin-name">get</span>(<span class="string">'value'</span>)</span><br><span class="line">    elif start_urls.<span class="builtin-name">get</span>(<span class="string">'type'</span>) == <span class="string">'dynamic'</span>:</span><br><span class="line">        self.start_urls = list(eval(<span class="string">'urls.'</span> + start_urls.<span class="builtin-name">get</span>(<span class="string">'method'</span>))(*start_urls.<span class="builtin-name">get</span>(<span class="string">'args'</span>, [])))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里通过判定 start_urls 的类型分别进行不同的处理，这样我们就可以实现 start_urls 的配置了。 至此，Spider 的设置、起始链接、属性、提取方法都已经实现了全部的可配置化。 综上所述，整个项目的配置包括如下内容。</p>
                  <ul>
                    <li>spider，指定所使用的 Spider 的名称。</li>
                    <li>settings，可以专门为 Spider 定制配置信息，会覆盖项目级别的配置。</li>
                    <li>start_urls，指定爬虫爬取的起始链接。</li>
                    <li>allowed_domains，允许爬取的站点。</li>
                    <li>rules，站点的爬取规则。</li>
                    <li>item，数据的提取规则。</li>
                  </ul>
                  <p>我们实现了 Scrapy 的通用爬虫，每个站点只需要修改 JSON 文件即可实现自由配置。</p>
                  <h3 id="7-本节代码"><a href="#7-本节代码" class="headerlink" title="7. 本节代码"></a>7. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/ScrapyUniversal" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyUniversal</a>。</p>
                  <h3 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h3>
                  <p>本节介绍了 Scrapy 通用爬虫的实现。我们将所有配置抽离出来，每增加一个爬虫，就只需要增加一个 JSON 文件配置。之后我们只需要维护这些配置文件即可。如果要更加方便的管理，可以将规则存入数据库，再对接可视化管理页面即可。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-06 09:30:05" itemprop="dateCreated datePublished" datetime="2019-12-06T09:30:05+08:00">2019-12-06</time>
                </span>
                <span id="/8413.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.10–Scrapy 通用爬虫" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>18k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>16 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8410.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8410.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.9–Scrapy 对接 Splash</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-9-Scrapy-对接-Splash"><a href="#13-9-Scrapy-对接-Splash" class="headerlink" title="13.9 Scrapy 对接 Splash"></a>13.9 Scrapy 对接 Splash</h1>
                  <p>在上一节我们实现了 Scrapy 对接 Selenium 抓取淘宝商品的过程，这是一种抓取 JavaScript 动态渲染页面的方式。除了 Selenium，Splash 也可以实现同样的功能。本节我们来了解 Scrapy 对接 Splash 来进行页面抓取的方式。</p>
                  <h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3>
                  <p>请确保 Splash 已经正确安装并正常运行，同时安装好 Scrapy-Splash 库，如果没有安装可以参考第 1 章的安装说明。</p>
                  <h3 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2. 新建项目"></a>2. 新建项目</h3>
                  <p>首先新建一个项目，名为 scrapysplashtest，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject scrapysplashtest</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>新建一个 Spider，命令如下所示：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">taobao</span> <span class="selector-tag">www</span><span class="selector-class">.taobao</span><span class="selector-class">.com</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3. 添加配置"></a>3. 添加配置</h3>
                  <p>可以参考 Scrapy-Splash 的配置说明进行一步步的配置，链接如下：<a href="https://github.com/scrapy-plugins/scrapy-splash#configuration" target="_blank" rel="noopener">https://github.com/scrapy-plugins/scrapy-splash#configuration</a>。 修改 settings.py，配置 SPLASH_URL。在这里我们的 Splash 是在本地运行的，所以可以直接配置本地的地址：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SPLASH_URL</span> = <span class="string">'http://localhost:8050'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果 Splash 是在远程服务器运行的，那此处就应该配置为远程的地址。例如运行在 IP 为 120.27.34.25 的服务器上，则此处应该配置为：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">SPLASH_URL</span> = <span class="string">'http://120.27.34.25:8050'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>还需要配置几个 Middleware，代码如下所示：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">DOWNLOADER_MIDDLEWARES</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'scrapy_splash.SplashCookiesMiddleware':</span> <span class="number">723</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy_splash.SplashMiddleware':</span> <span class="number">725</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware':</span> <span class="number">810</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">SPIDER_MIDDLEWARES</span> <span class="string">=</span> <span class="string">&#123;'scrapy_splash.SplashDeduplicateArgsMiddleware':</span> <span class="number">100</span><span class="string">,&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里配置了三个 Downloader Middleware 和一个 Spider Middleware，这是 Scrapy-Splash 的核心部分。我们不再需要像对接 Selenium 那样实现一个 Downloader Middleware，Scrapy-Splash 库都为我们准备好了，直接配置即可。 还需要配置一个去重的类 DUPEFILTER_CLASS，代码如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">DUPEFILTER_CLASS</span> = <span class="string">'scrapy_splash.SplashAwareDupeFilter'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>最后配置一个 Cache 存储 HTTPCACHE_STORAGE，代码如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">HTTPCACHE_STORAGE</span> = <span class="string">'scrapy_splash.SplashAwareFSCacheStorage'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="4-新建请求"><a href="#4-新建请求" class="headerlink" title="4. 新建请求"></a>4. 新建请求</h3>
                  <p>配置完成之后，我们就可以利用 Splash 来抓取页面了。我们可以直接生成一个 SplashRequest 对象并传递相应的参数，Scrapy 会将此请求转发给 Splash，Splash 对页面进行渲染加载，然后再将渲染结果传递回来。此时 Response 的内容就是渲染完成的页面结果了，最后交给 Spider 解析即可。 我们来看一个示例，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">yield SplashRequest(url, self.parse_result,</span><br><span class="line">    args=&#123;</span><br><span class="line">        # optional; parameters passed <span class="keyword">to</span> Splash HTTP API</span><br><span class="line">        <span class="string">'wait'</span>: 0.5,</span><br><span class="line">        # <span class="string">'url'</span> is prefilled <span class="keyword">from</span> request url</span><br><span class="line">        # <span class="string">'http_method'</span> is <span class="builtin-name">set</span> <span class="keyword">to</span> <span class="string">'POST'</span> <span class="keyword">for</span> POST requests</span><br><span class="line">        # <span class="string">'body'</span> is <span class="builtin-name">set</span> <span class="keyword">to</span> request body <span class="keyword">for</span> POST requests</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">endpoint</span>=<span class="string">'render.json'</span>, # optional;<span class="built_in"> default </span>is render.html</span><br><span class="line">    <span class="attribute">splash_url</span>=<span class="string">'&lt;url&gt;'</span>,     # optional; overrides SPLASH_URL</span><br><span class="line">)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里构造了一个 SplashRequest 对象，前两个参数依然是请求的 URL 和回调函数，另外还可以通过 args 传递一些渲染参数，例如等待时间 wait 等，还可以根据 endpoint 参数指定渲染接口，另外还有更多的参数可以参考文档的说明：<a href="https://github.com/scrapy-plugins/scrapy-splash#requests" target="_blank" rel="noopener">https://github.com/scrapy-plugins/scrapy-splash#requests</a>。 另外我们也可以生成 Request 对象，关于 Splash 的配置通过 meta 属性配置即可，代码如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">yield scrapy.Request(url, self.parse_result, meta=&#123;</span><br><span class="line">    <span class="string">'splash'</span>: &#123;</span><br><span class="line">        <span class="string">'args'</span>: &#123;</span><br><span class="line">            # <span class="builtin-name">set</span> rendering arguments here</span><br><span class="line">            <span class="string">'html'</span>: 1,</span><br><span class="line">            <span class="string">'png'</span>: 1,</span><br><span class="line">            # <span class="string">'url'</span> is prefilled <span class="keyword">from</span> request url</span><br><span class="line">            # <span class="string">'http_method'</span> is <span class="builtin-name">set</span> <span class="keyword">to</span> <span class="string">'POST'</span> <span class="keyword">for</span> POST requests</span><br><span class="line">            # <span class="string">'body'</span> is <span class="builtin-name">set</span> <span class="keyword">to</span> request body <span class="keyword">for</span> POST requests</span><br><span class="line">        &#125;,</span><br><span class="line">        # optional parameters</span><br><span class="line">        <span class="string">'endpoint'</span>: <span class="string">'render.json'</span>,  # optional;<span class="built_in"> default </span>is render.json</span><br><span class="line">        <span class="string">'splash_url'</span>: <span class="string">'&lt;url&gt;'</span>,      # optional; overrides SPLASH_URL</span><br><span class="line">        <span class="string">'slot_policy'</span>: scrapy_splash.SlotPolicy.PER_DOMAIN,</span><br><span class="line">        <span class="string">'splash_headers'</span>: &#123;&#125;,       # optional; a dict with headers sent <span class="keyword">to</span> Splash</span><br><span class="line">        <span class="string">'dont_process_response'</span>: <span class="literal">True</span>, # optional,<span class="built_in"> default </span>is <span class="literal">False</span></span><br><span class="line">        <span class="string">'dont_send_headers'</span>: <span class="literal">True</span>,  # optional,<span class="built_in"> default </span>is <span class="literal">False</span></span><br><span class="line">        <span class="string">'magic_response'</span>: <span class="literal">False</span>,    # optional,<span class="built_in"> default </span>is <span class="literal">True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>SplashRequest 对象通过 args 来配置和 Request 对象通过 meta 来配置，两种方式达到的效果是相同的。 本节我们要做的抓取是淘宝商品信息，涉及页面加载等待、模拟点击翻页等操作。我们可以首先定义一个 Lua 脚本，来实现页面加载、模拟点击翻页的功能，代码如下所示：</p>
                  <figure class="highlight irpf90">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">function</span></span> main(splash, args)</span><br><span class="line">  args = &#123;</span><br><span class="line">    url=<span class="string">"https://s.taobao.com/search?q=iPad"</span>,</span><br><span class="line">    <span class="keyword">wait</span>=<span class="number">5</span>,</span><br><span class="line">    page=<span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  splash.images_enabled = false</span><br><span class="line">  <span class="keyword">assert</span>(splash:go(args.url))</span><br><span class="line">  <span class="keyword">assert</span>(splash:<span class="keyword">wait</span>(args.<span class="keyword">wait</span>))</span><br><span class="line">  js = string.<span class="keyword">format</span>(<span class="string">"document.querySelector('#mainsrp-pager div.form&gt; input').value=% d;document.querySelector('#mainsrp-pager div.form&gt; span.btn.J_Submit').click()"</span>, args.page)</span><br><span class="line">  splash:evaljs(js)</span><br><span class="line">  <span class="keyword">assert</span>(splash:<span class="keyword">wait</span>(args.<span class="keyword">wait</span>))</span><br><span class="line">  <span class="keyword">return</span> splash:png()</span><br><span class="line"><span class="keyword">end</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们定义了三个参数：请求的链接 url、等待时间 wait、分页页码 page。然后禁用图片加载，请求淘宝的商品列表页面，通过 evaljs() 方法调用 JavaScript 代码，实现页码填充和翻页点击，最后返回页面截图。我们将脚本放到 Splash 中运行，正常获取到页面截图，如图 13-15 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034117.jpg" alt=""> 图 13-15 页面截图 翻页操作也成功实现，如图 13-16 所示即为当前页码，和我们传入的页码 page 参数是相同的。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034121.jpg" alt=""> 图 13-16 翻页结果 我们只需要在 Spider 里用 SplashRequest 对接 Lua 脚本就好了，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy import Spider</span><br><span class="line"><span class="keyword">from</span> urllib.parse import quote</span><br><span class="line"><span class="keyword">from</span> scrapysplashtest.items import ProductItem</span><br><span class="line"><span class="keyword">from</span> scrapy_splash import SplashRequest</span><br><span class="line"></span><br><span class="line">script = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">function main(splash, args)</span></span><br><span class="line"><span class="string">  splash.images_enabled = false</span></span><br><span class="line"><span class="string">  assert(splash:go(args.url))</span></span><br><span class="line"><span class="string">  assert(splash:wait(args.wait))</span></span><br><span class="line"><span class="string">  js = string.format("</span>document.querySelector(<span class="string">'#mainsrp-pager div.form&gt; input'</span>).<span class="attribute">value</span>=% d;document.querySelector(<span class="string">'#mainsrp-pager div.form&gt; span.btn.J_Submit'</span>).click()<span class="string">", args.page)</span></span><br><span class="line"><span class="string">  splash:evaljs(js)</span></span><br><span class="line"><span class="string">  assert(splash:wait(args.wait))</span></span><br><span class="line"><span class="string">  return splash:html()</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">class TaobaoSpider(Spider):</span><br><span class="line">    name = <span class="string">'taobao'</span></span><br><span class="line">    allowed_domains = [<span class="string">'www.taobao.com'</span>]</span><br><span class="line">    base_url = <span class="string">'https://s.taobao.com/search?q='</span></span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        <span class="keyword">for</span> keyword <span class="keyword">in</span> self.settings.<span class="builtin-name">get</span>(<span class="string">'KEYWORDS'</span>):</span><br><span class="line">            <span class="keyword">for</span><span class="built_in"> page </span><span class="keyword">in</span> range(1, self.settings.<span class="builtin-name">get</span>(<span class="string">'MAX_PAGE'</span>) + 1):</span><br><span class="line">                url = self.base_url + quote(keyword)</span><br><span class="line">                yield SplashRequest(url, <span class="attribute">callback</span>=self.parse, <span class="attribute">endpoint</span>=<span class="string">'execute'</span>, args=&#123;<span class="string">'lua_source'</span>: script, <span class="string">'page'</span>: page, <span class="string">'wait'</span>: 7&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们把 Lua 脚本定义成长字符串，通过 SplashRequest 的 args 来传递参数，接口修改为 execute。另外，args 参数里还有一个 lua_source 字段用于指定 Lua 脚本内容。这样我们就成功构造了一个 SplashRequest，对接 Splash 的工作就完成了。 其他的配置不需要更改，Item、Item Pipeline 等设置与上节对接 Selenium 的方式相同，parse() 回调函数也是完全一致的。</p>
                  <h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h3>
                  <p>接下来，我们通过如下命令运行爬虫：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl taobao</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如图 13-17 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034129.jpg" alt=""> 图 13-17 运行结果 由于 Splash 和 Scrapy 都支持异步处理，我们可以看到同时会有多个抓取成功的结果。在 Selenium 的对接过程中，每个页面渲染下载是在 Downloader Middleware 里完成的，所以整个过程是阻塞式的。Scrapy 会等待这个过程完成后再继续处理和调度其他请求，这影响了爬取效率。因此使用 Splash 的爬取效率比 Selenium 高很多。 最后我们再看看 MongoDB 的结果，如图 13-18 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034134.jpg" alt=""> 图 13-18 存储结果 结果同样正常保存到了 MongoDB 中。</p>
                  <h3 id="6-本节代码"><a href="#6-本节代码" class="headerlink" title="6. 本节代码"></a>6. 本节代码</h3>
                  <p>本节代码地址：<a href="https://github.com/Python3WebSpider/ScrapySplashTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapySplashTest</a>。</p>
                  <h3 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h3>
                  <p>在 Scrapy 中，建议使用 Splash 处理 JavaScript 动态渲染的页面。这样不会破坏 Scrapy 中的异步处理过程，会大大提高爬取效率。而且 Splash 的安装和配置比较简单，通过 API 调用的方式实现了模块分离，大规模爬取的部署也更加方便。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-06 09:27:03" itemprop="dateCreated datePublished" datetime="2019-12-06T09:27:03+08:00">2019-12-06</time>
                </span>
                <span id="/8410.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.9–Scrapy 对接 Splash" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>5.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>5 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8397.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8397.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.8–Scrapy 对接 Selenium</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-8-Scrapy-对接-Selenium"><a href="#13-8-Scrapy-对接-Selenium" class="headerlink" title="13.8 Scrapy 对接 Selenium"></a>13.8 Scrapy 对接 Selenium</h1>
                  <p>Scrapy 抓取页面的方式和 requests 库类似，都是直接模拟 HTTP 请求，而 Scrapy 也不能抓取 JavaScript 动态渲染的页面。在前文中抓取 JavaScript 渲染的页面有两种方式。一种是分析 Ajax 请求，找到其对应的接口抓取，Scrapy 同样可以用此种方式抓取。另一种是直接用 Selenium 或 Splash 模拟浏览器进行抓取，我们不需要关心页面后台发生的请求，也不需要分析渲染过程，只需要关心页面最终结果即可，可见即可爬。那么，如果 Scrapy 可以对接 Selenium，那 Scrapy 就可以处理任何网站的抓取了。</p>
                  <h3 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h3>
                  <p>本节我们来看看 Scrapy 框架如何对接 Selenium，以 PhantomJS 进行演示。我们依然抓取淘宝商品信息，抓取逻辑和前文中用 Selenium 抓取淘宝商品完全相同。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>请确保 PhantomJS 和 MongoDB 已经安装好并可以正常运行，安装好 Scrapy、Selenium、PyMongo 库，安装方式可以参考第 1 章的安装说明。</p>
                  <h3 id="3-新建项目"><a href="#3-新建项目" class="headerlink" title="3. 新建项目"></a>3. 新建项目</h3>
                  <p>首先新建项目，名为 scrapyseleniumtest，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject scrapyseleniumtest</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>新建一个 Spider，命令如下所示：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">taobao</span> <span class="selector-tag">www</span><span class="selector-class">.taobao</span><span class="selector-class">.com</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>修改 ROBOTSTXT_OBEY 为 False，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">ROBOTSTXT_OBEY</span> = <span class="literal">False</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="4-定义-Item"><a href="#4-定义-Item" class="headerlink" title="4. 定义 Item"></a>4. 定义 Item</h3>
                  <p>首先定义 Item 对象，名为 ProductItem，代码如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ProductItem</span>(<span class="symbol">Item</span>):</span><br><span class="line"></span><br><span class="line">    <span class="symbol">collection</span> = '<span class="symbol">products</span>'</span><br><span class="line">    <span class="symbol">image</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">price</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">deal</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">title</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">shop</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">location</span> = <span class="symbol">Field</span>()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了 6 个 Field，也就是 6 个字段，跟之前的案例完全相同。然后定义了一个 collection 属性，即此 Item 保存到 MongoDB 的 Collection 名称。 初步实现 Spider 的 start_requests() 方法，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy import Request, Spider</span><br><span class="line"><span class="keyword">from</span> urllib.parse import quote</span><br><span class="line"><span class="keyword">from</span> scrapyseleniumtest.items import ProductItem</span><br><span class="line"></span><br><span class="line">class TaobaoSpider(Spider):</span><br><span class="line">    name = <span class="string">'taobao'</span></span><br><span class="line">    allowed_domains = [<span class="string">'www.taobao.com'</span>]</span><br><span class="line">    base_url = <span class="string">'https://s.taobao.com/search?q='</span></span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        <span class="keyword">for</span> keyword <span class="keyword">in</span> self.settings.<span class="builtin-name">get</span>(<span class="string">'KEYWORDS'</span>):</span><br><span class="line">            <span class="keyword">for</span><span class="built_in"> page </span><span class="keyword">in</span> range(1, self.settings.<span class="builtin-name">get</span>(<span class="string">'MAX_PAGE'</span>) + 1):</span><br><span class="line">                url = self.base_url + quote(keyword)</span><br><span class="line">                yield Request(<span class="attribute">url</span>=url, <span class="attribute">callback</span>=self.parse, meta=&#123;<span class="string">'page'</span>: page&#125;, <span class="attribute">dont_filter</span>=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先定义了一个 base_url，即商品列表的 URL，其后拼接一个搜索关键字就是该关键字在淘宝的搜索结果商品列表页面。 关键字用 KEYWORDS 标识，定义为一个列表。最大翻页页码用 MAX_PAGE 表示。它们统一定义在 setttings.py 里面，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">KEYWORDS</span> = [<span class="string">'iPad'</span>]</span><br><span class="line"><span class="attr">MAX_PAGE</span> = <span class="number">100</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在 start_requests() 方法里，我们首先遍历了关键字，遍历了分页页码，构造并生成 Request。由于每次搜索的 URL 是相同的，所以分页页码用 meta 参数来传递，同时设置 dont_filter 不去重。这样爬虫启动的时候，就会生成每个关键字对应的商品列表的每一页的请求了。</p>
                  <h3 id="5-对接-Selenium"><a href="#5-对接-Selenium" class="headerlink" title="5. 对接 Selenium"></a>5. 对接 Selenium</h3>
                  <p>接下来我们需要处理这些请求的抓取。这次我们对接 Selenium 进行抓取，采用 Downloader Middleware 来实现。在 Middleware 里面的 process_request() 方法里对每个抓取请求进行处理，启动浏览器并进行页面渲染，再将渲染后的结果构造一个 HtmlResponse 对象返回。代码实现如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> selenium import webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions import TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by import By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"><span class="keyword">from</span> scrapy.http import HtmlResponse</span><br><span class="line"><span class="keyword">from</span><span class="built_in"> logging </span>import getLogger</span><br><span class="line"></span><br><span class="line">class SeleniumMiddleware():</span><br><span class="line">    def __init__(self, <span class="attribute">timeout</span>=None, service_args=[]):</span><br><span class="line">        self.logger = getLogger(__name__)</span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.browser = webdriver.PhantomJS(<span class="attribute">service_args</span>=service_args)</span><br><span class="line">        self.browser.set_window_size(1400, 700)</span><br><span class="line">        self.browser.set_page_load_timeout(self.timeout)</span><br><span class="line">        self.wait = WebDriverWait(self.browser, self.timeout)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.browser.close()</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        用 PhantomJS 抓取页面</span></span><br><span class="line"><span class="string">        :param request: Request 对象</span></span><br><span class="line"><span class="string">        :param spider: Spider 对象</span></span><br><span class="line"><span class="string">        :return: HtmlResponse</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        self.logger.<span class="builtin-name">debug</span>(<span class="string">'PhantomJS is Starting'</span>)</span><br><span class="line">       <span class="built_in"> page </span>= request.meta.<span class="builtin-name">get</span>(<span class="string">'page'</span>, 1)</span><br><span class="line">        try:</span><br><span class="line">            self.browser.<span class="builtin-name">get</span>(request.url)</span><br><span class="line">            <span class="keyword">if</span><span class="built_in"> page </span>&gt; 1:</span><br><span class="line">                input = self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager div.form&gt; input'</span>)))</span><br><span class="line">                submit = self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager div.form&gt; span.btn.J_Submit'</span>)))</span><br><span class="line">                input.clear()</span><br><span class="line">                input.send_keys(page)</span><br><span class="line">                submit.click()</span><br><span class="line">            self.wait.until(EC.text_to_be_present_in_element((By.CSS_SELECTOR, <span class="string">'#mainsrp-pager li.item.active&gt; span'</span>), str(page)))</span><br><span class="line">            self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'.m-itemlist .items .item'</span>)))</span><br><span class="line">            return HtmlResponse(<span class="attribute">url</span>=request.url, <span class="attribute">body</span>=self.browser.page_source, <span class="attribute">request</span>=request, <span class="attribute">encoding</span>=<span class="string">'utf-8'</span>, <span class="attribute">status</span>=200)</span><br><span class="line">        except TimeoutException:</span><br><span class="line">            return HtmlResponse(<span class="attribute">url</span>=request.url, <span class="attribute">status</span>=500, <span class="attribute">request</span>=request)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(<span class="attribute">timeout</span>=crawler.settings.get('SELENIUM_TIMEOUT'),</span><br><span class="line">                   <span class="attribute">service_args</span>=crawler.settings.get('PHANTOMJS_SERVICE_ARGS'))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先我们在 <strong>init</strong>() 里对一些对象进行初始化，包括 PhantomJS、WebDriverWait 等对象，同时设置页面大小和页面加载超时时间。在 process_request() 方法中，我们通过 Request 的 meta 属性获取当前需要爬取的页码，调用 PhantomJS 对象的 get() 方法访问 Request 的对应的 URL。这就相当于从 Request 对象里获取请求链接，然后再用 PhantomJS 加载，而不再使用 Scrapy 里的 Downloader。 随后的处理等待和翻页的方法在此不再赘述，和前文的原理完全相同。最后，页面加载完成之后，我们调用 PhantomJS 的 page_source 属性即可获取当前页面的源代码，然后用它来直接构造并返回一个 HtmlResponse 对象。构造这个对象的时候需要传入多个参数，如 url、body 等，这些参数实际上就是它的基础属性。可以在官方文档查看 HtmlResponse 对象的结构：<a href="https://doc.scrapy.org/en/latest/topics/request-response.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html</a>，这样我们就成功利用 PhantomJS 来代替 Scrapy 完成了页面的加载，最后将 Response 返回即可。 有人可能会纳闷：为什么实现这么一个 Downloader Middleware 就可以了？之前的 Request 对象怎么办？Scrapy 不再处理了吗？Response 返回后又传递给了谁？ 是的，Request 对象到这里就不会再处理了，也不会再像以前一样交给 Downloader 下载。Response 会直接传给 Spider 进行解析。 我们需要回顾一下 Downloader Middleware 的 process_request() 方法的处理逻辑，内容如下所示： 当 process_request() 方法返回 Response 对象的时候，更低优先级的 Downloader Middleware 的 process_request() 和 process_exception() 方法就不会被继续调用了，转而开始执行每个 Downloader Middleware 的 process_response() 方法，调用完毕之后直接将 Response 对象发送给 Spider 来处理。 这里直接返回了一个 HtmlResponse 对象，它是 Response 的子类，返回之后便顺次调用每个 Downloader Middleware 的 process_response() 方法。而在 process_response() 中我们没有对其做特殊处理，它会被发送给 Spider，传给 Request 的回调函数进行解析。 到现在，我们应该能了解 Downloader Middleware 实现 Selenium 对接的原理了。 在 settings.py 里，我们设置调用刚才定义的 SeleniumMiddleware、设置等待超时变量 SELENIUM_TIMEOUT、设置 PhantomJS 配置参数 PHANTOMJS_SERVICE_ARGS，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">DOWNLOADER_MIDDLEWARES</span> = &#123;<span class="string">'scrapyseleniumtest.middlewares.SeleniumMiddleware'</span>: <span class="number">543</span>,&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="6-解析页面"><a href="#6-解析页面" class="headerlink" title="6. 解析页面"></a>6. 解析页面</h3>
                  <p>Response 对象就会回传给 Spider 内的回调函数进行解析。所以下一步我们就实现其回调函数，对网页来进行解析，代码如下所示：</p>
                  <figure class="highlight nginx">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">def</span> parse(self, response):</span><br><span class="line">    products = response.xpath(<span class="string">'//div[<span class="variable">@id</span>="mainsrp-itemlist"]//div[<span class="variable">@class</span>="items"][1]//div[contains(<span class="variable">@class</span>, "item")]'</span>)</span><br><span class="line">    for product in products:</span><br><span class="line">        item = ProductItem()</span><br><span class="line">        item[<span class="string">'price'</span>] = <span class="string">''</span>.join(product.xpath(<span class="string">'.//div[contains(<span class="variable">@class</span>, "price")]//text()'</span>).extract()).strip()</span><br><span class="line">        item[<span class="string">'title'</span>] = <span class="string">''</span>.join(product.xpath(<span class="string">'.//div[contains(<span class="variable">@class</span>, "title")]//text()'</span>).extract()).strip()</span><br><span class="line">        item[<span class="string">'shop'</span>] = <span class="string">''</span>.join(product.xpath(<span class="string">'.//div[contains(<span class="variable">@class</span>, "shop")]//text()'</span>).extract()).strip()</span><br><span class="line">        item[<span class="string">'image'</span>] = <span class="string">''</span>.join(product.xpath(<span class="string">'.//div[<span class="variable">@class</span>="pic"]//img[contains(<span class="variable">@class</span>, "img")]/<span class="variable">@data</span>-src'</span>).extract()).strip()</span><br><span class="line">        item[<span class="string">'deal'</span>] = product.xpath(<span class="string">'.//div[contains(<span class="variable">@class</span>, "deal-cnt")]//text()'</span>).extract_first()</span><br><span class="line">        item[<span class="string">'location'</span>] = product.xpath(<span class="string">'.//div[contains(<span class="variable">@class</span>, "location")]//text()'</span>).extract_first()</span><br><span class="line">        yield item</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们使用 XPath 进行解析，调用 response 变量的 xpath() 方法即可。首先我们传递选取所有商品对应的 XPath，可以匹配所有商品，随后对结果进行遍历，依次选取每个商品的名称、价格、图片等内容，构造并返回一个 ProductItem 对象。</p>
                  <h3 id="7-存储结果"><a href="#7-存储结果" class="headerlink" title="7. 存储结果"></a>7. 存储结果</h3>
                  <p>最后我们实现一个 Item Pipeline，将结果保存到 MongoDB，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, mongo_uri, mongo_db)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.mongo_uri = mongo_uri</span><br><span class="line">        <span class="keyword">self</span>.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> cls(mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>), mongo_db=crawler.settings.get(<span class="string">'MONGO_DB'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client = pymongo.MongoClient(<span class="keyword">self</span>.mongo_uri)</span><br><span class="line">        <span class="keyword">self</span>.db = <span class="keyword">self</span>.client[<span class="keyword">self</span>.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.db[item.collection].insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此实现和前文中存储到 MongoDB 的方法完全一致，原理不再赘述。记得在 settings.py 中开启它的调用，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">ITEM_PIPELINES</span> = &#123;<span class="string">'scrapyseleniumtest.pipelines.MongoPipeline'</span>: <span class="number">300</span>,&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中，MONGO_URI 和 MONGO_DB 的定义如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MONGO_URI</span> = <span class="string">'localhost'</span></span><br><span class="line"><span class="attr">MONGO_DB</span> = <span class="string">'taobao'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="8-运行"><a href="#8-运行" class="headerlink" title="8. 运行"></a>8. 运行</h3>
                  <p>整个项目就完成了，执行如下命令启动抓取即可：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl taobao</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如图 13-13 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034100.jpg" alt=""> 图 13-13 运行结果 再查看一下 MongoDB，结果如图 13-14 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-034105.jpg" alt=""> 图 13-14 MongoDB 结果 这样我们便成功在 Scrapy 中对接 Selenium 并实现了淘宝商品的抓取。</p>
                  <h3 id="9-本节代码"><a href="#9-本节代码" class="headerlink" title="9. 本节代码"></a>9. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/ScrapySeleniumTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapySeleniumTest</a>。</p>
                  <h3 id="10-结语"><a href="#10-结语" class="headerlink" title="10. 结语"></a>10. 结语</h3>
                  <p>我们通过改写 Downloader Middleware 的方式实现了 Selenium 的对接。但这种方法其实是阻塞式的，也就是说这样就破坏了 Scrapy 异步处理的逻辑，速度会受到影响。为了不破坏其异步加载逻辑，我们可以使用 Splash 实现。下一节我们再来看看 Scrapy 对接 Splash 的方式。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-05 09:30:23" itemprop="dateCreated datePublished" datetime="2019-12-05T09:30:23+08:00">2019-12-05</time>
                </span>
                <span id="/8397.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.8–Scrapy 对接 Selenium" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>7.2k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>7 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8394.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8394.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.7–Item Pipeline 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-7-Item-Pipeline-的用法"><a href="#13-7-Item-Pipeline-的用法" class="headerlink" title="13.7 Item Pipeline 的用法"></a>13.7 Item Pipeline 的用法</h1>
                  <p>Item Pipeline 是项目管道。在前面我们已经了解了 Item Pipeline 的基本用法，本节我们再作详细了解它的用法。 首先我们看看 Item Pipeline 在 Scrapy 中的架构，如图 13-1 所示。 图中的最左侧即为 Item Pipeline，它的调用发生在 Spider 产生 Item 之后。当 Spider 解析完 Response 之后，Item 就会传递到 Item Pipeline，被定义的 Item Pipeline 组件会顺次调用，完成一连串的处理过程，比如数据清洗、存储等。 它的主要功能有：</p>
                  <ul>
                    <li>清洗 HTML 数据</li>
                    <li>验证爬取数据，检查爬取字段</li>
                    <li>查重并丢弃重复内容</li>
                    <li>将爬取结果储存到数据库</li>
                  </ul>
                  <h3 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h3>
                  <p>我们可以自定义 Item Pipeline，只需要实现指定的方法就好，其中必须要实现的一个方法是：</p>
                  <ul>
                    <li>process_item(item, spider)</li>
                  </ul>
                  <p>另外还有几个比较实用的方法，它们分别是：</p>
                  <ul>
                    <li>open_spider(spider)</li>
                    <li>close_spider(spider)</li>
                    <li>from_crawler(cls, crawler)</li>
                  </ul>
                  <p>下面我们对这几个方法的用法作下详细的介绍：</p>
                  <h4 id="process-item-item-spider"><a href="#process-item-item-spider" class="headerlink" title="process_item(item, spider)"></a>process_item(item, spider)</h4>
                  <p>process_item() 是必须要实现的方法，被定义的 Item Pipeline 会默认调用这个方法对 Item 进行处理。比如，我们可以进行数据处理或者将数据写入到数据库等操作。它必须返回 Item 类型的值或者抛出一个 DropItem 异常。 process_item() 方法的参数有如下两个。</p>
                  <ul>
                    <li>item，是 Item 对象，即被处理的 Item</li>
                    <li>spider，是 Spider 对象，即生成该 Item 的 Spider</li>
                  </ul>
                  <p>下面对该方法的返回类型归纳如下：</p>
                  <ul>
                    <li>如果返回的是 Item 对象，那么此 Item 会接着被低优先级的 Item Pipeline 的 process_item() 方法进行处理，直到所有的方法被调用完毕。</li>
                    <li>如果抛出的是 DropItem 异常，那么此 Item 就会被丢弃，不再进行处理。</li>
                  </ul>
                  <h4 id="open-spider-self-spider"><a href="#open-spider-self-spider" class="headerlink" title="open_spider(self, spider)"></a>open_spider(self, spider)</h4>
                  <p>open_spider() 方法是在 Spider 开启的时候被自动调用的，在这里我们可以做一些初始化操作，如开启数据库连接等。其中参数 spider 就是被开启的 Spider 对象。</p>
                  <h4 id="close-spider-spider"><a href="#close-spider-spider" class="headerlink" title="close_spider(spider)"></a>close_spider(spider)</h4>
                  <p>close_spider() 方法是在 Spider 关闭的时候自动调用的，在这里我们可以做一些收尾工作，如关闭数据库连接等，其中参数 spider 就是被关闭的 Spider 对象。</p>
                  <h4 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a>from_crawler(cls, crawler)</h4>
                  <p>from_crawler() 方法是一个类方法，用 @classmethod 标识，是一种依赖注入的方式。它的参数是 crawler，通过 crawler 对象，我们可以拿到 Scrapy 的所有核心组件，如全局配置的每个信息，然后创建一个 Pipeline 实例。参数 cls 就是 Class，最后返回一个 Class 实例。 下面我们用一个实例来加深对 Item Pipeline 用法的理解。</p>
                  <h3 id="2-本节目标"><a href="#2-本节目标" class="headerlink" title="2. 本节目标"></a>2. 本节目标</h3>
                  <p>我们以爬取 360 摄影美图为例，来分别实现 MongoDB 存储、MySQL 存储、Image 图片存储的三个 Pipeline。</p>
                  <h3 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3. 准备工作"></a>3. 准备工作</h3>
                  <p>请确保已经安装好 MongoDB 和 MySQL 数据库，安装好 Python 的 PyMongo、PyMySQL、Scrapy 框架，另外需要安装 pillow 图像处理库，如没有安装可以参考第 1 章的安装说明。</p>
                  <h3 id="4-抓取分析"><a href="#4-抓取分析" class="headerlink" title="4. 抓取分析"></a>4. 抓取分析</h3>
                  <p>我们这次爬取的目标网站为：<a href="https://image.so.com。打开此页面，切换到摄影页面，网页中呈现了许许多多的摄影美图。我们打开浏览器开发者工具，过滤器切换到" target="_blank" rel="noopener">https://image.so.com。打开此页面，切换到摄影页面，网页中呈现了许许多多的摄影美图。我们打开浏览器开发者工具，过滤器切换到</a> XHR 选项，然后下拉页面，可以看到下面就会呈现许多 Ajax 请求，如图 13-6 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033958.png" alt=""> 图 13-6 请求列表 我们查看一个请求的详情，观察返回的数据结构，如图 13-7 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034003.jpg" alt=""> 图 13-7 返回结果 返回格式是 JSON。其中 list 字段就是一张张图片的详情信息，包含了 30 张图片的 ID、名称、链接、缩略图等信息。另外观察 Ajax 请求的参数信息，有一个参数 sn 一直在变化，这个参数很明显就是偏移量。当 sn 为 30 时，返回的是前 30 张图片，sn 为 60 时，返回的就是第 31~60 张图片。另外，ch 参数是摄影类别，listtype 是排序方式，temp 参数可以忽略。 所以我们抓取时只需要改变 sn 的数值就好了。 下面我们用 Scrapy 来实现图片的抓取，将图片的信息保存到 MongoDB、MySQL，同时将图片存储到本地。</p>
                  <h3 id="5-新建项目"><a href="#5-新建项目" class="headerlink" title="5. 新建项目"></a>5. 新建项目</h3>
                  <p>首先新建一个项目，命令如下：</p>
                  <figure class="highlight mipsasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">scrapy </span>startproject images360</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来新建一个 Spider，命令如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">images</span> <span class="selector-tag">images</span><span class="selector-class">.so</span><span class="selector-class">.com</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就成功创建了一个 Spider。</p>
                  <h3 id="6-构造请求"><a href="#6-构造请求" class="headerlink" title="6. 构造请求"></a>6. 构造请求</h3>
                  <p>接下来定义爬取的页数。比如爬取 50 页、每页 30 张，也就是 1500 张图片，我们可以先在 settings.py 里面定义一个变量 MAX_PAGE，添加如下定义：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MAX_PAGE</span> = <span class="number">50</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>定义 start_requests() 方法，用来生成 50 次请求，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def start_requests(self):</span><br><span class="line">    data = &#123;<span class="string">'ch'</span>: <span class="string">'photography'</span>, <span class="string">'listtype'</span>: <span class="string">'new'</span>&#125;</span><br><span class="line">    base_url = <span class="string">'https://image.so.com/zj?'</span></span><br><span class="line">    <span class="keyword">for</span><span class="built_in"> page </span><span class="keyword">in</span> range(1, self.settings.<span class="builtin-name">get</span>(<span class="string">'MAX_PAGE'</span>) + 1):</span><br><span class="line">        data[<span class="string">'sn'</span>] =<span class="built_in"> page </span>* 30</span><br><span class="line">        params = urlencode(data)</span><br><span class="line">        url = base_url + params</span><br><span class="line">        yield Request(url, self.parse)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们首先定义了初始的两个参数，sn 参数是遍历循环生成的。然后利用 urlencode() 方法将字典转化为 URL 的 GET 参数，构造出完整的 URL，构造并生成 Request。 还需要引入 scrapy.Request 和 urllib.parse 模块，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Spider, Request</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>再修改 settings.py 中的 ROBOTSTXT_OBEY 变量，将其设置为 False，否则无法抓取，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">ROBOTSTXT_OBEY</span> = <span class="literal">False</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行爬虫，即可以看到链接都请求成功，执行命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl images</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行示例结果如图 13-8 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034009.jpg" alt=""> 图 13-8 运行结果 所有请求的状态码都是 200，这就证明图片信息爬取成功了。</p>
                  <h3 id="7-提取信息"><a href="#7-提取信息" class="headerlink" title="7. 提取信息"></a>7. 提取信息</h3>
                  <p>首先定义一个 Item，叫作 ImageItem，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item, Field</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ImageItem</span>(<span class="symbol">Item</span>):</span><br><span class="line">    <span class="symbol">collection</span> = <span class="symbol">table</span> = '<span class="symbol">images</span>'</span><br><span class="line">    <span class="symbol">id</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">url</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">title</span> = <span class="symbol">Field</span>()</span><br><span class="line">    <span class="symbol">thumb</span> = <span class="symbol">Field</span>()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们定义了 4 个字段，包括图片的 ID、链接、标题、缩略图。另外还有两个属性 collection 和 table，都定义为 images 字符串，分别代表 MongoDB 存储的 Collection 名称和 MySQL 存储的表名称。 接下来我们提取 Spider 里有关信息，将 parse() 方法改写为如下所示：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse(self, response):</span><br><span class="line">    <span class="built_in">result</span> = json.loads(response.<span class="keyword">text</span>)</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> <span class="built_in">result</span>.<span class="built_in">get</span>(<span class="string">'list'</span>):</span><br><span class="line">        <span class="keyword">item</span> = ImageItem()</span><br><span class="line">        <span class="keyword">item</span>[<span class="string">'id'</span>] = image.<span class="built_in">get</span>(<span class="string">'imageid'</span>)</span><br><span class="line">        <span class="keyword">item</span>[<span class="string">'url'</span>] = image.<span class="built_in">get</span>(<span class="string">'qhimg_url'</span>)</span><br><span class="line">        <span class="keyword">item</span>[<span class="string">'title'</span>] = image.<span class="built_in">get</span>(<span class="string">'group_title'</span>)</span><br><span class="line">        <span class="keyword">item</span>[<span class="string">'thumb'</span>] = image.<span class="built_in">get</span>(<span class="string">'qhimg_thumb_url'</span>)</span><br><span class="line">        yield <span class="keyword">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先解析 JSON，遍历其 list 字段，取出一个个图片信息，然后再对 ImageItem 赋值，生成 Item 对象。 这样我们就完成了信息的提取。</p>
                  <h3 id="8-存储信息"><a href="#8-存储信息" class="headerlink" title="8. 存储信息"></a>8. 存储信息</h3>
                  <p>接下来我们需要将图片的信息保存到 MongoDB、MySQL，同时将图片保存到本地。</p>
                  <h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4>
                  <p>首先确保 MongoDB 已经正常安装并且正常运行。 我们用一个 MongoPipeline 将信息保存到 MongoDB，在 pipelines.py 里添加如下类的实现：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, mongo_uri, mongo_db)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.mongo_uri = mongo_uri</span><br><span class="line">        <span class="keyword">self</span>.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> cls(mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>),</span><br><span class="line">            mongo_db=crawler.settings.get(<span class="string">'MONGO_DB'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client = pymongo.MongoClient(<span class="keyword">self</span>.mongo_uri)</span><br><span class="line">        <span class="keyword">self</span>.db = <span class="keyword">self</span>.client[<span class="keyword">self</span>.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.db[item.collection].insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里需要用到两个变量，MONGO_URI 和 MONGO_DB，即存储到 MongoDB 的链接地址和数据库名称。我们在 settings.py 里添加这两个变量，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MONGO_URI</span> = <span class="string">'localhost'</span></span><br><span class="line"><span class="attr">MONGO_DB</span> = <span class="string">'images360'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样一个保存到 MongoDB 的 Pipeline 的就创建好了。这里最主要的方法是 process_item() 方法，直接调用 Collection 对象的 insert() 方法即可完成数据的插入，最后返回 Item 对象。</p>
                  <h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4>
                  <p>首先确保 MySQL 已经正确安装并且正常运行。 新建一个数据库，名字还是 images360，SQL 语句如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">CREATE DATABASE images360<span class="built_in"> DEFAULT </span>CHARACTER <span class="builtin-name">SET</span> utf8 COLLATE utf8_general_ci</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>新建一个数据表，包含 id、url、title、thumb 四个字段，SQL 语句如下所示：</p>
                  <figure class="highlight sql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> images (<span class="keyword">id</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>, <span class="keyword">url</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="literal">NULL</span> , title <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="literal">NULL</span> , thumb <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="literal">NULL</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>执行完 SQL 语句之后，我们就成功创建好了数据表。接下来就可以往表里存储数据了。 接下来我们实现一个 MySQLPipeline，代码如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlPipeline</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, host, database, user, password, port)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.host = host</span><br><span class="line">        <span class="keyword">self</span>.database = database</span><br><span class="line">        <span class="keyword">self</span>.user = user</span><br><span class="line">        <span class="keyword">self</span>.password = password</span><br><span class="line">        <span class="keyword">self</span>.port = port</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> cls(host=crawler.settings.get(<span class="string">'MYSQL_HOST'</span>),</span><br><span class="line">            database=crawler.settings.get(<span class="string">'MYSQL_DATABASE'</span>),</span><br><span class="line">            user=crawler.settings.get(<span class="string">'MYSQL_USER'</span>),</span><br><span class="line">            password=crawler.settings.get(<span class="string">'MYSQL_PASSWORD'</span>),</span><br><span class="line">            port=crawler.settings.get(<span class="string">'MYSQL_PORT'</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.db = pymysql.connect(<span class="keyword">self</span>.host, <span class="keyword">self</span>.user, <span class="keyword">self</span>.password, <span class="keyword">self</span>.database, charset=<span class="string">'utf8'</span>, port=<span class="keyword">self</span>.port)</span><br><span class="line">        <span class="keyword">self</span>.cursor = <span class="keyword">self</span>.db.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.db.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        data = dict(item)</span><br><span class="line">        keys = <span class="string">', '</span>.join(data.keys())</span><br><span class="line">        values = <span class="string">', '</span>.join([<span class="string">'% s'</span>] * len(data))</span><br><span class="line">        sql = <span class="string">'insert into % s (% s) values (% s)'</span> % (item.table, keys, values)</span><br><span class="line">        <span class="keyword">self</span>.cursor.execute(sql, tuple(data.values()))</span><br><span class="line">        <span class="keyword">self</span>.db.commit()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如前所述，这里用到的数据插入方法是一个动态构造 SQL 语句的方法。 这里又需要几个 MySQL 的配置，我们在 settings.py 里添加几个变量，如下所示：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">MYSQL_HOST</span> = <span class="string">'localhost'</span></span><br><span class="line"><span class="attr">MYSQL_DATABASE</span> = <span class="string">'images360'</span></span><br><span class="line"><span class="attr">MYSQL_PORT</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">MYSQL_USER</span> = <span class="string">'root'</span></span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span> = <span class="string">'123456'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里分别定义了 MySQL 的地址、数据库名称、端口、用户名、密码。 这样，MySQL Pipeline 就完成了。</p>
                  <h4 id="Image-Pipeline"><a href="#Image-Pipeline" class="headerlink" title="Image Pipeline"></a>Image Pipeline</h4>
                  <p>Scrapy 提供了专门处理下载的 Pipeline，包括文件下载和图片下载。下载文件和图片的原理与抓取页面的原理一样，因此下载过程支持异步和多线程，下载十分高效。下面我们来看看具体的实现过程。 官方文档地址为：<a href="https://doc.scrapy.org/en/latest/topics/media-pipeline.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/media-pipeline.html</a>。 首先定义存储文件的路径，需要定义一个 IMAGES_STORE 变量，在 settings.py 中添加如下代码：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">IMAGES_STORE</span> = <span class="string">'./images'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们将路径定义为当前路径下的 images 子文件夹，即下载的图片都会保存到本项目的 images 文件夹中。 内置的 ImagesPipeline 会默认读取 Item 的 image_urls 字段，并认为该字段是一个列表形式，它会遍历 Item 的 image_urls 字段，然后取出每个 URL 进行图片下载。 但是现在生成的 Item 的图片链接字段并不是 image_urls 字段表示的，也不是列表形式，而是单个的 URL。所以为了实现下载，我们需要重新定义下载的部分逻辑，即要自定义 ImagePipeline，继承内置的 ImagesPipeline，重写几个方法。 我们定义 ImagePipeline，如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagePipeline</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        url = request.url</span><br><span class="line">        file_name = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        image_paths = [x[<span class="string">'path'</span>] <span class="keyword">for</span> ok, x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> image_paths:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Image Downloaded Failed'</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self, item, info)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> Request(item[<span class="string">'url'</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们实现了 ImagePipeline，继承 Scrapy 内置的 ImagesPipeline，重写下面几个方法。</p>
                  <ul>
                    <li>get_media_requests()。它的第一个参数 item 是爬取生成的 Item 对象。我们将它的 url 字段取出来，然后直接生成 Request 对象。此 Request 加入到调度队列，等待被调度，执行下载。</li>
                    <li>file_path()。它的第一个参数 request 就是当前下载对应的 Request 对象。这个方法用来返回保存的文件名，直接将图片链接的最后一部分当作文件名即可。它利用 split() 函数分割链接并提取最后一部分，返回结果。这样此图片下载之后保存的名称就是该函数返回的文件名。</li>
                    <li>item_completed()，它是当单个 Item 完成下载时的处理方法。因为并不是每张图片都会下载成功，所以我们需要分析下载结果并剔除下载失败的图片。如果某张图片下载失败，那么我们就不需保存此 Item 到数据库。该方法的第一个参数 results 就是该 Item 对应的下载结果，它是一个列表形式，列表每一个元素是一个元组，其中包含了下载成功或失败的信息。这里我们遍历下载结果找出所有成功的下载列表。如果列表为空，那么该 Item 对应的图片下载失败，随即抛出异常 DropItem，该 Item 忽略。否则返回该 Item，说明此 Item 有效。</li>
                  </ul>
                  <p>现在为止，三个 Item Pipeline 的定义就完成了。最后只需要启用就可以了，修改 settings.py，设置 ITEM_PIPELINES，如下所示：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">ITEM_PIPELINES</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'images360.pipelines.ImagePipeline':</span> <span class="number">300</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'images360.pipelines.MongoPipeline':</span> <span class="number">301</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'images360.pipelines.MysqlPipeline':</span> <span class="number">302</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里注意调用的顺序。我们需要优先调用 ImagePipeline 对 Item 做下载后的筛选，下载失败的 Item 就直接忽略，它们就不会保存到 MongoDB 和 MySQL 里。随后再调用其他两个存储的 Pipeline，这样就能确保存入数据库的图片都是下载成功的。 接下来运行程序，执行爬取，如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl images</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>爬虫一边爬取一边下载，下载速度非常快，对应的输出日志如图 13-9 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034019.jpg" alt=""> 图 13-9 输出日志 查看本地 images 文件夹，发现图片都已经成功下载，如图 13-10 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034024.jpg" alt=""> 图 13-10 下载结果 查看 MySQL，下载成功的图片信息也已成功保存，如图 13-11 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034029.jpg" alt=""> 图 13-11 MySQL 结果 查看 MongoDB，下载成功的图片信息同样已成功保存，如图 13-12 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-034034.jpg" alt=""> 图 13-12 MongoDB 结果 这样我们就可以成功实现图片的下载并把图片的信息存入数据库了。</p>
                  <h3 id="9-本节代码"><a href="#9-本节代码" class="headerlink" title="9. 本节代码"></a>9. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/Images360" target="_blank" rel="noopener">https://github.com/Python3WebSpider/Images360</a>。</p>
                  <h3 id="10-结语"><a href="#10-结语" class="headerlink" title="10. 结语"></a>10. 结语</h3>
                  <p>Item Pipeline 是 Scrapy 非常重要的组件，数据存储几乎都是通过此组件实现的。请读者认真掌握此内容。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-05 09:26:32" itemprop="dateCreated datePublished" datetime="2019-12-05T09:26:32+08:00">2019-12-05</time>
                </span>
                <span id="/8394.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.7–Item Pipeline 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>8.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>7 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8385.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8385.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.6–Spider Middleware 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-6-Spider-Middleware-的用法"><a href="#13-6-Spider-Middleware-的用法" class="headerlink" title="13.6 Spider Middleware 的用法"></a>13.6 Spider Middleware 的用法</h1>
                  <p>Spider Middleware 是介入到 Scrapy 的 Spider 处理机制的钩子框架。我们首先来看看它的架构，如图 13-1 所示。 当 Downloader 生成 Response 之后，Response 会被发送给 Spider，在发送给 Spider 之前，Response 会首先经过 Spider Middleware 处理，当 Spider 处理生成 Item 和 Request 之后，Item 和 Request 还会经过 Spider Middleware 的处理。 Spider Middleware 有如下三个作用。</p>
                  <ul>
                    <li>我们可以在 Downloader 生成的 Response 发送给 Spider 之前，也就是在 Response 发送给 Spider 之前对 Response 进行处理。</li>
                    <li>我们可以在 Spider 生成的 Request 发送给 Scheduler 之前，也就是在 Request 发送给 Scheduler 之前对 Request 进行处理。</li>
                    <li>我们可以在 Spider 生成的 Item 发送给 Item Pipeline 之前，也就是在 Item 发送给 Item Pipeline 之前对 Item 进行处理。</li>
                  </ul>
                  <h3 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h3>
                  <p>需要说明的是，Scrapy 其实已经提供了许多 Spider Middleware，它们被 SPIDER_MIDDLEWARES_BASE 这个变量所定义。 SPIDER_MIDDLEWARES_BASE 变量的内容如下：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware':</span> <span class="number">50</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.spidermiddlewares.offsite.OffsiteMiddleware':</span> <span class="number">500</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.spidermiddlewares.referer.RefererMiddleware':</span> <span class="number">700</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware':</span> <span class="number">800</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.spidermiddlewares.depth.DepthMiddleware':</span> <span class="number">900</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>和 Downloader Middleware 一样，Spider Middleware 首先加入到 SPIDER_MIDDLEWARES 设置中，该设置会和 Scrapy 中 SPIDER_MIDDLEWARES_BASE 定义的 Spider Middleware 合并。然后根据键值的数字优先级排序，得到一个有序列表。第一个 Middleware 是最靠近引擎的，最后一个 Middleware 是最靠近 Spider 的。</p>
                  <h3 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h3>
                  <p>Scrapy 内置的 Spider Middleware 为 Scrapy 提供了基础的功能。如果我们想要扩展其功能，只需要实现某几个方法即可。 每个 Spider Middleware 都定义了以下一个或多个方法的类，核心方法有如下 4 个。</p>
                  <ul>
                    <li>process_spider_input(response, spider)</li>
                    <li>process_spider_output(response, result, spider)</li>
                    <li>process_spider_exception(response, exception, spider)</li>
                    <li>process_start_requests(start_requests, spider)</li>
                  </ul>
                  <p>只需要实现其中一个方法就可以定义一个 Spider Middleware。下面我们来看看这 4 个方法的详细用法。</p>
                  <h4 id="process-spider-input-response-spider"><a href="#process-spider-input-response-spider" class="headerlink" title="process_spider_input(response, spider)"></a>process_spider_input(response, spider)</h4>
                  <p>当 Response 通过 Spider Middleware 时，该方法被调用，处理该 Response。 方法的参数有两个：</p>
                  <ul>
                    <li>response，即 Response 对象，即被处理的 Response</li>
                    <li>spider，即 Spider 对象，即该 response 对应的 Spider</li>
                  </ul>
                  <p>process_spider_input() 应该返回 None 或者抛出一个异常。</p>
                  <ul>
                    <li>如果其返回 None ，Scrapy 将会继续处理该 Response，调用所有其他的 Spider Middleware 直到 Spider 处理该 Response。</li>
                    <li>如果其抛出一个异常，Scrapy 将不会调用任何其他 Spider Middlewar e 的 process_spider_input() 方法，并调用 Request 的 errback() 方法。 errback 的输出将会以另一个方向被重新输入到中间件中，使用 process_spider_output() 方法来处理，当其抛出异常时则调用 process_spider_exception() 来处理。</li>
                  </ul>
                  <h4 id="process-spider-output-response-result-spider"><a href="#process-spider-output-response-result-spider" class="headerlink" title="process_spider_output(response, result, spider)"></a>process_spider_output(response, result, spider)</h4>
                  <p>当 Spider 处理 Response 返回结果时，该方法被调用。 方法的参数有三个：</p>
                  <ul>
                    <li>response，即 Response 对象，即生成该输出的 Response</li>
                    <li>result，包含 Request 或 Item 对象的可迭代对象，即 Spider 返回的结果</li>
                    <li>spider，即 Spider 对象，即其结果对应的 Spider</li>
                  </ul>
                  <p>process_spider_output() 必须返回包含 Request 或 Item 对象的可迭代对象。</p>
                  <h4 id="process-spider-exception-response-exception-spider"><a href="#process-spider-exception-response-exception-spider" class="headerlink" title="process_spider_exception(response, exception, spider)"></a>process_spider_exception(response, exception, spider)</h4>
                  <p>当 Spider 或 Spider Middleware 的 process_spider_input() 方法抛出异常时， 该方法被调用。 方法的参数有三个：</p>
                  <ul>
                    <li>response，即 Response 对象，即异常被抛出时被处理的 Response</li>
                    <li>exception，即 Exception 对象，被抛出的异常</li>
                    <li>spider，即 Spider 对象，即抛出该异常的 Spider</li>
                  </ul>
                  <p>process_spider_exception() 必须要么返回 None ， 要么返回一个包含 Response 或 Item 对象的可迭代对象。</p>
                  <ul>
                    <li>如果其返回 None ，Scrapy 将继续处理该异常，调用其他 Spider Middleware 中的 process_spider_exception() 方法，直到所有 Spider Middleware 都被调用。</li>
                    <li>如果其返回一个可迭代对象，则其他 Spider Middleware 的 process_spider_output() 方法被调用， 其他的 process_spider_exception() 将不会被调用。</li>
                  </ul>
                  <h4 id="process-start-requests-start-requests-spider"><a href="#process-start-requests-start-requests-spider" class="headerlink" title="process_start_requests(start_requests, spider)"></a>process_start_requests(start_requests, spider)</h4>
                  <p>该方法以 Spider 启动的 Request 为参数被调用，执行的过程类似于 process_spider_output() ，只不过其没有相关联的 Response 并且必须返回 Request。 方法的参数有两个：</p>
                  <ul>
                    <li>start_requests，即包含 Request 的可迭代对象，即 Start Requests</li>
                    <li>spider，即 Spider 对象，即 Start Requests 所属的 Spider</li>
                  </ul>
                  <p>其必须返回另一个包含 Request 对象的可迭代对象。</p>
                  <h3 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h3>
                  <p>本节介绍了 Spider Middleware 的基本原理和自定义 Spider Middleware 的方法。Spider Middleware 使用的频率不如 Downloader Middleware 的高，在必要的情况下它可以用来方便数据的处理。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-04 15:18:30" itemprop="dateCreated datePublished" datetime="2019-12-04T15:18:30+08:00">2019-12-04</time>
                </span>
                <span id="/8385.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.6–Spider Middleware 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8381.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8381.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.5–Downloader Middleware 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-5-Downloader-Middleware-的用法"><a href="#13-5-Downloader-Middleware-的用法" class="headerlink" title="13.5 Downloader Middleware 的用法"></a>13.5 Downloader Middleware 的用法</h1>
                  <p>Downloader Middleware 即下载中间件，它是处于 Scrapy 的 Request 和 Response 之间的处理模块。我们首先来看看它的架构，如图 13-1 所示。 Scheduler 从队列中拿出一个 Request 发送给 Downloader 执行下载，这个过程会经过 Downloader Middleware 的处理。另外，当 Downloader 将 Request 下载完成得到 Response 返回给 Spider 时会再次经过 Downloader Middleware 处理。 也就是说，Downloader Middleware 在整个架构中起作用的位置是以下两个。</p>
                  <ul>
                    <li>在 Scheduler 调度出队列的 Request 发送给 Downloader 下载之前，也就是我们可以在 Request 执行下载之前对其进行修改。</li>
                    <li>在下载后生成的 Response 发送给 Spider 之前，也就是我们可以在生成 Resposne 被 Spider 解析之前对其进行修改。</li>
                  </ul>
                  <p>Downloader Middleware 的功能十分强大，修改 User-Agent、处理重定向、设置代理、失败重试、设置 Cookies 等功能都需要借助它来实现。下面我们来了解一下 Downloader Middleware 的详细用法。</p>
                  <h3 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1. 使用说明"></a>1. 使用说明</h3>
                  <p>需要说明的是，Scrapy 其实已经提供了许多 Downloader Middleware，比如负责失败重试、自动重定向等功能的 Middleware，它们被 DOWNLOADER_MIDDLEWARES_BASE 变量所定义。 DOWNLOADER_MIDDLEWARES_BASE 变量的内容如下所示：</p>
                  <figure class="highlight yaml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware':</span> <span class="number">100</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware':</span> <span class="number">300</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware':</span> <span class="number">350</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware':</span> <span class="number">400</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware':</span> <span class="number">500</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.retry.RetryMiddleware':</span> <span class="number">550</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware':</span> <span class="number">560</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware':</span> <span class="number">580</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware':</span> <span class="number">590</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.redirect.RedirectMiddleware':</span> <span class="number">600</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.cookies.CookiesMiddleware':</span> <span class="number">700</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware':</span> <span class="number">750</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.stats.DownloaderStats':</span> <span class="number">850</span><span class="string">,</span></span><br><span class="line">    <span class="attr">'scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware':</span> <span class="number">900</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这是一个字典格式，字典的键名是 Scrapy 内置的 Downloader Middleware 的名称，键值代表了调用的优先级，优先级是一个数字，数字越小代表越靠近 Scrapy 引擎，数字越大代表越靠近 Downloader。每个 Downloader Middleware 都可以定义 process_request() 和 request_response() 方法来分别处理请求和响应，对于 process_request() 方法来说，优先级数字越小越先被调用，对于 process_response() 方法来说，优先级数字越大越先被调用。。 如果自己定义的 Downloader Middleware 要添加到项目里，DOWNLOADER_MIDDLEWARES_BASE 变量不能直接修改。Scrapy 提供了另外一个设置变量 DOWNLOADER_MIDDLEWARES，我们直接修改这个变量就可以添加自己定义的 Downloader Middleware，以及禁用 DOWNLOADER_MIDDLEWARES_BASE 里面定义的 Downloader Middleware。下面我们具体来看看 Downloader Middleware 的使用方法。</p>
                  <h3 id="2-核心方法"><a href="#2-核心方法" class="headerlink" title="2. 核心方法"></a>2. 核心方法</h3>
                  <p>Scrapy 内置的 Downloader Middleware 为 Scrapy 提供了基础的功能，但在项目实战中我们往往需要单独定义 Downloader Middleware。不用担心，这个过程非常简单，我们只需要实现某几个方法即可。 每个 Downloader Middleware 都定义了一个或多个方法的类，核心的方法有如下三个。</p>
                  <ul>
                    <li>process_request(request, spider)</li>
                    <li>process_response(request, response, spider)</li>
                    <li>process_exception(request, exception, spider)</li>
                  </ul>
                  <p>我们只需要实现至少一个方法，就可以定义一个 Downloader Middleware。下面我们来看看这三个方法的详细用法。</p>
                  <h4 id="process-request-request-spider"><a href="#process-request-request-spider" class="headerlink" title="process_request(request, spider)"></a>process_request(request, spider)</h4>
                  <p>Request 被 Scrapy 引擎调度给 Downloader 之前，process_request() 方法就会被调用，也就是在 Request 从队列里调度出来到 Downloader 下载执行之前，我们都可以用 process_request() 方法对 Request 进行处理。方法的返回值必须为 None、Response 对象、Request 对象之一，或者抛出 IgnoreRequest 异常。 process_request() 方法的参数有如下两个。</p>
                  <ul>
                    <li>request，即 Request 对象，即被处理的 Request</li>
                    <li>spider，即 Spdier 对象，即此 Request 对应的 Spider</li>
                  </ul>
                  <p>返回类型不同，产生的效果也不同。下面归纳一下不同的返回情况。</p>
                  <ul>
                    <li>当返回是 None 时，Scrapy 将继续处理该 Request，接着执行其他 Downloader Middleware 的 process_request() 方法，一直到 Downloader 把 Request 执行后得到 Response 才结束。这个过程其实就是修改 Request 的过程，不同的 Downloader Middleware 按照设置的优先级顺序依次对 Request 进行修改，最后送至 Downloader 执行。</li>
                    <li>当返回为 Response 对象时，更低优先级的 Downloader Middleware 的 process_request() 和 process_exception() 方法就不会被继续调用，每个 Downloader Middleware 的 process_response() 方法转而被依次调用。调用完毕之后，直接将 Response 对象发送给 Spider 来处理。</li>
                    <li>当返回为 Request 对象时，更低优先级的 Downloader Middleware 的 process_request() 方法会停止执行。这个 Request 会重新放到调度队列里，其实它就是一个全新的 Request，等待被调度。如果被 Scheduler 调度了，那么所有的 Downloader Middleware 的 process_request() 方法会被重新按照顺序执行。</li>
                    <li>如果 IgnoreRequest 异常抛出，则所有的 Downloader Middleware 的 process_exception() 方法会依次执行。如果没有一个方法处理这个异常，那么 Request 的 errorback() 方法就会回调。如果该异常还没有被处理，那么它便会被忽略。</li>
                  </ul>
                  <h4 id="process-response-request-response-spider"><a href="#process-response-request-response-spider" class="headerlink" title="process_response(request, response, spider)"></a>process_response(request, response, spider)</h4>
                  <p>Downloader 执行 Request 下载之后，会得到对应的 Response。Scrapy 引擎便会将 Response 发送给 Spider 进行解析。在发送之前，我们都可以用 process_response() 方法来对 Response 进行处理。方法的返回值必须为 Request 对象、Response 对象之一，或者抛出 IgnoreRequest 异常。 process_response() 方法的参数有如下三个。</p>
                  <ul>
                    <li>request，是 Request 对象，即此 Response 对应的 Request。</li>
                    <li>response，是 Response 对象，即此被处理的 Response。</li>
                    <li>spider，是 Spider 对象，即此 Response 对应的 Spider。</li>
                  </ul>
                  <p>下面对不同的返回情况做一下归纳：</p>
                  <ul>
                    <li>当返回为 Request 对象时，更低优先级的 Downloader Middleware 的 process_response() 方法不会继续调用。该 Request 对象会重新放到调度队列里等待被调度，它相当于一个全新的 Request。然后，该 Request 会被 process_request() 方法顺次处理。</li>
                    <li>当返回为 Response 对象时，更低优先级的 Downloader Middleware 的 process_response() 方法会继续调用，继续对该 Response 对象进行处理。</li>
                    <li>如果 IgnoreRequest 异常抛出，则 Request 的 errorback() 方法会回调。如果该异常还没有被处理，那么它便会被忽略。</li>
                  </ul>
                  <h4 id="process-exception-request-exception-spider"><a href="#process-exception-request-exception-spider" class="headerlink" title="process_exception(request, exception, spider)"></a>process_exception(request, exception, spider)</h4>
                  <p>当 Downloader 或 process_request() 方法抛出异常时，例如抛出 IgnoreRequest 异常，process_exception() 方法就会被调用。方法的返回值必须为 None、Response 对象、Request 对象之一。 process_exception() 方法的参数有如下三个。</p>
                  <ul>
                    <li>request，即 Request 对象，即产生异常的 Request</li>
                    <li>exception，即 Exception 对象，即抛出的异常</li>
                    <li>spdier，即 Spider 对象，即 Request 对应的 Spider</li>
                  </ul>
                  <p>下面归纳一下不同的返回值。</p>
                  <ul>
                    <li>当返回为 None 时，更低优先级的 Downloader Middleware 的 process_exception() 会被继续顺次调用，直到所有的方法都被调度完毕。</li>
                    <li>当返回为 Response 对象时，更低优先级的 Downloader Middleware 的 process_exception() 方法不再被继续调用，每个 Downloader Middleware 的 process_response() 方法转而被依次调用。</li>
                    <li>当返回为 Request 对象时，更低优先级的 Downloader Middleware 的 process_exception() 也不再被继续调用，该 Request 对象会重新放到调度队列里面等待被调度，它相当于一个全新的 Request。然后，该 Request 又会被 process_request() 方法顺次处理。</li>
                  </ul>
                  <p>以上内容便是这三个方法的详细使用逻辑。在使用它们之前，请先对这三个方法的返回值的处理情况有一个清晰的认识。在自定义 Downloader Middleware 的时候，也一定要注意每个方法的返回类型。 下面我们用一个案例实战来加深一下对 Downloader Middleware 用法的理解。</p>
                  <h3 id="3-项目实战"><a href="#3-项目实战" class="headerlink" title="3. 项目实战"></a>3. 项目实战</h3>
                  <p>新建一个项目，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject scrapydownloadertest</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>新建了一个 Scrapy 项目，名为 scrapydownloadertest。进入项目，新建一个 Spider，命令如下所示：</p>
                  <figure class="highlight avrasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy genspider httpbin httpbin<span class="meta">.org</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>新建了一个 Spider，名为 httpbin，源代码如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpbinSpider</span>(<span class="title">scrapy</span>.<span class="title">Spider</span>):</span></span><br><span class="line">    name = <span class="string">'httpbin'</span></span><br><span class="line">    allowed_domains = [<span class="string">'httpbin.org'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://httpbin.org/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">        pass</span><br><span class="line"><span class="string">``</span><span class="string">`接下来我们修改 start_urls 为：`</span>[<span class="string">'http://httpbin.org/'</span>]<span class="string">`。随后将 parse() 方法添加一行日志输出，将 response 变量的 text 属性输出出来，这样我们便可以看到 Scrapy 发送的 Request 信息了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">修改 Spider 内容如下所示：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>python</span><br><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpbinSpider</span>(<span class="title">scrapy</span>.<span class="title">Spider</span>):</span></span><br><span class="line">    name = <span class="string">'httpbin'</span></span><br><span class="line">    allowed_domains = [<span class="string">'httpbin.org'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://httpbin.org/get'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.logger.debug(response.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来运行此 Spider，执行如下命令：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl httpbin</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>Scrapy 运行结果包含 Scrapy 发送的 Request 信息，内容如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>, </span><br><span class="line">    <span class="attr">"Accept-Encoding"</span>: <span class="string">"gzip,deflate,br"</span>, </span><br><span class="line">    <span class="attr">"Accept-Language"</span>: <span class="string">"en"</span>, </span><br><span class="line">    <span class="attr">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"Scrapy/1.4.0 (+http://scrapy.org)"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"60.207.237.85"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们观察一下 Headers，Scrapy 发送的 Request 使用的 User-Agent 是 Scrapy/1.4.0(+<a href="http://scrapy.org" target="_blank" rel="noopener">http://scrapy.org)，这其实是由</a>，这其实是由) Scrapy 内置的 UserAgentMiddleware 设置的，UserAgentMiddleware 的源码如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy import signals</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentMiddleware</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, user_agent=<span class="string">'Scrapy'</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.user_agent = user_agent</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        o = cls(crawler.settings[<span class="string">'USER_AGENT'</span>])</span><br><span class="line">        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)</span><br><span class="line">        <span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_opened</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.user_agent = getattr(spider, <span class="string">'user_agent'</span>, <span class="keyword">self</span>.user_agent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(<span class="keyword">self</span>, request, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">user_agent:</span></span><br><span class="line">            request.headers.setdefault(b<span class="string">'User-Agent'</span>, <span class="keyword">self</span>.user_agent)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在 from_crawler() 方法中，首先尝试获取 settings 里面 USER_AGENT，然后把 USER_AGENT 传递给<strong>init</strong>() 方法进行初始化，其参数就是 user_agent。如果没有传递 USER_AGENT 参数就默认设置为 Scrapy 字符串。我们新建的项目没有设置 USER_AGENT，所以这里的 user_agent 变量就是 Scrapy。接下来，在 process_request() 方法中，将 user-agent 变量设置为 headers 变量的一个属性，这样就成功设置了 User-Agent。因此，User-Agent 就是通过此 Downloader Middleware 的 process_request() 方法设置的。 修改请求时的 User-Agent 可以有两种方式：一是修改 settings 里面的 USER_AGENT 变量；二是通过 Downloader Middleware 的 process_request() 方法来修改。 第一种方法非常简单，我们只需要在 setting.py 里面加一行 USER_AGENT 的定义即可：</p>
                  <figure class="highlight lsl">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">USER_AGENT = 'Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_12_6) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">59.0</span><span class="number">.3071</span><span class="number">.115</span> Safari/<span class="number">537.36</span>'</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>一般推荐使用此方法来设置。但是如果想设置得更灵活，比如设置随机的 User-Agent，那就需要借助 Downloader Middleware 了。所以接下来我们用 Downloader Middleware 实现一个随机 User-Agent 的设置。 在 middlewares.py 里面添加一个 RandomUserAgentMiddleware 的类，如下所示：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">RandomUserAgentMiddleware</span>():</span></span><br><span class="line"><span class="class">    def __init__(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        self.user_agents = ['<span class="type">Mozilla</span>/5.0 (<span class="type">Windows</span>; <span class="type">U</span>; <span class="type">MSIE</span> 9.0; <span class="type">Windows</span> <span class="type">NT</span> 9.0; <span class="title">en</span>-<span class="type">US</span>)',</span></span><br><span class="line"><span class="class">            '<span class="type">Mozilla</span>/5.0 (<span class="type">Windows</span> <span class="type">NT</span> 6.1) <span class="type">AppleWebKit</span>/537.2 (<span class="type">KHTML</span>, <span class="title">like</span> <span class="type">Gecko</span>) <span class="type">Chrome</span>/22.0.1216.0 <span class="type">Safari</span>/537.2',</span></span><br><span class="line"><span class="class">            '<span class="type">Mozilla</span>/5.0 (<span class="type">X11</span>; <span class="type">Ubuntu</span>; <span class="type">Linux</span> <span class="title">i686</span>; <span class="title">rv</span>:15.0) <span class="type">Gecko</span>/20100101 <span class="type">Firefox</span>/15.0.1'</span></span><br><span class="line"><span class="class">        ]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    def process_request(<span class="title">self</span>, <span class="title">request</span>, <span class="title">spider</span>):</span></span><br><span class="line"><span class="class">        request.headers['<span class="type">User</span>-<span class="type">Agent'</span>] = random.choice(<span class="title">self</span>.<span class="title">user_agents</span>)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们首先在类的 <strong>init</strong>() 方法中定义了三个不同的 User-Agent，并用一个列表来表示。接下来实现了 process_request() 方法，它有一个参数 request，我们直接修改 request 的属性即可。在这里我们直接设置了 request 对象的 headers 属性的 User-Agent，设置内容是随机选择的 User-Agent，这样一个 Downloader Middleware 就写好了。 不过，要使之生效我们还需要再去调用这个 Downloader Middleware。在 settings.py 中，将 DOWNLOADER_MIDDLEWARES 取消注释，并设置成如下内容：</p>
                  <figure class="highlight ini">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">DOWNLOADER_MIDDLEWARES</span> = &#123;<span class="string">'scrapydownloadertest.middlewares.RandomUserAgentMiddleware'</span>: <span class="number">543</span>,&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来我们重新运行 Spider，就可以看到 User-Agent 被成功修改为列表中所定义的随机的一个 User-Agent 了：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>, </span><br><span class="line">    <span class="attr">"Accept-Encoding"</span>: <span class="string">"gzip,deflate,br"</span>, </span><br><span class="line">    <span class="attr">"Accept-Language"</span>: <span class="string">"en"</span>, </span><br><span class="line">    <span class="attr">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"60.207.237.85"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们就通过实现 Downloader Middleware 并利用 process_request() 方法成功设置了随机的 User-Agent。 另外，Downloader Middleware 还有 process_response() 方法。Downloader 对 Request 执行下载之后会得到 Response，随后 Scrapy 引擎会将 Response 发送回 Spider 进行处理。但是在 Response 被发送给 Spider 之前，我们同样可以使用 process_response() 方法对 Response 进行处理。比如这里修改一下 Response 的状态码，在 RandomUserAgentMiddleware 添加如下代码：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(<span class="keyword">self</span>, request, response, spider)</span></span><span class="symbol">:</span></span><br><span class="line">    response.status = <span class="number">201</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们将 response 对象的 status 属性修改为 201，随后将 response 返回，这个被修改后的 Response 就会被发送到 Spider。 我们再在 Spider 里面输出修改后的状态码，在 parse() 方法中添加如下的输出语句：</p>
                  <figure class="highlight gauss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">self.logger.<span class="keyword">debug</span>('Status <span class="built_in">Code</span>: ' + <span class="built_in">str</span>(response.status))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>重新运行之后，控制台输出了如下内容：</p>
                  <figure class="highlight gauss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[httpbin] <span class="keyword">DEBUG</span>: Status <span class="built_in">Code</span>: <span class="number">201</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，Response 的状态码成功修改了。 因此要想对 Response 进行后处理，就可以借助于 process_response() 方法。 另外还有一个 process_exception() 方法，它是用来处理异常的方法。如果需要异常处理的话，我们可以调用此方法。不过这个方法的使用频率相对低一些，在此不用实例演示。</p>
                  <h3 id="4-本节代码"><a href="#4-本节代码" class="headerlink" title="4. 本节代码"></a>4. 本节代码</h3>
                  <p>本节源代码为：<a href="https://github.com/Python3WebSpider/ScrapyDownloaderTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyDownloaderTest</a>。</p>
                  <h3 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h3>
                  <p>本节讲解了 Downloader Middleware 的基本用法。此组件非常重要，是做异常处理和应对反爬处理的核心。后面我们会在实战中应用此组件来处理代理、Cookies 等内容。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-04 15:11:33" itemprop="dateCreated datePublished" datetime="2019-12-04T15:11:33+08:00">2019-12-04</time>
                </span>
                <span id="/8381.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.5–Downloader Middleware 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>9.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>9 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8364.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8364.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.1–Scrapy 框架介绍</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-1-Scrapy-框架介绍"><a href="#13-1-Scrapy-框架介绍" class="headerlink" title="13.1 Scrapy 框架介绍"></a>13.1 Scrapy 框架介绍</h1>
                  <p>Scrapy 是一个基于 Twisted 的异步处理框架，是纯 Python 实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。我们只需要定制开发几个模块就可以轻松实现一个爬虫。</p>
                  <h3 id="1-架构介绍"><a href="#1-架构介绍" class="headerlink" title="1. 架构介绍"></a>1. 架构介绍</h3>
                  <p>首先我们来看下 Scrapy 框架的架构，如图 13-1 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-033839.jpg" alt=""> 图 13-1 Scrapy 架构 它可以分为如下的几个部分。</p>
                  <ul>
                    <li>Engine，引擎，用来处理整个系统的数据流处理，触发事务，是整个框架的核心。</li>
                    <li>Item，项目，它定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。</li>
                    <li>Scheduler， 调度器，用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。</li>
                    <li>Downloader，下载器，用于下载网页内容，并将网页内容返回给蜘蛛。</li>
                    <li>Spiders，蜘蛛，其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。</li>
                    <li>Item Pipeline，项目管道，负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。</li>
                    <li>Downloader Middlewares，下载器中间件，位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。</li>
                    <li>Spider Middlewares， 蜘蛛中间件，位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。</li>
                  </ul>
                  <h3 id="2-数据流"><a href="#2-数据流" class="headerlink" title="2. 数据流"></a>2. 数据流</h3>
                  <p>Scrapy 中的数据流由引擎控制，其过程如下:</p>
                  <ul>
                    <li>Engine 首先打开一个网站，找到处理该网站的 Spider 并向该 Spider 请求第一个要爬取的 URL。</li>
                    <li>Engine 从 Spider 中获取到第一个要爬取的 URL 并通过 Scheduler 以 Request 的形式调度。</li>
                    <li>Engine 向 Scheduler 请求下一个要爬取的 URL。</li>
                    <li>Scheduler 返回下一个要爬取的 URL 给 Engine，Engine 将 URL 通过 Downloader Middlewares 转发给 Downloader 下载。</li>
                    <li>一旦页面下载完毕， Downloader 生成一个该页面的 Response，并将其通过 Downloader Middlewares 发送给 Engine。</li>
                    <li>Engine 从下载器中接收到 Response 并通过 Spider Middlewares 发送给 Spider 处理。</li>
                    <li>Spider 处理 Response 并返回爬取到的 Item 及新的 Request 给 Engine。</li>
                    <li>Engine 将 Spider 返回的 Item 给 Item Pipeline，将新的 Request 给 Scheduler。</li>
                    <li>重复第二步到最后一步，直到 Scheduler 中没有更多的 Request，Engine 关闭该网站，爬取结束。</li>
                  </ul>
                  <p>通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，Scrapy 最大限度地利用了网络带宽，大大提高了数据爬取和处理的效率。</p>
                  <h3 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h3>
                  <p>Scrapy 框架和 pyspider 不同，它是通过命令行来创建项目的，代码的编写还是需要 IDE。项目创建之后，项目文件结构如下所示：</p>
                  <figure class="highlight stylus">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy.cfg</span><br><span class="line">project/</span><br><span class="line">    __init__.py</span><br><span class="line">    items.py</span><br><span class="line">    pipelines.py</span><br><span class="line">    settings.py</span><br><span class="line">    middlewares.py</span><br><span class="line">    spiders/</span><br><span class="line">        __init__.py</span><br><span class="line">        spider1.py</span><br><span class="line">        spider2.py</span><br><span class="line">        ...</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在此要将各个文件的功能描述如下：</p>
                  <ul>
                    <li>scrapy.cfg：它是 Scrapy 项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。</li>
                    <li>items.py：它定义 Item 数据结构，所有的 Item 的定义都可以放这里。</li>
                    <li>pipelines.py：它定义 Item Pipeline 的实现，所有的 Item Pipeline 的实现都可以放这里。</li>
                    <li>settings.py：它定义项目的全局配置。</li>
                    <li>middlewares.py：它定义 Spider Middlewares 和 Downloader Middlewares 的实现。</li>
                    <li>spiders：其内包含一个个 Spider 的实现，每个 Spider 都有一个文件。</li>
                  </ul>
                  <h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h3>
                  <p>本节介绍了 Scrapy 框架的基本架构、数据流过程以及项目结构。后面我们会详细了解 Scrapy 的用法，感受它的强大。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-03 11:42:17" itemprop="dateCreated datePublished" datetime="2019-12-03T11:42:17+08:00">2019-12-03</time>
                </span>
                <span id="/8364.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.1–Scrapy 框架介绍" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8361.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8361.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 9.4–ADSL 拨号代理</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="9-4-ADSL-拨号代理"><a href="#9-4-ADSL-拨号代理" class="headerlink" title="9.4 ADSL 拨号代理"></a>9.4 ADSL 拨号代理</h1>
                  <p>我们尝试维护过一个代理池。代理池可以挑选出许多可用代理，但是常常其稳定性不高、响应速度慢，而且这些代理通常是公共代理，可能不止一人同时使用，其 IP 被封的概率很大。另外，这些代理可能有效时间比较短，虽然代理池一直在筛选，但如果没有及时更新状态，也有可能获取到不可用的代理。 如果要追求更加稳定的代理，就需要购买专有代理或者自己搭建代理服务器。但是服务器一般都是固定的 IP，我们总不能搭建 100 个代理就用 100 台服务器吧，这显然是不现实的。 所以，ADSL 动态拨号主机就派上用场了。下面我们来了解一下 ADSL 拨号代理服务器的相关设置。</p>
                  <h3 id="1-什么是-ADSL"><a href="#1-什么是-ADSL" class="headerlink" title="1. 什么是 ADSL"></a>1. 什么是 ADSL</h3>
                  <p>ADSL（Asymmetric Digital Subscriber Line，非对称数字用户环路），它的上行和下行带宽不对称，它采用频分复用技术把普通的电话线分成了电话、上行和下行 3 个相对独立的信道，从而避免了相互之间的干扰。 ADSL 通过拨号的方式上网，需要输入 ADSL 账号和密码，每次拨号就更换一个 IP。IP 分布在多个 A 段，如果 IP 都能使用，则意味着 IP 量级可达千万。如果我们将 ADSL 主机作为代理，每隔一段时间主机拨号就换一个 IP，这样可以有效防止 IP 被封禁。另外，主机的稳定性很好，代理响应速度很快。</p>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>首先需要成功安装 Redis 数据库并启动服务，另外还需要安装 requests、redis-py、Tornado 库。如果没有安装，读者可以参考第一章的安装说明。</p>
                  <h3 id="3-购买主机"><a href="#3-购买主机" class="headerlink" title="3. 购买主机"></a>3. 购买主机</h3>
                  <p>我们先购买一台动态拨号 VPS 主机，这样的主机服务商相当多。在这里使用了云立方，官方网站：<a href="http://www.yunlifang.cn/dynamicvps.asp" target="_blank" rel="noopener">http://www.yunlifang.cn/dynamicvps.asp</a>。 建议选择电信线路。可以自行选择主机配置，主要考虑带宽是否满足需求。 然后进入拨号主机的后台，预装一个操作系统，如图 9-10 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052822.jpg" alt=""> 图 9-10 预装操作系统 推荐安装 CentOS 7 系统。 然后找到远程管理面板  远程连接的用户名和密码，也就是 SSH 远程连接服务器的信息。比如我使用的 IP 和端口是 153.36.65.214:20063，用户名是 root。命令行下输入如下内容：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ssh <span class="symbol">root@</span><span class="number">153.36</span><span class="number">.65</span><span class="number">.214</span> -p <span class="number">20063</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输入管理密码，就可以连接上远程服务器了。 进入之后，我们发现一个可用的脚本文件 ppp.sh，这是拨号初始化的脚本。运行此脚本会提示输入拨号的用户名和密码，然后它就开始各种拨号配置。一次配置成功，后面拨号就不需要重复输入用户名和密码。 运行 ppp.sh 脚本，输入用户名、密码等待它的配置完成，如图 9-11 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052827.jpg" alt=""> 图 9-11 配置页面 提示成功之后就可以进行拨号了。注意，在拨号之前测试 ping 任何网站都是不通的，因为当前网络还没联通。输入如下拨号命令：</p>
                  <figure class="highlight crmsh">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">adsl-<span class="literal">start</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>拨号命令成功运行，没有报错信息，耗时约几秒。接下来再去 ping 外网就可以通了。 如果要停止拨号，可以输入如下命令：</p>
                  <figure class="highlight arduino">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">adsl-<span class="built_in">stop</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>之后，可以发现又连不通网络了，如图 9-12 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052841.jpg" alt=""> 图 9-12 拨号建立连接 断线重播的命令就是二者组合起来，先执行 adsl-stop，再执行 adsl-start。每次拨号，ifconfig 命令观察主机的 IP，发现主机的 IP 一直在变化，网卡名称叫作 ppp0，如图 9-13 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052851.jpg" alt=""> 图 9-13 网络设备信息 接下来，我们要做两件事：一是怎样将主机设置为代理服务器，二是怎样实时获取拨号主机的 IP。</p>
                  <h3 id="4-设置代理服务器"><a href="#4-设置代理服务器" class="headerlink" title="4. 设置代理服务器"></a>4. 设置代理服务器</h3>
                  <p>在 Linux 下搭建 HTTP 代理服务器，推荐 TinyProxy 和 Squid，配置都非常简单。在这里我们以 TinyProxy 为例来讲解一下怎样搭建代理服务器。</p>
                  <h4 id="安装-TinyProxy"><a href="#安装-TinyProxy" class="headerlink" title="安装 TinyProxy"></a>安装 TinyProxy</h4>
                  <p>第一步就是安装 TinyProxy 软件。在这里我使用的系统是 CentOS，所以使用 yum 来安装。如果是其他系统，如 Ubuntu，可以选择 apt-get 等命令安装。 命令行执行 yum 安装指令：</p>
                  <figure class="highlight sql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">yum <span class="keyword">install</span> -y epel-<span class="keyword">release</span></span><br><span class="line">yum <span class="keyword">update</span> -y</span><br><span class="line">yum <span class="keyword">install</span> -y tinyproxy</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行完成之后就可以完成 tinyproxy 的安装了。</p>
                  <h4 id="配置-TinyProxy"><a href="#配置-TinyProxy" class="headerlink" title="配置 TinyProxy"></a>配置 TinyProxy</h4>
                  <p>TinyProxy 安装完成之后还要配置一下才可以用作代理服务器。我们需要编辑配置文件，此文件一般的路径是 /etc/tinyproxy/tinyproxy.conf。 可以看到有一行</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Port <span class="number">8888</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里可以设置代理的端口，默认是 8888。 继续向下找到如下代码：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Allow <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这行代码表示被允许连接的主机 IP。如果希望连接任何主机，那就直接将这行代码注释即可。在这里我们选择直接注释，也就是任何主机都可以使用这台主机作为代理服务器。 修改为如下代码：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"># Allow <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>设置完成之后重启 TinyProxy 即可：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">enable</span> <span class="selector-tag">tinyproxy</span><span class="selector-class">.service</span></span><br><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">tinyproxy</span><span class="selector-class">.service</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>防火墙开放该端口：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">iptables -I <span class="keyword">INPUT</span> -p tcp <span class="comment">--dport 8888 -j ACCEPT</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然如果想直接关闭防火墙也可以：</p>
                  <figure class="highlight arduino">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">systemctl <span class="built_in">stop</span> firewalld.service</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就完成了 TinyProxy 的配置了。</p>
                  <h4 id="验证-TinyProxy"><a href="#验证-TinyProxy" class="headerlink" title="验证 TinyProxy"></a>验证 TinyProxy</h4>
                  <p>首先，用 ifconfig 查看当前主机的 IP。比如，当前我的主机拨号 IP 为 112.84.118.216，在其他的主机运行测试一下。 用 curl 命令设置代理请求 httpbin，检测代理是否生效。</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl -x <span class="number">112.84</span><span class="number">.118</span><span class="number">.216</span>:<span class="number">8888</span> httpbin.org/<span class="keyword">get</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如图 9-14 所示： <img src="https://cdn.cuiqingcai.com/2019-10-20-052902.jpg" alt=""> 图 9-14 运行结果 如果有正常的结果输出，并且 origin 的值为代理 IP 的地址，就证明 TinyProxy 配置成功了。</p>
                  <h3 id="5-动态获取-IP"><a href="#5-动态获取-IP" class="headerlink" title="5. 动态获取 IP"></a>5. 动态获取 IP</h3>
                  <p>现在可以执行命令让主机动态切换 IP，也在主机上搭建了代理服务器。我们只需要知道拨号后的 IP 就可以使用代理。 我们考虑到，在一台主机拨号切换 IP 的间隙代理是不可用的，在这拨号的几秒时间内如果有第二台主机顶替第一台主机，那就可以解决拨号间隙代理无法使用的问题了。所以我们要设计的架构必须要考虑支持多主机的问题。 假如有 10 台拨号主机同时需要维护，而爬虫需要使用这 10 台主机的代理，那么在爬虫端维护的开销是非常大的。如果爬虫在不同的机器上运行，那么每个爬虫必须要获得这 10 台拨号主机的配置，这显然是不理想的。 为了更加方便地使用代理，我们可以像上文的代理池一样定义一个统一的代理接口，爬虫端只需要配置代理接口即可获取可用代理。要搭建一个接口，就势必需要一台服务器，而接口的数据从哪里获得呢，当然最理想的还是选择数据库。 比如我们需要同时维护 10 台拨号主机，每台拨号主机都会定时拨号，那这样每台主机在某个时刻可用的代理只有一个，所以我们没有必要存储之前的拨号代理，因为重新拨号之后之前的代理已经不能用了，所以只需要将之前的代理更新其内容就好了。数据库要做的就是定时对每台主机的代理进行更新，而更新时又需要拨号主机的唯一标识，根据主机标识查出这条数据，然后将这条数据对应的代理更新。 所以数据库端就需要存储一个主机标识到代理的映射关系。那么很自然地我们就会想到关系型数据库，如 MySQL 或者 Redis 的 Hash 存储，只需存储一个映射关系，不需要很多字段，而且 Redis 比 MySQL 效率更高、使用更方便，所以最终选定的存储方式就是 Redis 的 Hash。</p>
                  <h3 id="6-存储模块"><a href="#6-存储模块" class="headerlink" title="6. 存储模块"></a>6. 存储模块</h3>
                  <p>那么接下来我们要做可被远程访问的 Redis 数据库，各个拨号机器只需要将各自的主机标识和当前 IP 和端口（也就是代理）发送给数据库就好了。 先定义一个操作 Redis 数据库的类，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 数据库 IP</span></span><br><span class="line">REDIS_HOST = <span class="string">'remoteaddress'</span></span><br><span class="line"><span class="comment"># Redis 数据库密码，如无则填 None</span></span><br><span class="line">REDIS_PASSWORD = <span class="string">'foobared'</span></span><br><span class="line"><span class="comment"># Redis 数据库端口</span></span><br><span class="line">REDIS_PORT = <span class="number">6379</span></span><br><span class="line"><span class="comment"># 代理池键名</span></span><br><span class="line">PROXY_KEY = <span class="string">'adsl'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD, proxy_key=PROXY_KEY)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化 Redis 连接</span></span><br><span class="line"><span class="string">        :param host: Redis 地址</span></span><br><span class="line"><span class="string">        :param port: Redis 端口</span></span><br><span class="line"><span class="string">        :param password: Redis 密码</span></span><br><span class="line"><span class="string">        :param proxy_key: Redis 哈希表名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.db = redis.StrictRedis(host=host, port=port, password=password, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.proxy_key = proxy_key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, name, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        设置代理</span></span><br><span class="line"><span class="string">        :param name: 主机名称</span></span><br><span class="line"><span class="string">        :param proxy: 代理</span></span><br><span class="line"><span class="string">        :return: 设置结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hset(self.proxy_key, name, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取代理</span></span><br><span class="line"><span class="string">        :param name: 主机名称</span></span><br><span class="line"><span class="string">        :return: 代理</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hget(self.proxy_key, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取代理总数</span></span><br><span class="line"><span class="string">        :return: 代理总数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hlen(self.proxy_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除代理</span></span><br><span class="line"><span class="string">        :param name: 主机名称</span></span><br><span class="line"><span class="string">        :return: 删除结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hdel(self.proxy_key, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">names</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取主机名称列表</span></span><br><span class="line"><span class="string">        :return: 获取主机名称列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hkeys(self.proxy_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proxies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取代理列表</span></span><br><span class="line"><span class="string">        :return: 代理列表</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.db.hvals(self.proxy_key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        随机获取代理</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        proxies = self.proxies()</span><br><span class="line">        <span class="keyword">return</span> random.choice(proxies)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取字典</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span><span class="keyword">return</span> self.db.hgetall(self.proxy_key)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了一个 RedisClient 类，在<strong>init</strong>() 方法中初始化了 Redis 连接，其中 REDIS_HOST 就是远程 Redis 的地址，REDIS_PASSWORD 是密码，REDIS_PORT 是端口，PROXY_KEY 是存储代理的散列表的键名。 接下来定义了一个 set() 方法，这个方法用来向散列表添加映射关系。映射是从主机标识到代理的映射，比如一台主机的标识为 adsl1，当前的代理为 118.119.111.172:8888，那么散列表中就会存储一个 key 为 adsl1、value 为 118.119.111.172:8888 的映射，Hash 结构如图 9-15 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052948.jpg" alt=""> 图 9-15 Hash 结构 如果有多台主机，只需要向 Hash 中添加映射即可。 另外，get() 方法就是从散列表中取出某台主机对应的代理。remove() 方法则是从散列表中移除对应的主机的代理。还有 names()、proxies()、all() 方法则是分别获取散列表中的主机列表、代理列表及所有主机代理映射。count() 方法则是返回当前散列表的大小，也就是可用代理的数目。 最后还有一个比较重要的方法 random()，它随机从散列表中取出一个可用代理，类似前面代理池的思想，确保每个代理都能被取到。 如果要对数据库进行操作，只需要初始化 RedisClient 对象，然后调用它的 set() 或者 remove() 方法，即可对散列表进行设置和删除。</p>
                  <h3 id="7-拨号模块"><a href="#7-拨号模块" class="headerlink" title="7. 拨号模块"></a>7. 拨号模块</h3>
                  <p>接下来要做的就是拨号，并把新的 IP 保存到 Redis 散列表里。 首先是拨号定时，它分为定时拨号和非定时拨号两种选择。 非定时拨号：最好的方法就是向该主机发送一个信号，然后主机就启动拨号，但这样做的话，我们首先要搭建一个重新拨号的接口，如搭建一个 Web 接口，请求该接口即进行拨号，但开始拨号之后，此时主机的状态就从在线转为离线，而此时的 Web 接口也就相应失效了，拨号过程无法再连接，拨号之后接口的 IP 也变了，所以我们无法通过接口来方便地控制拨号过程和获取拨号结果，下次拨号还得改变拨号请求接口，所以非定时拨号的开销还是比较大的。 定时拨号：我们只需要在拨号主机上运行定时脚本即可，每隔一段时间拨号一次，更新 IP，然后将 IP 在 Redis 散列表中更新即可，非常简单易用，另外可以适当将拨号频率调高一点，减少短时间内 IP 被封的可能性。 在这里选择定时拨号。 接下来就是获取 IP。获取拨号后的 IP 非常简单，只需要调用 ifconfig 命令，然后解析出对应网卡的 IP 即可。 获取了 IP 之后，我们还需要进行有效性检测。拨号主机可以自己检测，比如可以利用 requests 设置自身的代理请求外网，如果成功，那么证明代理可用，然后再修改 Redis 散列表，更新代理。 需要注意，由于在拨号的间隙拨号主机是离线状态，而此时 Redis 散列表中还存留了上次的代理，一旦这个代理被取用了，该代理是无法使用的。为了避免这个情况，每台主机在拨号之前还需要将自身的代理从 Redis 散列表中移除。 这样基本的流程就理顺了，我们用如下代码实现：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions import ConnectionError, ReadTimeout</span><br><span class="line"><span class="keyword">from</span> db import RedisClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拨号网卡</span></span><br><span class="line">ADSL_IFNAME = <span class="string">'ppp0'</span></span><br><span class="line"><span class="comment"># 测试 URL</span></span><br><span class="line">TEST_URL = <span class="string">'http://www.baidu.com'</span></span><br><span class="line"><span class="comment"># 测试超时时间</span></span><br><span class="line">TEST_TIMEOUT = 20</span><br><span class="line"><span class="comment"># 拨号间隔</span></span><br><span class="line">ADSL_CYCLE = 100</span><br><span class="line"><span class="comment"># 拨号出错重试间隔</span></span><br><span class="line">ADSL_ERROR_CYCLE = 5</span><br><span class="line"><span class="comment"># ADSL 命令</span></span><br><span class="line">ADSL_BASH = <span class="string">'adsl-stop;adsl-start'</span></span><br><span class="line"><span class="comment"># 代理运行端口</span></span><br><span class="line">PROXY_PORT = 8888</span><br><span class="line"><span class="comment"># 客户端唯一标识</span></span><br><span class="line">CLIENT_NAME = <span class="string">'adsl1'</span></span><br><span class="line"></span><br><span class="line">class Sender():</span><br><span class="line">    def get_ip(self, <span class="attribute">ifname</span>=ADSL_IFNAME):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        获取本机 IP</span></span><br><span class="line"><span class="string">        :param ifname: 网卡名称</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        (status, output) = subprocess.getstatusoutput(<span class="string">'ifconfig'</span>)</span><br><span class="line">        <span class="keyword">if</span> status == 0:</span><br><span class="line">            pattern = re.compile(ifname + <span class="string">'.*?inet.*?(d+.d+.d+.d+).*?netmask'</span>, re.S)</span><br><span class="line">            result = re.search(pattern, output)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">               <span class="built_in"> ip </span>= result.group(1)</span><br><span class="line">                return ip</span><br><span class="line"></span><br><span class="line">    def test_proxy(self, proxy):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        测试代理</span></span><br><span class="line"><span class="string">        :param proxy: 代理</span></span><br><span class="line"><span class="string">        :return: 测试结果</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        try:</span><br><span class="line">            response = requests.<span class="builtin-name">get</span>(TEST_URL, proxies=&#123;</span><br><span class="line">                <span class="string">'http'</span>: <span class="string">'http://'</span> + proxy,</span><br><span class="line">                <span class="string">'https'</span>: <span class="string">'https://'</span> + proxy</span><br><span class="line">            &#125;, <span class="attribute">timeout</span>=TEST_TIMEOUT)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == 200:</span><br><span class="line">                return <span class="literal">True</span></span><br><span class="line">        except (ConnectionError, ReadTimeout):</span><br><span class="line">            return <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    def remove_proxy(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        移除代理</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        self.redis = RedisClient()</span><br><span class="line">        self.redis.<span class="builtin-name">remove</span>(CLIENT_NAME)</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="string">'Successfully Removed Proxy'</span>)</span><br><span class="line"></span><br><span class="line">    def set_proxy(self, proxy):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        设置代理</span></span><br><span class="line"><span class="string">        :param proxy: 代理</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        self.redis = RedisClient()</span><br><span class="line">        <span class="keyword">if</span> self.redis.<span class="builtin-name">set</span>(CLIENT_NAME, proxy):</span><br><span class="line">            <span class="builtin-name">print</span>(<span class="string">'Successfully Set Proxy'</span>, proxy)</span><br><span class="line"></span><br><span class="line">    def adsl(self):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        拨号主进程</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="builtin-name">print</span>(<span class="string">'ADSL Start, Remove Proxy, Please wait'</span>)</span><br><span class="line">            self.remove_proxy()</span><br><span class="line">            (status, output) = subprocess.getstatusoutput(ADSL_BASH)</span><br><span class="line">            <span class="keyword">if</span> status == 0:</span><br><span class="line">                <span class="builtin-name">print</span>(<span class="string">'ADSL Successfully'</span>)</span><br><span class="line">               <span class="built_in"> ip </span>= self.get_ip()</span><br><span class="line">                <span class="keyword">if</span> ip:</span><br><span class="line">                    <span class="builtin-name">print</span>(<span class="string">'Now IP'</span>, ip)</span><br><span class="line">                    <span class="builtin-name">print</span>(<span class="string">'Testing Proxy, Please Wait'</span>)</span><br><span class="line">                   <span class="built_in"> proxy </span>= <span class="string">'&#123;ip&#125;:&#123;port&#125;'</span>.format(<span class="attribute">ip</span>=ip, <span class="attribute">port</span>=PROXY_PORT)</span><br><span class="line">                    <span class="keyword">if</span> self.test_proxy(proxy):</span><br><span class="line">                        <span class="builtin-name">print</span>(<span class="string">'Valid Proxy'</span>)</span><br><span class="line">                        self.set_proxy(proxy)</span><br><span class="line">                        <span class="builtin-name">print</span>(<span class="string">'Sleeping'</span>)</span><br><span class="line">                        time.sleep(ADSL_CYCLE)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="builtin-name">print</span>(<span class="string">'Invalid Proxy'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="builtin-name">print</span>(<span class="string">'Get IP Failed, Re Dialing'</span>)</span><br><span class="line">                    time.sleep(ADSL_ERROR_CYCLE)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="builtin-name">print</span>(<span class="string">'ADSL Failed, Please Check'</span>)</span><br><span class="line">                time.sleep(ADSL_ERROR_CYCLE)</span><br><span class="line">def <span class="builtin-name">run</span>():</span><br><span class="line">    sender = Sender()</span><br><span class="line">    sender.adsl()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里定义了一个 Sender 类，它的主要作用是执行定时拨号，并将新的 IP 测试通过之后更新到远程 Redis 散列表里。 主方法是 adsl() 方法，它首先是一个无限循环，循环体内就是拨号的逻辑。 adsl() 方法首先调用了 remove_proxy() 方法，将远程 Redis 散列表中本机对应的代理移除，避免拨号时本主机的残留代理被取到。 接下来利用 subprocess 模块来执行拨号脚本，拨号脚本很简单，就是 stop 之后再 start，这里将拨号的命令直接定义成了 ADSL_BASH。 随后程序又调用 get_ip() 方法，通过 subprocess 模块执行获取 IP 的命令 ifconfig，然后根据网卡名称获取了当前拨号网卡的 IP 地址，即拨号后的 IP。 再接下来就需要测试代理有效性了。程序首先调用了 test_proxy() 方法，将自身的代理设置好，使用 requests 库来用代理连接 TEST_URL。在此 TEST_URL 设置为百度，如果请求成功，则证明代理有效。 如果代理有效，再调用 set_proxy() 方法将 Redis 散列表中本机对应的代理更新，设置时需要指定本机唯一标识和本机当前代理。本机唯一标识可随意配置，其对应的变量为 CLIENT_NAME，保证各台拨号主机不冲突即可。本机当前代理则由拨号后的新 IP 加端口组合而成。通过调用 RedisClient 的 set() 方法，参数 name 为本机唯一标识，proxy 为拨号后的新代理，执行之后便可以更新散列表中的本机代理了。 建议至少配置两台主机，这样在一台主机的拨号间隙还有另一台主机的代理可用。拨号主机的数量不限，越多越好。 在拨号主机上执行拨号脚本，示例输出如图 9-16 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-052912.jpg" alt=""> 图 9-16 示例输出 首先移除了代理，再进行拨号，拨号完成之后获取新的 IP，代理检测成功之后就设置到 Redis 散列表中，然后等待一段时间再重新进行拨号。 我们添加了多台拨号主机，这样就有多个稳定的定时更新的代理可用了。Redis 散列表会实时更新各台拨号主机的代理，如图 9-17 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-053042.jpg" alt=""> 图 9-17 Hash 结构 图中所示是四台 ADSL 拨号主机配置并运行后的散列表的内容，表中的代理都是可用的。</p>
                  <h3 id="8-接口模块"><a href="#8-接口模块" class="headerlink" title="8. 接口模块"></a>8. 接口模块</h3>
                  <p>目前为止，我们已经成功实时更新拨号主机的代理。不过还缺少一个模块，那就是接口模块。像之前的代理池一样，我们也定义一些接口来获取代理，如 random 获取随机代理、count 获取代理个数等。 我们选用 Tornado 来实现，利用 Tornado 的 Server 模块搭建 Web 接口服务，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler, Application</span><br><span class="line"></span><br><span class="line"><span class="comment"># API 端口</span></span><br><span class="line">API_PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, redis)</span>:</span></span><br><span class="line">        self.redis = redis</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, api=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> api:</span><br><span class="line">            links = [<span class="string">'random'</span>, <span class="string">'proxies'</span>, <span class="string">'names'</span>, <span class="string">'all'</span>, <span class="string">'count'</span>]</span><br><span class="line">            self.write(<span class="string">'&lt;h4&gt;Welcome to ADSL Proxy API&lt;/h4&gt;'</span>)</span><br><span class="line">            <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">                self.write(<span class="string">'&lt;a href='</span> + link + <span class="string">'&gt;'</span> + link + <span class="string">'&lt;/a&gt;&lt;br&gt;'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> api == <span class="string">'random'</span>:</span><br><span class="line">            result = self.redis.random()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                self.write(result)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> api == <span class="string">'names'</span>:</span><br><span class="line">            result = self.redis.names()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                self.write(json.dumps(result))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> api == <span class="string">'proxies'</span>:</span><br><span class="line">            result = self.redis.proxies()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                self.write(json.dumps(result))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> api == <span class="string">'all'</span>:</span><br><span class="line">            result = self.redis.all()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                self.write(json.dumps(result))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> api == <span class="string">'count'</span>:</span><br><span class="line">            self.write(str(self.redis.count()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(redis, port=API_PORT, address=<span class="string">''</span>)</span>:</span></span><br><span class="line">    application = Application([(<span class="string">r'/'</span>, MainHandler, dict(redis=redis)),</span><br><span class="line">        (<span class="string">r'/(.*)'</span>, MainHandler, dict(redis=redis)),</span><br><span class="line">    ])</span><br><span class="line">    application.listen(port, address=address)</span><br><span class="line">    print(<span class="string">'ADSL API Listening on'</span>, port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了 5 个接口，random 获取随机代理，names 获取主机列表，proxies 获取代理列表，all 获取代理映射，count 获取代理数量。 程序启动之后便会在 API_PORT 端口上运行 Web 服务，主页面如图 9-18 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-053047.jpg" alt=""> 图 9-18 主页面 访问 proxies 接口可以获得所有代理列表，如图 9-19 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-053052.jpg" alt=""> 图 9-19 代理列表 访问 random 接口可以获取随机可用代理，如图 9-20 所示。 <img src="https://cdn.cuiqingcai.com/2019-10-20-053057.jpg" alt=""> 图 9-20 随机代理 我们只需将接口部署到服务器上，即可通过 Web 接口获取可用代理，获取方式和代理池类似。</p>
                  <h3 id="9-本节代码"><a href="#9-本节代码" class="headerlink" title="9. 本节代码"></a>9. 本节代码</h3>
                  <p>本节代码地址为：<a href="https://github.com/Python3WebSpider/AdslProxy" target="_blank" rel="noopener">https://github.com/Python3WebSpider/AdslProxy</a>。</p>
                  <h3 id="10-结语"><a href="#10-结语" class="headerlink" title="10. 结语"></a>10. 结语</h3>
                  <p>本节介绍了 ADSL 拨号代理的搭建过程。通过这种代理，我们可以无限次更换 IP，而且线路非常稳定，抓取效果好很多。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-03 11:07:04" itemprop="dateCreated datePublished" datetime="2019-12-03T11:07:04+08:00">2019-12-03</time>
                </span>
                <span id="/8361.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 9.4–ADSL 拨号代理" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>10k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>9 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8353.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8353.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.4–Spider 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-4-Spider-的用法"><a href="#13-4-Spider-的用法" class="headerlink" title="13.4 Spider 的用法"></a>13.4 Spider 的用法</h1>
                  <p>在 Scrapy 中，要抓取网站的链接配置、抓取逻辑、解析逻辑里其实都是在 Spider 中配置的。在前一节实例中，我们发现抓取逻辑也是在 Spider 中完成的。本节我们就来专门了解一下 Spider 的基本用法。</p>
                  <h3 id="1-Spider-运行流程"><a href="#1-Spider-运行流程" class="headerlink" title="1. Spider 运行流程"></a>1. Spider 运行流程</h3>
                  <p>在实现 Scrapy 爬虫项目时，最核心的类便是 Spider 类了，它定义了如何爬取某个网站的流程和解析方式。简单来讲，Spider 要做的事就是如下两件。</p>
                  <ul>
                    <li>定义爬取网站的动作</li>
                    <li>分析爬取下来的网页</li>
                  </ul>
                  <p>对于 Spider 类来说，整个爬取循环如下所述。</p>
                  <ul>
                    <li>以初始的 URL 初始化 Request，并设置回调函数。 当该 Request 成功请求并返回时，将生成 Response，并作为参数传给该回调函数。</li>
                    <li>在回调函数内分析返回的网页内容。返回结果可以有两种形式，一种是解析到的有效结果返回字典或 Item 对象。下一步可经过处理后（或直接）保存，另一种是解析得下一个（如下一页）链接，可以利用此链接构造 Request 并设置新的回调函数，返回 Request。</li>
                    <li>如果返回的是字典或 Item 对象，可通过 Feed Exports 等形式存入到文件，如果设置了 Pipeline 的话，可以经由 Pipeline 处理（如过滤、修正等）并保存。</li>
                    <li>如果返回的是 Reqeust，那么 Request 执行成功得到 Response 之后会再次传递给 Request 中定义的回调函数，可以再次使用选择器来分析新得到的网页内容，并根据分析的数据生成 Item。</li>
                  </ul>
                  <p>通过以上几步循环往复进行，便完成了站点的爬取。</p>
                  <h3 id="2-Spider-类分析"><a href="#2-Spider-类分析" class="headerlink" title="2. Spider 类分析"></a>2. Spider 类分析</h3>
                  <p>在上一节的例子中我们定义的 Spider 是继承自 scrapy.spiders.Spider，这个类是最简单最基本的 Spider 类，每个其他的 Spider 必须继承这个类，还有后文要说明的一些特殊 Spider 类也都是继承自它。 这个类里提供了 start_requests() 方法的默认实现，读取并请求 start_urls 属性，并根据返回的结果调用 parse() 方法解析结果。另外它还有一些基础属性，下面对其进行讲解：</p>
                  <ul>
                    <li>name，爬虫名称，是定义 Spider 名字的字符串。Spider 的名字定义了 Scrapy 如何定位并初始化 Spider，所以其必须是唯一的。 不过我们可以生成多个相同的 Spider 实例，这没有任何限制。 name 是 Spider 最重要的属性，而且是必须的。如果该 Spider 爬取单个网站，一个常见的做法是以该网站的域名名称来命名 Spider。 例如，如果 Spider 爬取 mywebsite.com ，该 Spider 通常会被命名为 mywebsite 。</li>
                    <li>allowed_domains，允许爬取的域名，是可选配置，不在此范围的链接不会被跟进爬取。</li>
                    <li>start_urls，起始 URL 列表，当我们没有实现 start_requests() 方法时，默认会从这个列表开始抓取。</li>
                    <li>custom_settings，这是一个字典，是专属于本 Spider 的配置，此设置会覆盖项目全局的设置，而且此设置必须在初始化前被更新，所以它必须定义成类变量。</li>
                    <li>crawler，此属性是由 from_crawler() 方法设置的，代表的是本 Spider 类对应的 Crawler 对象，Crawler 对象中包含了很多项目组件，利用它我们可以获取项目的一些配置信息，如最常见的就是获取项目的设置信息，即 Settings。</li>
                    <li>settings，是一个 Settings 对象，利用它我们可以直接获取项目的全局设置变量。</li>
                  </ul>
                  <p>除了一些基础属性，Spider 还有一些常用的方法，在此介绍如下：</p>
                  <ul>
                    <li>start_requests()，此方法用于生成初始请求，它必须返回一个可迭代对象，此方法会默认使用 start_urls 里面的 URL 来构造 Request，而且 Request 是 GET 请求方式。如果我们想在启动时以 POST 方式访问某个站点，可以直接重写这个方法，发送 POST 请求时我们使用 FormRequest 即可。</li>
                    <li>parse()，当 Response 没有指定回调函数时，该方法会默认被调用，它负责处理 Response，处理返回结果，并从中提取出想要的数据和下一步的请求，然后返回。该方法需要返回一个包含 Request 或 Item 的可迭代对象。</li>
                    <li>closed()，当 Spider 关闭时，该方法会被调用，在这里一般会定义释放资源的一些操作或其他收尾操作。</li>
                  </ul>
                  <h3 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h3>
                  <p>以上的介绍可能初看起来有点摸不清头脑，不过不用担心，后面我们会有很多实例来使用这些属性和方法，慢慢会熟练掌握的。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-03 09:40:04" itemprop="dateCreated datePublished" datetime="2019-12-03T09:40:04+08:00">2019-12-03</time>
                </span>
                <span id="/8353.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.4–Spider 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.8k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8350.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8350.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.3–Selector 的用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-3-Selector-的用法"><a href="#13-3-Selector-的用法" class="headerlink" title="13.3 Selector 的用法"></a>13.3 Selector 的用法</h1>
                  <p>我们之前介绍了利用 Beautiful Soup、pyquery 以及正则表达式来提取网页数据，这确实非常方便。而 Scrapy 还提供了自己的数据提取方法，即 Selector（选择器）。Selector 是基于 lxml 来构建的，支持 XPath 选择器、CSS 选择器以及正则表达式，功能全面，解析速度和准确度非常高。 本节将介绍 Selector 的用法。</p>
                  <h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1. 直接使用"></a>1. 直接使用</h3>
                  <p>Selector 是一个可以独立使用的模块。我们可以直接利用 Selector 这个类来构建一个选择器对象，然后调用它的相关方法如 xpath()、css() 等来提取数据。 例如，针对一段 HTML 代码，我们可以用如下方式构建 Selector 对象来提取数据：</p>
                  <figure class="highlight vbnet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> scrapy import Selector</span><br><span class="line"></span><br><span class="line">body = <span class="comment">'<span class="doctag">&lt;html&gt;</span><span class="doctag">&lt;head&gt;</span><span class="doctag">&lt;title&gt;</span>Hello World<span class="doctag">&lt;/title&gt;</span><span class="doctag">&lt;/head&gt;</span><span class="doctag">&lt;body&gt;</span><span class="doctag">&lt;/body&gt;</span><span class="doctag">&lt;/html&gt;</span>'</span></span><br><span class="line">selector = Selector(<span class="keyword">text</span>=body)</span><br><span class="line">title = selector.xpath(<span class="comment">'//title/text()').extract_first()</span></span><br><span class="line">print(title)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">Hello World</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们在这里没有在 Scrapy 框架中运行，而是把 Scrapy 中的 Selector 单独拿出来使用了，构建的时候传入 text 参数，就生成了一个 Selector 选择器对象，然后就可以像前面我们所用的 Scrapy 中的解析方式一样，调用 xpath()、css() 等方法来提取了。 在这里我们查找的是源代码中的 title 中的文本，在 XPath 选择器最后加 text() 方法就可以实现文本的提取了。 以上内容就是 Selector 的直接使用方式。同 Beautiful Soup 等库类似，Selector 其实也是强大的网页解析库。如果方便的话，我们也可以在其他项目中直接使用 Selector 来提取数据。 接下来，我们用实例来详细讲解 Selector 的用法。</p>
                  <h3 id="2-Scrapy-Shell"><a href="#2-Scrapy-Shell" class="headerlink" title="2. Scrapy Shell"></a>2. Scrapy Shell</h3>
                  <p>由于 Selector 主要是与 Scrapy 结合使用，如 Scrapy 的回调函数中的参数 response 直接调用 xpath() 或者 css() 方法来提取数据，所以在这里我们借助 Scrapy shell 来模拟 Scrapy 请求的过程，来讲解相关的提取方法。 我们用官方文档的一个样例页面来做演示：<a href="http://doc.scrapy.org/en/latest/_static/selectors-sample1.html" target="_blank" rel="noopener">http://doc.scrapy.org/en/latest/_static/selectors-sample1.html</a>。 开启 Scrapy shell，在命令行输入如下命令：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy shell http:<span class="regexp">//</span>doc.scrapy.org<span class="regexp">/en/</span>latest<span class="regexp">/_static/</span>selectors-sample1.html</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们就进入到 Scrapy shell 模式。这个过程其实是，Scrapy 发起了一次请求，请求的 URL 就是刚才命令行下输入的 URL，然后把一些可操作的变量传递给我们，如 request、response 等，如图 13-5 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033928.jpg" alt=""> 图 13-5 Scrapy Shell 我们可以在命令行模式下输入命令调用对象的一些操作方法，回车之后实时显示结果。这与 Python 的命令行交互模式是类似的。 接下来，演示的实例都将页面的源码作为分析目标，页面源码如下所示：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">'http://example.com/'</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example website<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'images'</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image1.html'</span>&gt;</span>Name: My image 1 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image1_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image2.html'</span>&gt;</span>Name: My image 2 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image2_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image3.html'</span>&gt;</span>Name: My image 3 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image3_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image4.html'</span>&gt;</span>Name: My image 4 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image4_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'image5.html'</span>&gt;</span>Name: My image 5 <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'image5_thumb.jpg'</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="3-XPath-选择器"><a href="#3-XPath-选择器" class="headerlink" title="3. XPath 选择器"></a>3. XPath 选择器</h3>
                  <p>进入 Scrapy shell 之后，我们将主要操作 response 这个变量来进行解析。因为我们解析的是 HTML 代码，Selector 将自动使用 HTML 语法来分析。 response 有一个属性 selector，我们调用 response.selector 返回的内容就相当于用 response 的 text 构造了一个 Selector 对象。通过这个 Selector 对象我们可以调用解析方法如 xpath()、css() 等，通过向方法传入 XPath 或 CSS 选择器参数就可以实现信息的提取。 我们用一个实例感受一下，如下所示：</p>
                  <figure class="highlight vbnet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; result = response.selector.xpath(<span class="comment">'//a')</span></span><br><span class="line">&gt;&gt;&gt; result</span><br><span class="line">[&lt;Selector xpath=<span class="comment">'//a' data='<span class="doctag">&lt;a href="image1.html"&gt;</span>Name: My image 1 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line"> &lt;Selector xpath=<span class="comment">'//a' data='<span class="doctag">&lt;a href="image2.html"&gt;</span>Name: My image 2 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line"> &lt;Selector xpath=<span class="comment">'//a' data='<span class="doctag">&lt;a href="image3.html"&gt;</span>Name: My image 3 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line"> &lt;Selector xpath=<span class="comment">'//a' data='<span class="doctag">&lt;a href="image4.html"&gt;</span>Name: My image 4 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line"> &lt;Selector xpath=<span class="comment">'//a' data='<span class="doctag">&lt;a href="image5.html"&gt;</span>Name: My image 5 <span class="doctag">&lt;'&gt;</span>]</span></span><br><span class="line">&gt;&gt;&gt; type(result)</span><br><span class="line">scrapy.selector.unified.SelectorList</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>打印结果的形式是 Selector 组成的列表，其实它是 SelectorList 类型，SelectorList 和 Selector 都可以继续调用 xpath() 和 css() 等方法来进一步提取数据。 在上面的例子中，我们提取了 a 节点。接下来，我们尝试继续调用 xpath() 方法来提取 a 节点内包含的 img 节点，如下所示：</p>
                  <figure class="highlight oxygene">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; <span class="keyword">result</span>.xpath(<span class="string">'./img'</span>)</span><br><span class="line">[&lt;<span class="keyword">Selector</span> xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image1_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;<span class="keyword">Selector</span> xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image2_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;<span class="keyword">Selector</span> xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image3_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;<span class="keyword">Selector</span> xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image4_thumb.jpg"&gt;'</span>&gt;,</span><br><span class="line"> &lt;<span class="keyword">Selector</span> xpath=<span class="string">'./img'</span> data=<span class="string">'&lt;img src="image5_thumb.jpg"&gt;'</span>&gt;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们获得了 a 节点里面的所有 img 节点，结果为 5。 值得注意的是，选择器的最前方加 .（点），这代表提取元素内部的数据，如果没有加点，则代表从根节点开始提取。此处我们用了./img 的提取方式，则代表从 a 节点里进行提取。如果此处我们用 //img，则还是从 html 节点里进行提取。 我们刚才使用了 response.selector.xpath() 方法对数据进行了提取。Scrapy 提供了两个实用的快捷方法，response.xpath() 和 response.css()，它们二者的功能完全等同于 response.selector.xpath() 和 response.selector.css()。方便起见，后面我们统一直接调用 response 的 xpath() 和 css() 方法进行选择。 现在我们得到的是 SelectorList 类型的变量，该变量是由 Selector 对象组成的列表。我们可以用索引单独取出其中某个 Selector 元素，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; result[0]</span><br><span class="line">&lt;Selector <span class="attribute">xpath</span>=<span class="string">'//a'</span> <span class="attribute">data</span>=<span class="string">'&lt;a href="image1.html"&gt;Name: My image 1 &lt;'</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们可以像操作列表一样操作这个 SelectorList。 但是现在获取的内容是 Selector 或者 SelectorList 类型，并不是真正的文本内容。那么具体的内容怎么提取呢？ 比如我们现在想提取出 a 节点元素，就可以利用 extract() 方法，如下所示：</p>
                  <figure class="highlight vbnet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; result.extract()</span><br><span class="line">[<span class="comment">'<span class="doctag">&lt;a href="image1.html"&gt;</span>Name: My image 1 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image1_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>', '<span class="doctag">&lt;a href="image2.html"&gt;</span>Name: My image 2 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image2_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>', '<span class="doctag">&lt;a href="image3.html"&gt;</span>Name: My image 3 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image3_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>', '<span class="doctag">&lt;a href="image4.html"&gt;</span>Name: My image 4 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image4_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>', '<span class="doctag">&lt;a href="image5.html"&gt;</span>Name: My image 5 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image5_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>']</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里使用了 extract() 方法，我们就可以把真实需要的内容获取下来。 我们还可以改写 XPath 表达式，来选取节点的内部文本和属性，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.xpath(<span class="string">'//a/text()'</span>).extract()</span><br><span class="line">[<span class="string">'Name: My image 1 '</span>, <span class="string">'Name: My image 2 '</span>, <span class="string">'Name: My image 3 '</span>, <span class="string">'Name: My image 4 '</span>, <span class="string">'Name: My image 5 '</span>]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; response.xpath(<span class="string">'//a/@href'</span>).extract()</span><br><span class="line">[<span class="string">'image1.html'</span>, <span class="string">'image2.html'</span>, <span class="string">'image3.html'</span>, <span class="string">'image4.html'</span>, <span class="string">'image5.html'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们只需要再加一层 /text() 就可以获取节点的内部文本，或者加一层 /@href 就可以获取节点的 href 属性。其中，@符号后面内容就是要获取的属性名称。 现在我们可以用一个规则把所有符合要求的节点都获取下来，返回的类型是列表类型。 但是这里有一个问题：如果符合要求的节点只有一个，那么返回的结果会是什么呢？我们再用一个实例来感受一下，如下所示：</p>
                  <figure class="highlight less">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; <span class="selector-tag">response</span><span class="selector-class">.xpath</span>(<span class="string">'//a[@href="image1.html"]/text()'</span>)<span class="selector-class">.extract</span>()</span><br><span class="line"><span class="selector-attr">['Name: My image 1 ']</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们用属性限制了匹配的范围，使 XPath 只可以匹配到一个元素。然后用 extract() 方法提取结果，其结果还是一个列表形式，其文本是列表的第一个元素。但很多情况下，我们其实想要的数据就是第一个元素内容，这里我们通过加一个索引来获取，如下所示： ```python&gt;&gt;&gt; response.xpath(‘//a[@href=”image1.html”]/text()’).extract()[0] ‘Name: My image 1 ‘</p>
                  <figure class="highlight isbl">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"> 但是，这个写法很明显是有风险的。一旦 <span class="variable">XPath</span> 有问题，那么 <span class="function"><span class="title">extract</span>() 后的结果可能是一个空列表。如果我们再用索引来获取，那不就会可能导致数组越界吗？</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">所以，另外一个方法可以专门提取单个元素，它叫作 <span class="title">extract_first</span>()。我们可以改写上面的例子如下所示：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">```<span class="variable">python</span></span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="variable">response.xpath</span>(<span class="string">'//a[@href="image1.html"]/text()'</span>).extract_first()</span></span><br><span class="line"><span class="string">'Name: My image 1 '</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样，我们直接利用 extract_first() 方法将匹配的第一个结果提取出来，同时我们也不用担心数组越界的问题。 另外我们也可以为 extract_first() 方法设置一个默认值参数，这样当 XPath 规则提取不到内容时会直接使用默认值。例如将 XPath 改成一个不存在的规则，重新执行代码，如下所示：</p>
                  <figure class="highlight mathematica">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.xpath('//a[@href=<span class="string">"image1"</span>]/text()').extract_first()&gt;&gt;&gt; response.xpath('//a[@href=<span class="string">"image1"</span>]/text()').extract_first('<span class="keyword">Default</span> <span class="keyword">Image</span>')</span><br><span class="line">'<span class="keyword">Default</span> <span class="keyword">Image</span>'</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里，如果 XPath 匹配不到任何元素，调用 extract_first() 会返回空，也不会报错。 在第二行代码中，我们还传递了一个参数当作默认值，如 Default Image。这样如果 XPath 匹配不到结果的话，返回值会使用这个参数来代替，可以看到输出正是如此。 现在为止，我们了解了 Scrapy 中的 XPath 的相关用法，包括嵌套查询、提取内容、提取单个内容、获取文本和属性等。</p>
                  <h3 id="4-CSS-选择器"><a href="#4-CSS-选择器" class="headerlink" title="4. CSS 选择器"></a>4. CSS 选择器</h3>
                  <p>接下来，我们看看 CSS 选择器的用法。 Scrapy 的选择器同时还对接了 CSS 选择器，使用 response.css() 方法可以使用 CSS 选择器来选择对应的元素。 例如在上文我们选取了所有的 a 节点，那么 CSS 选择器同样可以做到，如下所示：</p>
                  <figure class="highlight vbnet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.css(<span class="comment">'a')</span></span><br><span class="line">[&lt;Selector xpath=<span class="comment">'descendant-or-self::a' data='<span class="doctag">&lt;a href="image1.html"&gt;</span>Name: My image 1 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line">&lt;Selector xpath=<span class="comment">'descendant-or-self::a' data='<span class="doctag">&lt;a href="image2.html"&gt;</span>Name: My image 2 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line">&lt;Selector xpath=<span class="comment">'descendant-or-self::a' data='<span class="doctag">&lt;a href="image3.html"&gt;</span>Name: My image 3 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line">&lt;Selector xpath=<span class="comment">'descendant-or-self::a' data='<span class="doctag">&lt;a href="image4.html"&gt;</span>Name: My image 4 <span class="doctag">&lt;'&gt;</span>,</span></span><br><span class="line">&lt;Selector xpath=<span class="comment">'descendant-or-self::a' data='<span class="doctag">&lt;a href="image5.html"&gt;</span>Name: My image 5 <span class="doctag">&lt;'&gt;</span>]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>同样，调用 extract() 方法就可以提取出节点，如下所示： ```python&gt;&gt;&gt; response.css(‘a’).extract() <a href="image1.html">‘[Name: My image 1 <img src="image1_thumb.jpg" alt=""></a> ‘, ‘<a href="image2.html">Name: My image 2 <img src="image2_thumb.jpg" alt=""></a> ‘, ‘<a href="image3.html">Name: My image 3 <img src="image3_thumb.jpg" alt=""></a> ‘, ‘<a href="image4.html">Name: My image 4 <img src="image4_thumb.jpg" alt=""></a> ‘, ‘<a href="image5.html">Name: My image 5 <img src="image5_thumb.jpg" alt=""></a> ‘]</p>
                  <figure class="highlight vbnet">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"> 用法和 XPath 选择是完全一样的。</span><br><span class="line"></span><br><span class="line">另外，我们也可以进行属性选择和嵌套选择，如下所示：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">&gt;&gt;&gt; response.css(<span class="comment">'a[href="image1.html"]').extract()</span></span><br><span class="line">[<span class="comment">'<span class="doctag">&lt;a href="image1.html"&gt;</span>Name: My image 1 <span class="doctag">&lt;br&gt;</span><span class="doctag">&lt;img src="image1_thumb.jpg"&gt;</span><span class="doctag">&lt;/a&gt;</span>']</span></span><br><span class="line">&gt;&gt;&gt; response.css(<span class="comment">'a[href="image1.html"] img').extract()</span></span><br><span class="line">[<span class="comment">'<span class="doctag">&lt;img src="image1_thumb.jpg"&gt;</span>']</span></span><br><span class="line">​```这里用 [href=<span class="string">"image.html"</span>] 限定了 href 属性，可以看到匹配结果就只有一个了。另外如果想查找 a 节点内的 img 节点，只需要再加一个空格和 img 即可。选择器的写法和标准 CSS 选择器写法如出一辙。</span><br><span class="line"></span><br><span class="line">我们也可以使用 extract_first() 方法提取列表的第一个元素，如下所示：</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line">&gt;&gt;&gt; response.css(<span class="comment">'a[href="image1.html"] img').extract_first()</span></span><br><span class="line"><span class="comment">'<span class="doctag">&lt;img src="image1_thumb.jpg"&gt;</span>'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来的两个用法不太一样。节点的内部文本和属性的获取是这样实现的，如下所示：</p>
                  <figure class="highlight rust">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.css(<span class="symbol">'a</span>[href=<span class="string">"image1.html"</span>]::text').extract_first()</span><br><span class="line"><span class="symbol">'Name</span>: My image <span class="number">1</span> '</span><br><span class="line">&gt;&gt;&gt; response.css(<span class="symbol">'a</span>[href=<span class="string">"image1.html"</span>] img::attr(src)').extract_first()</span><br><span class="line"><span class="symbol">'image1_thumb</span>.jpg'</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>获取文本和属性需要用::text 和::attr() 的写法。而其他库如 Beautiful Soup 或 pyquery 都有单独的方法。 另外，CSS 选择器和 XPath 选择器一样可以嵌套选择。我们可以先用 XPath 选择器选中所有 a 节点，再利用 CSS 选择器选中 img 节点，再用 XPath 选择器获取属性。我们用一个实例来感受一下，如下所示：</p>
                  <figure class="highlight livescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">\&gt;&gt;&gt;</span> response.xpath(<span class="string">'//a'</span>).css(<span class="string">'img'</span>).xpath(<span class="string">'@src'</span>).extract()</span><br><span class="line">[<span class="string">'image1_thumb.jpg'</span>, <span class="string">'image2_thumb.jpg'</span>, <span class="string">'image3_thumb.jpg'</span>, <span class="string">'image4_thumb.jpg'</span>, <span class="string">'image5_thumb.jpg'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们成功获取了所有 img 节点的 src 属性。 因此，我们可以随意使用 xpath() 和 css() 方法二者自由组合实现嵌套查询，二者是完全兼容的。</p>
                  <h3 id="5-正则匹配"><a href="#5-正则匹配" class="headerlink" title="5. 正则匹配"></a>5. 正则匹配</h3>
                  <p>Scrapy 的选择器还支持正则匹配。比如，在示例的 a 节点中的文本类似于 Name: My image 1，现在我们只想把 Name: 后面的内容提取出来，这时就可以借助 re() 方法，实现如下：</p>
                  <figure class="highlight livescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">\&gt;&gt;&gt;</span> response.xpath(<span class="string">'//a/text()'</span>).re(<span class="string">'Name:s(.*)'</span>)</span><br><span class="line">[<span class="string">'My image 1 '</span>, <span class="string">'My image 2 '</span>, <span class="string">'My image 3 '</span>, <span class="string">'My image 4 '</span>, <span class="string">'My image 5 '</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们给 re() 方法传了一个正则表达式，其中 (.*) 就是要匹配的内容，输出的结果就是正则表达式匹配的分组，结果会依次输出。 如果同时存在两个分组，那么结果依然会被按序输出，如下所示：</p>
                  <figure class="highlight livescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="string">\&gt;&gt;&gt;</span> response.xpath(<span class="string">'//a/text()'</span>).re(<span class="string">'(.*?):s(.*)'</span>)</span><br><span class="line">[<span class="string">'Name'</span>, <span class="string">'My image 1 '</span>, <span class="string">'Name'</span>, <span class="string">'My image 2 '</span>, <span class="string">'Name'</span>, <span class="string">'My image 3 '</span>, <span class="string">'Name'</span>, <span class="string">'My image 4 '</span>, <span class="string">'Name'</span>, <span class="string">'My image 5 '</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>类似 extract_first() 方法，re_first() 方法可以选取列表的第一个元素，用法如下：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.xpath(<span class="string">'//a/text()'</span>).re_first(<span class="string">'(.*?):s(.*)'</span>)</span><br><span class="line"><span class="string">'Name'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; response.xpath(<span class="string">'//a/text()'</span>).re_first(<span class="string">'Name:s(.*)'</span>)</span><br><span class="line"><span class="string">'My image 1 '</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>不论正则匹配了几个分组，结果都会等于列表的第一个元素。 值得注意的是，response 对象不能直接调用 re() 和 re_first() 方法。如果想要对全文进行正则匹配，可以先调用 xpath() 方法再正则匹配，如下所示：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\&gt;&gt;&gt; response.re(<span class="string">'Name:s(.*)'</span>)</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> last):</span><br><span class="line">  File "&lt;console&gt;", <span class="type">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'HtmlResponse'</span> <span class="keyword">object</span> has <span class="keyword">no</span> <span class="keyword">attribute</span> <span class="string">'re'</span></span><br><span class="line">&gt;&gt;&gt; response.xpath(<span class="string">'.'</span>).re(<span class="string">'Name:s(.*)&lt;br&gt;'</span>)</span><br><span class="line">[<span class="string">'My image 1 '</span>, <span class="string">'My image 2 '</span>, <span class="string">'My image 3 '</span>, <span class="string">'My image 4 '</span>, <span class="string">'My image 5 '</span>]</span><br><span class="line">&gt;&gt;&gt; response.xpath(<span class="string">'.'</span>).re_first(<span class="string">'Name:s(.*)&lt;br&gt;'</span>)</span><br><span class="line"><span class="string">'My image 1 '</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过上面的例子，我们可以看到，直接调用 re() 方法会提示没有 re 属性。但是这里首先调用了 xpath(‘.’) 选中全文，然后调用 re() 和 re_first() 方法，就可以进行正则匹配了。</p>
                  <h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h3>
                  <p>以上内容便是 Scrapy 选择器的用法，它包括两个常用选择器和正则匹配功能。熟练掌握 XPath 语法、CSS 选择器语法、正则表达式语法可以大大提高数据提取效率。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-03 09:31:21" itemprop="dateCreated datePublished" datetime="2019-12-03T09:31:21+08:00">2019-12-03</time>
                </span>
                <span id="/8350.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.3–Selector 的用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>9.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>9 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8337.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8337.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.2-Scrapy 入门</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-2-Scrapy-入门"><a href="#13-2-Scrapy-入门" class="headerlink" title="13.2 Scrapy 入门"></a>13.2 Scrapy 入门</h1>
                  <p>接下来介绍一个简单的项目，完成一遍 Scrapy 抓取流程。通过这个过程，我们可以对 Scrapy 的基本用法和原理有大体了解。</p>
                  <h3 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h3>
                  <p>本节要完成的任务如下。</p>
                  <ul>
                    <li>创建一个 Scrapy 项目。</li>
                    <li>创建一个 Spider 来抓取站点和处理数据。</li>
                    <li>通过命令行将抓取的内容导出。</li>
                    <li>将抓取的内容保存到 MongoDB 数据库。</li>
                  </ul>
                  <h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3>
                  <p>我们需要安装好 Scrapy 框架、MongoDB 和 PyMongo 库。如果尚未安装，请参照上一节的安装说明。</p>
                  <h3 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3. 创建项目"></a>3. 创建项目</h3>
                  <p>创建一个 Scrapy 项目，项目文件可以直接用 scrapy 命令生成，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy startproject tutorial</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个命令可以在任意文件夹运行。如果提示权限问题，可以加 sudo 运行该命令。这个命令将会创建一个名为 tutorial 的文件夹，文件夹结构如下所示：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy.cfg     <span class="comment"># Scrapy 部署时的配置文件</span></span><br><span class="line">tutorial         <span class="comment"># 项目的模块，引入的时候需要从这里引入</span></span><br><span class="line">    __init__.py</span><br><span class="line">    <span class="keyword">items</span>.py     <span class="comment"># Items 的定义，定义爬取的数据结构</span></span><br><span class="line">    middlewares.py   <span class="comment"># Middlewares 的定义，定义爬取时的中间件</span></span><br><span class="line">    pipelines.py       <span class="comment"># Pipelines 的定义，定义数据管道</span></span><br><span class="line">    settings.py       <span class="comment"># 配置文件</span></span><br><span class="line">    spiders         <span class="comment"># 放置 Spiders 的文件夹</span></span><br><span class="line">    __init__.py</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="4-创建-Spider"><a href="#4-创建-Spider" class="headerlink" title="4. 创建 Spider"></a>4. 创建 Spider</h3>
                  <p>Spider 是自己定义的类，Scrapy 用它来从网页里抓取内容，并解析抓取的结果。不过这个类必须继承 Scrapy 提供的 Spider 类 scrapy.Spider，还要定义 Spider 的名称和起始请求，以及怎样处理爬取后的结果的方法。 也可以使用命令行创建一个 Spider。比如要生成 Quotes 这个 Spider，可以执行如下命令：</p>
                  <figure class="highlight properties">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">cd</span> <span class="string">tutorial</span></span><br><span class="line"><span class="attr">scrapy</span> <span class="string">genspider quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>进入刚才创建的 tutorial 文件夹，然后执行 genspider 命令。第一个参数是 Spider 的名称，第二个参数是网站域名。执行完毕之后，spiders 文件夹中多了一个 quotes.py，它就是刚刚创建的 Spider，内容如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"quotes"</span></span><br><span class="line">    allowed_domains = [<span class="string">"quotes.toscrape.com"</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里有三个属性 ——name、allowed_domains 和 start_urls，还有一个方法 parse。</p>
                  <ul>
                    <li>name，它是每个项目唯一的名字，用来区分不同的 Spider。</li>
                    <li>allowed_domains，它是允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，则请求链接会被过滤掉。</li>
                    <li>start_urls，它包含了 Spider 在启动时爬取的 url 列表，初始请求是由它来定义的。</li>
                    <li>parse，它是 Spider 的一个方法。默认情况下，被调用时 start_urls 里面的链接构成的请求完成下载执行后，返回的响应就会作为唯一的参数传递给这个函数。该方法负责解析返回的响应、提取数据或者进一步生成要处理的请求。</li>
                  </ul>
                  <h3 id="5-创建-Item"><a href="#5-创建-Item" class="headerlink" title="5. 创建 Item"></a>5. 创建 Item</h3>
                  <p>Item 是保存爬取数据的容器，它的使用方法和字典类似。不过，相比字典，Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。 创建 Item 需要继承 scrapy.Item 类，并且定义类型为 scrapy.Field 的字段。观察目标网站，我们可以获取到的内容有 text、author、tags。 定义 Item，此时将 items.py 修改如下：</p>
                  <figure class="highlight haskell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">QuoteItem</span>(<span class="title">scrapy</span>.<span class="type">Item</span>):</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    text = scrapy.<span class="type">Field</span>()</span></span><br><span class="line"><span class="class">    author = scrapy.<span class="type">Field</span>()</span></span><br><span class="line"><span class="class">    tags = scrapy.<span class="type">Field</span>()</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了三个字段，将类的名称修改为 QuoteItem，接下来爬取时我们会使用到这个 Item。</p>
                  <h3 id="6-解析-Response"><a href="#6-解析-Response" class="headerlink" title="6. 解析 Response"></a>6. 解析 Response</h3>
                  <p>前面我们看到，parse() 方法的参数 response 是 start_urls 里面的链接爬取后的结果。所以在 parse() 方法中，我们可以直接对 response 变量包含的内容进行解析，比如浏览请求结果的网页源代码，或者进一步分析源代码内容，或者找出结果中的链接而得到下一个请求。 我们可以看到网页中既有我们想要的结果，又有下一页的链接，这两部分内容我们都要进行处理。 首先看看网页结构，如图 13-2 所示。每一页都有多个 class 为 quote 的区块，每个区块内都包含 text、author、tags。那么我们先找出所有的 quote，然后提取每一个 quote 中的内容。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033901.jpg" alt=""> 图 13-2 页面结构 提取的方式可以是 CSS 选择器或 XPath 选择器。在这里我们使用 CSS 选择器进行选择，parse() 方法的改写如下所示：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def parse(self, response):</span><br><span class="line">    quotes = response.css('.<span class="literal">quote</span>')</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">quote</span> <span class="keyword">in</span> quotes:</span><br><span class="line">        <span class="built_in">text</span> = <span class="literal">quote</span>.css('.<span class="built_in">text</span>::<span class="built_in">text</span>').extract_first()</span><br><span class="line">        author = <span class="literal">quote</span>.css('.author::<span class="built_in">text</span>').extract_first()</span><br><span class="line">        tags = <span class="literal">quote</span>.css('.tags .tag::<span class="built_in">text</span>').extract()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先利用选择器选取所有的 quote，并将其赋值为 quotes 变量，然后利用 for 循环对每个 quote 遍历，解析每个 quote 的内容。 对 text 来说，观察到它的 class 为 text，所以可以用.text 选择器来选取，这个结果实际上是整个带有标签的节点，要获取它的正文内容，可以加::text 来获取。这时的结果是长度为 1 的列表，所以还需要用 extract_first() 方法来获取第一个元素。而对于 tags 来说，由于我们要获取所有的标签，所以用 extract() 方法获取整个列表即可。 以第一个 quote 的结果为例，各个选择方法及结果的说明如下内容。 源码如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"quote"</span> itemscope=<span class="string">""</span>itemtype=<span class="string">"http://schema.org/CreativeWork"</span>&gt;</span><br><span class="line">        &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"text"</span> itemprop=<span class="string">"text"</span>&gt;“The world <span class="keyword">as</span> we have created it is a process <span class="keyword">of</span> our thinking. It cannot be changed without changing our thinking.”&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;by &lt;small class="author" itemprop="author"&gt;Albert Einstein&lt;/</span>small&gt;</span><br><span class="line">        &lt;a href=<span class="string">"/author/Albert-Einstein"</span>&gt;(about)&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>span&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"tags"</span>&gt;</span><br><span class="line">            Tags:</span><br><span class="line">            &lt;meta <span class="class"><span class="keyword">class</span></span>=<span class="string">"keywords"</span> itemprop=<span class="string">"keywords"</span> content=<span class="string">"change,deep-thoughts,thinking,world"</span>&gt;</span><br><span class="line">            &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"tag"</span> href=<span class="string">"/tag/change/page/1/"</span>&gt;change&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a class="tag" href="/</span>tag/deep-thoughts/page/<span class="number">1</span>/<span class="string">"&gt;deep-thoughts&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;a class="</span>tag<span class="string">" href="</span>/tag/thinking/page/<span class="number">1</span>/<span class="string">"&gt;thinking&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;a class="</span>tag<span class="string">" href="</span>/tag/world/page/<span class="number">1</span>/<span class="string">"&gt;world&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>不同选择器的返回结果如下。</p>
                  <h4 id="quote-css-‘-text’"><a href="#quote-css-‘-text’" class="headerlink" title="quote.css(‘.text’)"></a>quote.css(‘.text’)</h4>
                  <figure class="highlight fsharp">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">[&lt;Selector xpath="descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), ' text ')]"data='&lt;span class="text"itemprop="text"&gt;“The '&gt;]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="quote-css-‘-text-text’"><a href="#quote-css-‘-text-text’" class="headerlink" title="quote.css(‘.text::text’)"></a>quote.css(‘.text::text’)</h4>
                  <figure class="highlight fsharp">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">[&lt;Selector xpath="descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), ' text ')]/text()"data='“The world as we have created it is a pr'&gt;]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="quote-css-‘-text’-extract"><a href="#quote-css-‘-text’-extract" class="headerlink" title="quote.css(‘.text’).extract()"></a>quote.css(‘.text’).extract()</h4>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">['&lt;span <span class="built_in">class</span>=<span class="string">"text"</span>itemprop=<span class="string">"text"</span>&gt;“The world <span class="keyword">as</span> we have created <span class="keyword">it</span> <span class="keyword">is</span> a process <span class="keyword">of</span> our thinking. It cannot be changed <span class="keyword">without</span> changing our thinking.”&lt;/span&gt;']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="quote-css-‘-text-text’-extract"><a href="#quote-css-‘-text-text’-extract" class="headerlink" title="quote.css(‘.text::text’).extract()"></a>quote.css(‘.text::text’).extract()</h4>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">['“The world <span class="keyword">as</span> we have created <span class="keyword">it</span> <span class="keyword">is</span> a process <span class="keyword">of</span> our thinking. It cannot be changed <span class="keyword">without</span> changing our thinking.”']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="quote-css-‘-text-text’-extract-first"><a href="#quote-css-‘-text-text’-extract-first" class="headerlink" title="quote.css(‘.text::text’).extract_first()"></a>quote.css(‘.text::text’).extract_first()</h4>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">“The world <span class="keyword">as</span> we have created <span class="keyword">it</span> is <span class="keyword">a</span> <span class="built_in">process</span> <span class="keyword">of</span> our thinking. It cannot be changed <span class="keyword">without</span> changing our thinking.”</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>所以，对于 text，获取结果的第一个元素即可，所以使用 extract_first() 方法，对于 tags，要获取所有结果组成的列表，所以使用 extract() 方法。</p>
                  <h3 id="7-使用-Item"><a href="#7-使用-Item" class="headerlink" title="7. 使用 Item"></a>7. 使用 Item</h3>
                  <p>上文定义了 Item，接下来就要使用它了。Item 可以理解为一个字典，不过在声明的时候需要实例化。然后依次用刚才解析的结果赋值 Item 的每一个字段，最后将 Item 返回即可。 QuotesSpider 的改写如下所示：</p>
                  <figure class="highlight livecodeserver">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import scrapy</span><br><span class="line"><span class="built_in">from</span> tutorial.<span class="keyword">items</span> import QuoteItem</span><br><span class="line"></span><br><span class="line">class QuotesSpider(scrapy.Spider):</span><br><span class="line">    name = <span class="string">"quotes"</span></span><br><span class="line">    allowed_domains = [<span class="string">"quotes.toscrape.com"</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="literal">quote</span> <span class="keyword">in</span> quotes:</span><br><span class="line">            <span class="keyword">item</span> = QuoteItem()</span><br><span class="line">            <span class="keyword">item</span>[<span class="string">'text'</span>] = <span class="literal">quote</span>.css(<span class="string">'.text::text'</span>).extract_first()</span><br><span class="line">            <span class="keyword">item</span>[<span class="string">'author'</span>] = <span class="literal">quote</span>.css(<span class="string">'.author::text'</span>).extract_first()</span><br><span class="line">            <span class="keyword">item</span>[<span class="string">'tags'</span>] = <span class="literal">quote</span>.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br><span class="line">            yield <span class="keyword">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如此一来，首页的所有内容被解析出来，并被赋值成了一个个 QuoteItem。</p>
                  <h3 id="8-后续-Request"><a href="#8-后续-Request" class="headerlink" title="8. 后续 Request"></a>8. 后续 Request</h3>
                  <p>上面的操作实现了从初始页面抓取内容。那么，下一页的内容该如何抓取？这就需要我们从当前页面中找到信息来生成下一个请求，然后在下一个请求的页面里找到信息再构造再下一个请求。这样循环往复迭代，从而实现整站的爬取。 将刚才的页面拉到最底部，如图 13-3 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033909.jpg" alt=""> 图 13-3 页面底部 有一个 Next 按钮，查看一下源代码，可以发现它的链接是 /page/2/，实际上全链接就是：<a href="http://quotes.toscrape.com/page/2" target="_blank" rel="noopener">http://quotes.toscrape.com/page/2</a>，通过这个链接我们就可以构造下一个请求。 构造请求时需要用到 scrapy.Request。这里我们传递两个参数 ——url 和 callback，这两个参数的说明如下。</p>
                  <ul>
                    <li>url：它是请求链接。</li>
                    <li>callback：它是回调函数。当指定了该回调函数的请求完成之后，获取到响应，引擎会将该响应作为参数传递给这个回调函数。回调函数进行解析或生成下一个请求，回调函数如上文的 parse() 所示。</li>
                  </ul>
                  <p>由于 parse() 就是解析 text、author、tags 的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以我们可以再次使用 parse() 方法来做页面解析。 接下来我们要做的就是利用选择器得到下一页链接并生成请求，在 parse() 方法后追加如下的代码：</p>
                  <figure class="highlight reasonml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">next = response.css('.pager .next a::attr(href)').extract<span class="constructor">_first()</span></span><br><span class="line">url = response.urljoin(next)</span><br><span class="line">yield scrapy.<span class="constructor">Request(<span class="params">url</span>=<span class="params">url</span>, <span class="params">callback</span>=<span class="params">self</span>.<span class="params">parse</span>)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一句代码首先通过 CSS 选择器获取下一个页面的链接，即要获取 a 超链接中的 href 属性。这里用到了::attr(href) 操作。然后再调用 extract_first() 方法获取内容。 第二句代码调用了 urljoin() 方法，urljoin() 方法可以将相对 URL 构造成一个绝对的 URL。例如，获取到的下一页地址是 /page/2，urljoin() 方法处理后得到的结果就是：<a href="http://quotes.toscrape.com/page/2/" target="_blank" rel="noopener">http://quotes.toscrape.com/page/2/</a>。 第三句代码通过 url 和 callback 变量构造了一个新的请求，回调函数 callback 依然使用 parse() 方法。这个请求完成后，响应会重新经过 parse 方法处理，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样爬虫就进入了一个循环，直到最后一页。 通过几行代码，我们就轻松实现了一个抓取循环，将每个页面的结果抓取下来了。 现在，改写之后的整个 Spider 类如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import scrapy</span><br><span class="line">from tutorial.items import QuoteItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span>(<span class="title">scrapy</span>.<span class="title">Spider</span>):</span></span><br><span class="line">    name = <span class="string">"quotes"</span></span><br><span class="line">    allowed_domains = [<span class="string">"quotes.toscrape.com"</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">        quotes = response.css(<span class="string">'.quote'</span>)</span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> <span class="symbol">quotes:</span></span><br><span class="line">            item = QuoteItem()</span><br><span class="line">            item[<span class="string">'text'</span>] = quote.css(<span class="string">'.text::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'author'</span>] = quote.css(<span class="string">'.author::text'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'tags'</span>] = quote.css(<span class="string">'.tags .tag::text'</span>).extract()</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">next</span> = response.css(<span class="string">'.pager .next a::attr("href")'</span>).extract_first()</span><br><span class="line">        url = response.urljoin(<span class="keyword">next</span>)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=url, callback=<span class="keyword">self</span>.parse)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="9-运行"><a href="#9-运行" class="headerlink" title="9. 运行"></a>9. 运行</h3>
                  <p>接下来，进入目录，运行如下命令：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>就可以看到 Scrapy 的运行结果了。</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.utils.log] INFO: Scrapy <span class="number">1.3</span><span class="number">.0</span> started (bot: tutorial)</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.utils.log] INFO: Overridden settings: &#123;<span class="string">'NEWSPIDER_MODULE'</span>: <span class="string">'tutorial.spiders'</span>, <span class="string">'SPIDER_MODULES'</span>: [<span class="string">'tutorial.spiders'</span>], <span class="string">'ROBOTSTXT_OBEY'</span>: <span class="literal">True</span>, <span class="string">'BOT_NAME'</span>: <span class="string">'tutorial'</span>&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">[<span class="string">'scrapy.extensions.logstats.LogStats'</span>,</span><br><span class="line"> <span class="string">'scrapy.extensions.telnet.TelnetConsole'</span>,</span><br><span class="line"> <span class="string">'scrapy.extensions.corestats.CoreStats'</span>]</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">[<span class="string">'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.retry.RetryMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.cookies.CookiesMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.downloadermiddlewares.stats.DownloaderStats'</span>]</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">[<span class="string">'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.spidermiddlewares.offsite.OffsiteMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.spidermiddlewares.referer.RefererMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware'</span>,</span><br><span class="line"> <span class="string">'scrapy.spidermiddlewares.depth.DepthMiddleware'</span>]</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[]</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.core.engine] INFO: Spider opened</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.extensions.logstats] INFO: Crawled <span class="number">0</span> pages (at <span class="number">0</span> pages/min), scraped <span class="number">0</span> items (at <span class="number">0</span> items/min)</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">20</span> [scrapy.extensions.telnet] DEBUG: Telnet console listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6023</span></span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">21</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">404</span>) &lt;GET http://quotes.toscrape.com/robots.txt&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">21</span> [scrapy.core.engine] DEBUG: Crawled (<span class="number">200</span>) &lt;GET http://quotes.toscrape.com/&gt; (referer: <span class="literal">None</span>)</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">21</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http://quotes.toscrape.com/&gt;</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">u'Albert Einstein'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">u'change'</span>, <span class="string">u'deep-thoughts'</span>, <span class="string">u'thinking'</span>, <span class="string">u'world'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">u'u201cThe world as we have created it is a process of our thinking. It cannot be changed without changing our thinking.u201d'</span>&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">21</span> [scrapy.core.scraper] DEBUG: Scraped <span class="keyword">from</span> &lt;<span class="number">200</span> http://quotes.toscrape.com/&gt;</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">u'J.K. Rowling'</span>,</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">u'abilities'</span>, <span class="string">u'choices'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">u'u201cIt is our choices, Harry, that show what we truly are, far more than our abilities.u201d'</span>&#125;</span><br><span class="line">...</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">27</span> [scrapy.core.engine] INFO: Closing spider (finished)</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">27</span> [scrapy.statscollectors] INFO: Dumping Scrapy stats:</span><br><span class="line">&#123;<span class="string">'downloader/request_bytes'</span>: <span class="number">2859</span>,</span><br><span class="line"> <span class="string">'downloader/request_count'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/request_method_count/GET'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/response_bytes'</span>: <span class="number">24871</span>,</span><br><span class="line"> <span class="string">'downloader/response_count'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'downloader/response_status_count/200'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'downloader/response_status_count/404'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'dupefilter/filtered'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'finish_reason'</span>: <span class="string">'finished'</span>,</span><br><span class="line"> <span class="string">'finish_time'</span>: datetime.datetime(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">27</span>, <span class="number">227438</span>),</span><br><span class="line"> <span class="string">'item_scraped_count'</span>: <span class="number">100</span>,</span><br><span class="line"> <span class="string">'log_count/DEBUG'</span>: <span class="number">113</span>,</span><br><span class="line"> <span class="string">'log_count/INFO'</span>: <span class="number">7</span>,</span><br><span class="line"> <span class="string">'request_depth_max'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'response_received_count'</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">'scheduler/dequeued'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/dequeued/memory'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/enqueued'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'scheduler/enqueued/memory'</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">'start_time'</span>: datetime.datetime(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">20</span>, <span class="number">321557</span>)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-19</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">27</span> [scrapy.core.engine] INFO: Spider closed (finished)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里只是部分运行结果，中间一些抓取结果已省略。 首先，Scrapy 输出了当前的版本号以及正在启动的项目名称。接着输出了当前 settings.py 中一些重写后的配置。然后输出了当前所应用的 Middlewares 和 Pipelines。Middlewares 默认是启用的，可以在 settings.py 中修改。Pipelines 默认是空，同样也可以在 settings.py 中配置。后面会对它们进行讲解。 接下来就是输出各个页面的抓取结果了，可以看到爬虫一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。 最后，Scrapy 输出了整个抓取过程的统计信息，如请求的字节数、请求次数、响应次数、完成原因等。 整个 Scrapy 程序成功运行。我们通过非常简单的代码就完成了一个网站内容的爬取，这样相比之前一点点写程序简洁很多。</p>
                  <h3 id="10-保存到文件"><a href="#10-保存到文件" class="headerlink" title="10. 保存到文件"></a>10. 保存到文件</h3>
                  <p>运行完 Scrapy 后，我们只在控制台看到了输出结果。如果想保存结果该怎么办呢？ 要完成这个任务其实不需要任何额外的代码，Scrapy 提供的 Feed Exports 可以轻松将抓取结果输出。例如，我们想将上面的结果保存成 JSON 文件，可以执行如下命令：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.json</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>命令运行后，项目内多了一个 quotes.json 文件，文件包含了刚才抓取的所有内容，内容是 JSON 格式。 另外我们还可以每一个 Item 输出一行 JSON，输出后缀为 jl，为 jsonline 的缩写，命令如下所示：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.jl</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.jsonlines</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出格式还支持很多种，例如 csv、xml、pickle、marshal 等，还支持 ftp、s3 等远程输出，另外还可以通过自定义 ItemExporter 来实现其他的输出。 例如，下面命令对应的输出分别为 csv、xml、pickle、marshal 格式以及 ftp 远程输出：</p>
                  <figure class="highlight scss">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.csv</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.xml</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.pickle</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o <span class="attribute">quotes</span><span class="selector-class">.marshal</span></span><br><span class="line">scrapy crawl <span class="attribute">quotes</span> -o ftp://user:pass@ftp.example.com/path/to/quotes.csv</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中，ftp 输出需要正确配置用户名、密码、地址、输出路径，否则会报错。 通过 Scrapy 提供的 Feed Exports，我们可以轻松地输出抓取结果到文件。对于一些小型项目来说，这应该足够了。不过如果想要更复杂的输出，如输出到数据库等，我们可以使用 Item Pileline 来完成。</p>
                  <h3 id="11-使用-Item-Pipeline"><a href="#11-使用-Item-Pipeline" class="headerlink" title="11. 使用 Item Pipeline"></a>11. 使用 Item Pipeline</h3>
                  <p>如果想进行更复杂的操作，如将结果保存到 MongoDB 数据库，或者筛选某些有用的 Item，则我们可以定义 Item Pipeline 来实现。 Item Pipeline 为项目管道。当 Item 生成后，它会自动被送到 Item Pipeline 进行处理，我们常用 Item Pipeline 来做如下操作。</p>
                  <ul>
                    <li>清洗 HTML 数据</li>
                    <li>验证爬取数据，检查爬取字段</li>
                    <li>查重并丢弃重复内容</li>
                    <li>将爬取结果储存到数据库</li>
                  </ul>
                  <p>要实现 Item Pipeline 很简单，只需要定义一个类并实现 process_item() 方法即可。启用 Item Pipeline 后，Item Pipeline 会自动调用这个方法。process_item() 方法必须返回包含数据的字典或 Item 对象，或者抛出 DropItem 异常。 process_item() 方法有两个参数。一个参数是 item，每次 Spider 生成的 Item 都会作为参数传递过来。另一个参数是 spider，就是 Spider 的实例。 接下来，我们实现一个 Item Pipeline，筛掉 text 长度大于 50 的 Item，并将结果保存到 MongoDB。 修改项目里的 pipelines.py 文件，之前用命令行自动生成的文件内容可以删掉，增加一个 TextPipeline 类，内容如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">from scrapy.exceptions import DropItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.limit = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">'text'</span>]<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'text'</span>]) &gt; <span class="keyword">self</span>.<span class="symbol">limit:</span></span><br><span class="line">                item[<span class="string">'text'</span>] = item[<span class="string">'text'</span>][<span class="number">0</span><span class="symbol">:self</span>.limit].rstrip() + <span class="string">'...'</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="symbol">else:</span></span><br><span class="line">            <span class="keyword">return</span> DropItem(<span class="string">'Missing Text'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这段代码在构造方法里定义了限制长度为 50，实现了 process_item() 方法，其参数是 item 和 spider。首先该方法判断 item 的 text 属性是否存在，如果不存在，则抛出 DropItem 异常；如果存在，再判断长度是否大于 50，如果大于，那就截断然后拼接省略号，再将 item 返回即可。 接下来，我们将处理后的 item 存入 MongoDB，定义另外一个 Pipeline。同样在 pipelines.py 中，我们实现另一个类 MongoPipeline，内容如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, mongo_uri, mongo_db)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.mongo_uri = mongo_uri</span><br><span class="line">        <span class="keyword">self</span>.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> cls(mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>),</span><br><span class="line">            mongo_db=crawler.settings.get(<span class="string">'MONGO_DB'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client = pymongo.MongoClient(<span class="keyword">self</span>.mongo_uri)</span><br><span class="line">        <span class="keyword">self</span>.db = <span class="keyword">self</span>.client[<span class="keyword">self</span>.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(<span class="keyword">self</span>, item, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        name = item.__class_<span class="number">_</span>.__name_<span class="number">_</span></span><br><span class="line">        <span class="keyword">self</span>.db[name].insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(<span class="keyword">self</span>, spider)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.client.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>MongoPipeline 类实现了 API 定义的另外几个方法。</p>
                  <ul>
                    <li>from_crawler，这是一个类方法，用 @classmethod 标识，是一种依赖注入的方式，方法的参数就是 crawler，通过 crawler 这个我们可以拿到全局配置的每个配置信息，在全局配置 settings.py 中我们可以定义 MONGO_URI 和 MONGO_DB 来指定 MongoDB 连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取 settings.py 中的配置的。</li>
                    <li>open_spider，当 Spider 被开启时，这个方法被调用。在这里主要进行了一些初始化操作。</li>
                    <li>close_spider，当 Spider 被关闭时，这个方法会调用，在这里将数据库连接关闭。</li>
                  </ul>
                  <p>最主要的 process_item() 方法则执行了数据插入操作。 定义好 TextPipeline 和 MongoPipeline 这两个类后，我们需要在 settings.py 中使用它们。MongoDB 的连接信息还需要定义。 我们在 settings.py 中加入如下内容：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'tutorial.pipelines.TextPipeline'</span>: 300,</span><br><span class="line">   <span class="string">'tutorial.pipelines.MongoPipeline'</span>: 400,</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">MONGO_URI</span>=<span class="string">'localhost'</span></span><br><span class="line"><span class="attribute">MONGO_DB</span>=<span class="string">'tutorial'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>赋值 ITEM_PIPELINES 字典，键名是 Pipeline 的类名称，键值是调用优先级，是一个数字，数字越小则对应的 Pipeline 越先被调用。 再重新执行爬取，命令如下所示：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">scrapy crawl quotes</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>爬取结束后，MongoDB 中创建了一个 tutorial 的数据库、QuoteItem 的表，如图 13-4 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033919.jpg" alt=""> 图 13-4 爬取结果 长的 text 已经被处理并追加了省略号，短的 text 保持不变，author 和 tags 也都相应保存。</p>
                  <h3 id="12-源代码"><a href="#12-源代码" class="headerlink" title="12. 源代码"></a>12. 源代码</h3>
                  <p>本节代码地址：<a href="https://github.com/Python3WebSpider/ScrapyTutorial" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapyTutorial</a>。</p>
                  <h3 id="13-结语"><a href="#13-结语" class="headerlink" title="13. 结语"></a>13. 结语</h3>
                  <p>我们通过抓取 Quotes 网站完成了整个 Scrapy 的简单入门。但这只是冰山一角，还有很多内容等待我们去探索。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-02 11:22:46" itemprop="dateCreated datePublished" datetime="2019-12-02T11:22:46+08:00">2019-12-02</time>
                </span>
                <span id="/8337.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.2-Scrapy 入门" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>14k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>13 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8333.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Paper <i class="label-arrow"></i>
                  </a>
                  <a href="/8333.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 13.1-Scrapy 框架介绍</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="13-1-Scrapy-框架介绍"><a href="#13-1-Scrapy-框架介绍" class="headerlink" title="13.1 Scrapy 框架介绍"></a>13.1 Scrapy 框架介绍</h1>
                  <p>Scrapy 是一个基于 Twisted 的异步处理框架，是纯 Python 实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。我们只需要定制开发几个模块就可以轻松实现一个爬虫。</p>
                  <h3 id="1-架构介绍"><a href="#1-架构介绍" class="headerlink" title="1. 架构介绍"></a>1. 架构介绍</h3>
                  <p>首先我们来看下 Scrapy 框架的架构，如图 13-1 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-033839.jpg" alt=""> 图 13-1 Scrapy 架构 它可以分为如下的几个部分。</p>
                  <ul>
                    <li>Engine，引擎，用来处理整个系统的数据流处理，触发事务，是整个框架的核心。</li>
                    <li>Item，项目，它定义了爬取结果的数据结构，爬取的数据会被赋值成该对象。</li>
                    <li>Scheduler， 调度器，用来接受引擎发过来的请求并加入队列中，并在引擎再次请求的时候提供给引擎。</li>
                    <li>Downloader，下载器，用于下载网页内容，并将网页内容返回给蜘蛛。</li>
                    <li>Spiders，蜘蛛，其内定义了爬取的逻辑和网页的解析规则，它主要负责解析响应并生成提取结果和新的请求。</li>
                    <li>Item Pipeline，项目管道，负责处理由蜘蛛从网页中抽取的项目，它的主要任务是清洗、验证和存储数据。</li>
                    <li>Downloader Middlewares，下载器中间件，位于引擎和下载器之间的钩子框架，主要是处理引擎与下载器之间的请求及响应。</li>
                    <li>Spider Middlewares， 蜘蛛中间件，位于引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛输入的响应和输出的结果及新的请求。</li>
                  </ul>
                  <h3 id="2-数据流"><a href="#2-数据流" class="headerlink" title="2. 数据流"></a>2. 数据流</h3>
                  <p>Scrapy 中的数据流由引擎控制，其过程如下:</p>
                  <ul>
                    <li>Engine 首先打开一个网站，找到处理该网站的 Spider 并向该 Spider 请求第一个要爬取的 URL。</li>
                    <li>Engine 从 Spider 中获取到第一个要爬取的 URL 并通过 Scheduler 以 Request 的形式调度。</li>
                    <li>Engine 向 Scheduler 请求下一个要爬取的 URL。</li>
                    <li>Scheduler 返回下一个要爬取的 URL 给 Engine，Engine 将 URL 通过 Downloader Middlewares 转发给 Downloader 下载。</li>
                    <li>一旦页面下载完毕， Downloader 生成一个该页面的 Response，并将其通过 Downloader Middlewares 发送给 Engine。</li>
                    <li>Engine 从下载器中接收到 Response 并通过 Spider Middlewares 发送给 Spider 处理。</li>
                    <li>Spider 处理 Response 并返回爬取到的 Item 及新的 Request 给 Engine。</li>
                    <li>Engine 将 Spider 返回的 Item 给 Item Pipeline，将新的 Request 给 Scheduler。</li>
                    <li>重复第二步到最后一步，直到 Scheduler 中没有更多的 Request，Engine 关闭该网站，爬取结束。</li>
                  </ul>
                  <p>通过多个组件的相互协作、不同组件完成工作的不同、组件对异步处理的支持，Scrapy 最大限度地利用了网络带宽，大大提高了数据爬取和处理的效率。</p>
                  <h3 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h3>
                  <p>Scrapy 框架和 pyspider 不同，它是通过命令行来创建项目的，代码的编写还是需要 IDE。项目创建之后，项目文件结构如下所示：</p>
                  <figure class="highlight stylus">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrapy.cfg</span><br><span class="line">project/</span><br><span class="line">    __init__.py</span><br><span class="line">    items.py</span><br><span class="line">    pipelines.py</span><br><span class="line">    settings.py</span><br><span class="line">    middlewares.py</span><br><span class="line">    spiders/</span><br><span class="line">        __init__.py</span><br><span class="line">        spider1.py</span><br><span class="line">        spider2.py</span><br><span class="line">        ...</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在此要将各个文件的功能描述如下：</p>
                  <ul>
                    <li>scrapy.cfg：它是 Scrapy 项目的配置文件，其内定义了项目的配置文件路径、部署相关信息等内容。</li>
                    <li>items.py：它定义 Item 数据结构，所有的 Item 的定义都可以放这里。</li>
                    <li>pipelines.py：它定义 Item Pipeline 的实现，所有的 Item Pipeline 的实现都可以放这里。</li>
                    <li>settings.py：它定义项目的全局配置。</li>
                    <li>middlewares.py：它定义 Spider Middlewares 和 Downloader Middlewares 的实现。</li>
                    <li>spiders：其内包含一个个 Spider 的实现，每个 Spider 都有一个文件。</li>
                  </ul>
                  <h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h3>
                  <p>本节介绍了 Scrapy 框架的基本架构、数据流过程以及项目结构。后面我们会详细了解 Scrapy 的用法，感受它的强大。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-12-02 11:20:01" itemprop="dateCreated datePublished" datetime="2019-12-02T11:20:01+08:00">2019-12-02</time>
                </span>
                <span id="/8333.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 13.1-Scrapy 框架介绍" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/8320.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/8320.html" class="post-title-link" itemprop="url">[Python3网络爬虫开发实战] 12.3-pyspider 用法详解</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <h1 id="12-3-pyspider-用法详解"><a href="#12-3-pyspider-用法详解" class="headerlink" title="12.3 pyspider 用法详解"></a>12.3 pyspider 用法详解</h1>
                  <p>前面我们了解了 pyspider 的基本用法，我们通过非常少的代码和便捷的可视化操作就完成了一个爬虫的编写，本节我们来总结一下它的详细用法。</p>
                  <h3 id="1-命令行"><a href="#1-命令行" class="headerlink" title="1. 命令行"></a>1. 命令行</h3>
                  <p>上面的实例通过如下命令启动 pyspider：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pyspider <span class="keyword">all</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>命令行还有很多可配制参数，完整的命令行结构如下所示：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">pyspider</span> <span class="selector-attr">[OPTIONS]</span> <span class="selector-tag">COMMAND</span> <span class="selector-attr">[ARGS]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中，OPTIONS 为可选参数，它可以指定如下参数。</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Options:</span><br><span class="line">  -c, <span class="comment">--config FILENAME    指定配置文件名称</span></span><br><span class="line">  <span class="comment">--logging-config TEXT    日志配置文件名称，默认: pyspider/pyspider/logging.conf</span></span><br><span class="line">  <span class="comment">--debug                  开启调试模式</span></span><br><span class="line">  <span class="comment">--queue-maxsize INTEGER  队列的最大长度</span></span><br><span class="line">  <span class="comment">--taskdb TEXT            taskdb 的数据库连接字符串，默认: sqlite</span></span><br><span class="line">  <span class="comment">--projectdb TEXT         projectdb 的数据库连接字符串，默认: sqlite</span></span><br><span class="line">  <span class="comment">--resultdb TEXT          resultdb 的数据库连接字符串，默认: sqlite</span></span><br><span class="line">  <span class="comment">--message-queue TEXT     消息队列连接字符串，默认: multiprocessing.Queue</span></span><br><span class="line">  <span class="comment">--phantomjs-proxy TEXT   PhantomJS 使用的代理，ip:port 的形式</span></span><br><span class="line">  <span class="comment">--data-path TEXT         数据库存放的路径</span></span><br><span class="line">  <span class="comment">--version                pyspider 的版本</span></span><br><span class="line">  <span class="comment">--help                   显示帮助信息</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>例如，-c 可以指定配置文件的名称，这是一个常用的配置，配置文件的样例结构如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"taskdb"</span>: <span class="string">"mysql+taskdb://username:password@host:port/taskdb"</span>,</span><br><span class="line">  <span class="attr">"projectdb"</span>: <span class="string">"mysql+projectdb://username:password@host:port/projectdb"</span>,</span><br><span class="line">  <span class="attr">"resultdb"</span>: <span class="string">"mysql+resultdb://username:password@host:port/resultdb"</span>,</span><br><span class="line">  <span class="attr">"message_queue"</span>: <span class="string">"amqp://username:password@host:port/%2F"</span>,</span><br><span class="line">  <span class="attr">"webui"</span>: &#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"some_name"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"some_passwd"</span>,</span><br><span class="line">    <span class="attr">"need-auth"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果要配置 pyspider WebUI 的访问认证，可以新建一个 pyspider.json，内容如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"webui"</span>: &#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"need-auth"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们通过在启动时指定配置文件来配置 pyspider WebUI 的访问认证，用户名为 root，密码为 123456，命令如下所示：</p>
                  <figure class="highlight pgsql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pyspider -c pyspider.json <span class="keyword">all</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行之后打开：<a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a>，页面如 12-26 所示： <img src="https://cdn.cuiqingcai.com/2019-11-27-033806.png" alt=""> 图 12-26 运行页面 也可以单独运行 pyspider 的某一个组件。 运行 Scheduler 的命令如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pyspider<span class="built_in"> scheduler </span>[OPTIONS]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行时也可以指定各种配置，参数如下所示：</p>
                  <figure class="highlight brainfuck">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment">Options:</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span> <span class="comment">/</span>--<span class="comment">no</span><span class="literal">-</span><span class="comment">xmlrpc</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span><span class="literal">-</span><span class="comment">host</span> <span class="comment">TEXT</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">INTEGER</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">inqueue</span><span class="literal">-</span><span class="comment">limit</span> <span class="comment">INTEGER</span>  <span class="comment">任务队列的最大长度，如果满了则新的任务会被忽略</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">delete</span><span class="literal">-</span><span class="comment">time</span> <span class="comment">INTEGER</span>    <span class="comment">设置为</span> <span class="comment">delete</span> <span class="comment">标记之前的删除时间</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">active</span><span class="literal">-</span><span class="comment">tasks</span> <span class="comment">INTEGER</span>   <span class="comment">当前活跃任务数量配置</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">loop</span><span class="literal">-</span><span class="comment">limit</span> <span class="comment">INTEGER</span>     <span class="comment">单轮最多调度的任务数量</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">scheduler</span><span class="literal">-</span><span class="comment">cls</span> <span class="comment">TEXT</span>     <span class="comment">Scheduler</span> <span class="comment">使用的类</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">help</span>                   <span class="comment">显示帮助信息</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行 Fetcher 的命令如下所示：</p>
                  <figure class="highlight apache">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">pyspider</span> fetcher<span class="meta"> [OPTIONS]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>参数配置如下所示：</p>
                  <figure class="highlight brainfuck">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment">Options:</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span> <span class="comment">/</span>--<span class="comment">no</span><span class="literal">-</span><span class="comment">xmlrpc</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span><span class="literal">-</span><span class="comment">host</span> <span class="comment">TEXT</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">xmlrpc</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">INTEGER</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">poolsize</span> <span class="comment">INTEGER</span>      <span class="comment">同时请求的个数</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">proxy</span> <span class="comment">TEXT</span>            <span class="comment">使用的代理</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">user</span><span class="literal">-</span><span class="comment">agent</span> <span class="comment">TEXT</span>       <span class="comment">使用的</span> <span class="comment">User</span><span class="literal">-</span><span class="comment">Agent</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">timeout</span> <span class="comment">TEXT</span>          <span class="comment">超时时间</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">fetcher</span><span class="literal">-</span><span class="comment">cls</span> <span class="comment">TEXT</span>      <span class="comment">Fetcher</span> <span class="comment">使用的类</span></span><br><span class="line"><span class="comment"></span>  --<span class="comment">help</span>                  <span class="comment">显示帮助信息</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行 Processer 的命令如下所示：</p>
                  <figure class="highlight apache">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">pyspider</span> processor<span class="meta"> [OPTIONS]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>参数配置如下所示：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Options:</span><br><span class="line">  <span class="comment">--processor-cls TEXT  Processor 使用的类</span></span><br><span class="line">  <span class="comment">--help                显示帮助信息</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行 WebUI 的命令如下所示：</p>
                  <figure class="highlight apache">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">pyspider</span> webui<span class="meta"> [OPTIONS]</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>参数配置如下所示：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Options:</span><br><span class="line">  <span class="comment">--host TEXT            运行地址</span></span><br><span class="line">  <span class="comment">--port INTEGER         运行端口</span></span><br><span class="line">  <span class="comment">--cdn TEXT             JS 和 CSS 的 CDN 服务器</span></span><br><span class="line">  <span class="comment">--scheduler-rpc TEXT   Scheduler 的 xmlrpc 路径</span></span><br><span class="line">  <span class="comment">--fetcher-rpc TEXT     Fetcher 的 xmlrpc 路径</span></span><br><span class="line">  <span class="comment">--max-rate FLOAT       每个项目最大的 rate 值</span></span><br><span class="line">  <span class="comment">--max-burst FLOAT      每个项目最大的 burst 值</span></span><br><span class="line">  <span class="comment">--username TEXT        Auth 验证的用户名</span></span><br><span class="line">  <span class="comment">--password TEXT        Auth 验证的密码</span></span><br><span class="line">  <span class="comment">--need-auth            是否需要验证</span></span><br><span class="line">  <span class="comment">--webui-instance TEXT  运行时使用的 Flask 应用</span></span><br><span class="line">  <span class="comment">--help                 显示帮助信息</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里的配置和前面提到的配置文件参数是相同的。如果想要改变 WebUI 的端口为 5001，单独运行如下命令：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pyspider webui <span class="comment">--port 5001</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或者可以将端口配置到 JSON 文件中，配置如下所示：</p>
                  <figure class="highlight json">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"webui"</span>: &#123;<span class="attr">"port"</span>: <span class="number">5001</span>&#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>使用如下命令启动同样可以达到相同的效果：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">pyspider</span> <span class="selector-tag">-c</span> <span class="selector-tag">pyspider</span><span class="selector-class">.json</span> <span class="selector-tag">webui</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以在 5001 端口上运行 WebUI 了。</p>
                  <h3 id="2-crawl-方法"><a href="#2-crawl-方法" class="headerlink" title="2. crawl() 方法"></a>2. crawl() 方法</h3>
                  <p>在前面的例子中，我们使用 crawl() 方法实现了新请求的生成，但是只指定了 URL 和 Callback。这里将详细介绍一下 crawl() 方法的参数配置。</p>
                  <h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4>
                  <p>url 是爬取时的 URL，可以定义为单个 URL 字符串，也可以定义成 URL 列表。</p>
                  <h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4>
                  <p>callback 是回调函数，指定了该 URL 对应的响应内容用哪个方法来解析，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://scrapy.org/'</span>, callback=<span class="keyword">self</span>.index_page)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里指定了 callback 为 index_page，就代表爬取 <a href="http://scrapy.org/" target="_blank" rel="noopener">http://scrapy.org/</a> 链接得到的响应会用 index_page() 方法来解析。 index_page() 方法的第一个参数是响应对象，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">    pass</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>方法中的 response 参数就是请求上述 URL 得到的响应对象，我们可以直接在 index_page() 方法中实现页面的解析。</p>
                  <h4 id="age"><a href="#age" class="headerlink" title="age"></a>age</h4>
                  <p>age 是任务的有效时间。如果某个任务在有效时间内且已经被执行，则它不会重复执行，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               age=<span class="number">10</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或者可以这样设置：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">@config(age=<span class="number">10</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    pass</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>默认的有效时间为 10 天。</p>
                  <h4 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h4>
                  <p>priority 是爬取任务的优先级，其值默认是 0，priority 的数值越大，对应的请求会越优先被调度，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/page.html'</span>, callback=<span class="keyword">self</span>.index_page)</span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/233.html'</span>, callback=<span class="keyword">self</span>.detail_page,</span><br><span class="line">               priority=<span class="number">1</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第二个任务会优先调用，233.html 这个链接优先爬取。</p>
                  <h4 id="exetime"><a href="#exetime" class="headerlink" title="exetime"></a>exetime</h4>
                  <p>exetime 参数可以设置定时任务，其值是时间戳，默认是 0，即代表立即执行，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               exetime=time.time()+<span class="number">30</span>*<span class="number">60</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样该任务会在 30 分钟之后执行。</p>
                  <h4 id="retries"><a href="#retries" class="headerlink" title="retries"></a>retries</h4>
                  <p>retries 可以定义重试次数，其值默认是 3。</p>
                  <h4 id="itag"><a href="#itag" class="headerlink" title="itag"></a>itag</h4>
                  <p>itag 参数设置判定网页是否发生变化的节点值，在爬取时会判定次当前节点是否和上次爬取到的节点相同。如果节点相同，则证明页面没有更新，就不会重复爬取，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> response.doc(<span class="string">'.item'</span>).items()<span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.crawl(item.find(<span class="string">'a'</span>).attr.url, callback=<span class="keyword">self</span>.detail_page,</span><br><span class="line">                   itag=item.find(<span class="string">'.update-time'</span>).text())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里设置了更新时间这个节点的值为 itag，在下次爬取时就会首先检测这个值有没有发生变化，如果没有变化，则不再重复爬取，否则执行爬取。</p>
                  <h4 id="auto-recrawl"><a href="#auto-recrawl" class="headerlink" title="auto_recrawl"></a>auto_recrawl</h4>
                  <p>当开启时，爬取任务在过期后会重新执行，循环时间即定义的 age 时间长度，如下所示：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def on_start(self):</span><br><span class="line">    self.crawl(<span class="string">'http://www.example.org/'</span>, <span class="attribute">callback</span>=self.callback,</span><br><span class="line">               <span class="attribute">age</span>=5*60*60, <span class="attribute">auto_recrawl</span>=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了 age 有效期为 5 小时，设置了 auto_recrawl 为 True，这样任务就会每 5 小时执行一次。</p>
                  <h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4>
                  <p>method 是 HTTP 请求方式，它默认是 GET。如果想发起 POST 请求，可以将 method 设置为 POST。</p>
                  <h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4>
                  <p>我们可以方便地使用 params 来定义 GET 请求参数，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://httpbin.org/get'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               params=&#123;<span class="string">'a'</span>: <span class="number">123</span>, <span class="string">'b'</span>: <span class="string">'c'</span>&#125;)</span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://httpbin.org/get?a=123&amp;b=c'</span>, callback=<span class="keyword">self</span>.callback)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里两个爬取任务是等价的。</p>
                  <h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4>
                  <p>data 是 POST 表单数据。当请求方式为 POST 时，我们可以通过此参数传递表单数据，如下所示：</p>
                  <figure class="highlight oxygene">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def on_start(<span class="keyword">self</span>):</span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://httpbin.org/post'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               <span class="function"><span class="keyword">method</span>='<span class="title">POST</span>', <span class="title">data</span>=<span class="comment">&#123;'a': 123, 'b': 'c'&#125;</span>)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4>
                  <p>files 是上传的文件，需要指定文件名，如下所示：</p>
                  <figure class="highlight oxygene">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">def on_start(<span class="keyword">self</span>):</span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://httpbin.org/post'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               <span class="function"><span class="keyword">method</span>='<span class="title">POST</span>', <span class="title">files</span>=<span class="comment">&#123;field: &#123;filename: 'content'&#125;</span>&#125;)</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="user-agent"><a href="#user-agent" class="headerlink" title="user_agent"></a>user_agent</h4>
                  <p>user_agent 是爬取使用的 User-Agent。</p>
                  <h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4>
                  <p>headers 是爬取时使用的 Headers，即 Request Headers。</p>
                  <h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4>
                  <p>cookies 是爬取时使用的 Cookies，为字典格式。</p>
                  <h4 id="connect-timeout"><a href="#connect-timeout" class="headerlink" title="connect_timeout"></a>connect_timeout</h4>
                  <p>connect_timeout 是在初始化连接时的最长等待时间，它默认是 20 秒。</p>
                  <h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4>
                  <p>timeout 是抓取网页时的最长等待时间，它默认是 120 秒。</p>
                  <h4 id="allow-redirects"><a href="#allow-redirects" class="headerlink" title="allow_redirects"></a>allow_redirects</h4>
                  <p>allow_redirects 确定是否自动处理重定向，它默认是 True。</p>
                  <h4 id="validate-cert"><a href="#validate-cert" class="headerlink" title="validate_cert"></a>validate_cert</h4>
                  <p>validate_cert 确定是否验证证书，此选项对 HTTPS 请求有效，默认是 True。</p>
                  <h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4>
                  <p>proxy 是爬取时使用的代理，它支持用户名密码的配置，格式为 username:password@hostname:port，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://httpbin.org/get'</span>, callback=<span class="keyword">self</span>.callback, proxy=<span class="string">'127.0.0.1:9743'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>也可以设置 craw_config 来实现全局配置，如下所示：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">class</span> <span class="symbol">Handler</span>(<span class="symbol">BaseHandler</span>):</span><br><span class="line">    <span class="symbol">crawl_config</span> = &#123;<span class="string">'proxy'</span>: <span class="string">'127.0.0.1:9743'</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h4 id="fetch-type"><a href="#fetch-type" class="headerlink" title="fetch_type"></a>fetch_type</h4>
                  <p>fetch_type 开启 PhantomJS 渲染。如果遇到 JavaScript 渲染的页面，指定此字段即可实现 PhantomJS 的对接，pyspider 将会使用 PhantomJS 进行网页的抓取，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'https://www.taobao.com'</span>, callback=<span class="keyword">self</span>.index_page, fetch_type=<span class="string">'js'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以实现淘宝页面的抓取了，得到的结果就是浏览器中看到的效果。</p>
                  <h4 id="js-script"><a href="#js-script" class="headerlink" title="js_script"></a>js_script</h4>
                  <p>js_script 是页面加载完毕后执行的 JavaScript 脚本，如下所示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.crawl(<span class="string">'http://www.example.org/'</span>, callback=self.callback,</span><br><span class="line">               fetch_type=<span class="string">'js'</span>, js_script=<span class="string">'''</span></span><br><span class="line"><span class="string">               function() &#123;window.scrollTo(0,document.body.scrollHeight);</span></span><br><span class="line"><span class="string">                   return 123;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               '''</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>页面加载成功后将执行页面混动的 JavaScript 代码，页面会下拉到最底部。</p>
                  <h4 id="js-run-at"><a href="#js-run-at" class="headerlink" title="js_run_at"></a>js_run_at</h4>
                  <p>js_run_at 代表 JavaScript 脚本运行的位置，是在页面节点开头还是结尾，默认是结尾，即 document-end。</p>
                  <h4 id="js-viewport-width-js-viewport-height"><a href="#js-viewport-width-js-viewport-height" class="headerlink" title="js_viewport_width/js_viewport_height"></a>js_viewport_width/js_viewport_height</h4>
                  <p>js_viewport_width/js_viewport_height 是 JavaScript 渲染页面时的窗口大小。</p>
                  <h4 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h4>
                  <p>load_images 在加载 JavaScript 页面时确定是否加载图片，它默认是否。</p>
                  <h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4>
                  <p>save 参数非常有用，可以在不同的方法之间传递参数，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/'</span>, callback=<span class="keyword">self</span>.callback,</span><br><span class="line">               save=&#123;<span class="string">'page'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(<span class="keyword">self</span>, response)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> response.save[<span class="string">'page'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样，在 on_start() 方法中生成 Request 并传递额外的参数 page，在回调函数里可以通过 response 变量的 save 字段接收到这些参数值。</p>
                  <h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h4>
                  <p>cancel 是取消任务，如果一个任务是 ACTIVE 状态的，则需要将 force_update 设置为 True。</p>
                  <h4 id="force-update"><a href="#force-update" class="headerlink" title="force_update"></a>force_update</h4>
                  <p>即使任务处于 ACTIVE 状态，那也会强制更新状态。 以上便是 crawl() 方法的参数介绍，更加详细的描述可以参考：<a href="http://docs.pyspider.org/en/latest/apis/self.crawl/" target="_blank" rel="noopener">http://docs.pyspider.org/en/latest/apis/self.crawl/</a>。</p>
                  <h3 id="3-任务区分"><a href="#3-任务区分" class="headerlink" title="3. 任务区分"></a>3. 任务区分</h3>
                  <p>在 pyspider 判断两个任务是否是重复的是使用的是该任务对应的 URL 的 MD5 值作为任务的唯一 ID，如果 ID 相同，那么两个任务就会判定为相同，其中一个就不会爬取了。很多情况下请求的链接可能是同一个，但是 POST 的参数不同。这时可以重写 task_id() 方法，改变这个 ID 的计算方式来实现不同任务的区分，如下所示：</p>
                  <figure class="highlight gradle">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyspider.libs.utils <span class="keyword">import</span> md5string</span><br><span class="line"><span class="keyword">def</span> get_taskid(self, <span class="keyword">task</span>):</span><br><span class="line">    <span class="keyword">return</span> md5string(<span class="keyword">task</span>[<span class="string">'url'</span>]+json.dumps(<span class="keyword">task</span>[<span class="string">'fetch'</span>].get(<span class="string">'data'</span>, <span class="string">''</span>)))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里重写了 get_taskid() 方法，利用 URL 和 POST 的参数来生成 ID。这样一来，即使 URL 相同，但是 POST 的参数不同，两个任务的 ID 就不同，它们就不会被识别成重复任务。</p>
                  <h3 id="4-全局配置"><a href="#4-全局配置" class="headerlink" title="4. 全局配置"></a>4. 全局配置</h3>
                  <p>pyspider 可以使用 crawl_config 来指定全局的配置，配置中的参数会和 crawl() 方法创建任务时的参数合并。如要全局配置一个 Headers，可以定义如下代码：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line">    crawl_config = &#123;</span><br><span class="line">        <span class="string">'headers'</span>: &#123;<span class="string">'User-Agent'</span>: <span class="string">'GoogleBot'</span>,&#125;</span><br><span class="line">    &#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="5-定时爬取"><a href="#5-定时爬取" class="headerlink" title="5. 定时爬取"></a>5. 定时爬取</h3>
                  <p>我们可以通过 every 属性来设置爬取的时间间隔，如下所示：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">@every(minutes=<span class="number">24</span> * <span class="number">60</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> <span class="symbol">urllist:</span></span><br><span class="line">        <span class="keyword">self</span>.crawl(url, callback=<span class="keyword">self</span>.index_page)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里设置了每天执行一次爬取。 在上文中我们提到了任务的有效时间，在有效时间内爬取不会重复。所以要把有效时间设置得比重复时间更短，这样才可以实现定时爬取。 例如，下面的代码就无法做到每天爬取：</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">@every(minutes=<span class="number">24</span> * <span class="number">60</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">self</span>.crawl(<span class="string">'http://www.example.org/'</span>, callback=<span class="keyword">self</span>.index_page)</span><br><span class="line"></span><br><span class="line">@config(age=<span class="number">10</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">    pass</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里任务的过期时间为 10 天，而自动爬取的时间间隔为 1 天。当第二次尝试重新爬取的时候，pyspider 会监测到此任务尚未过期，便不会执行爬取，所以我们需要将 age 设置得小于定时时间。</p>
                  <h3 id="6-项目状态"><a href="#6-项目状态" class="headerlink" title="6. 项目状态"></a>6. 项目状态</h3>
                  <p>每个项目都有 6 个状态，分别是 TODO、STOP、CHECKING、DEBUG、RUNNING、PAUSE。</p>
                  <ul>
                    <li>TODO：它是项目刚刚被创建还未实现时的状态。</li>
                    <li>STOP：如果想停止某项目的抓取，可以将项目的状态设置为 STOP。</li>
                    <li>CHECKING：正在运行的项目被修改后就会变成 CHECKING 状态，项目在中途出错需要调整的时候会遇到这种情况。</li>
                    <li>DEBUG/RUNNING：这两个状态对项目的运行没有影响，状态设置为任意一个，项目都可以运行，但是可以用二者来区分项目是否已经测试通过。</li>
                    <li>PAUSE：当爬取过程中出现连续多次错误时，项目会自动设置为 PAUSE 状态，并等待一定时间后继续爬取。</li>
                  </ul>
                  <h3 id="7-抓取进度"><a href="#7-抓取进度" class="headerlink" title="7. 抓取进度"></a>7. 抓取进度</h3>
                  <p>在抓取时，可以看到抓取的进度，progress 部分会显示 4 个进度条，如图 12-27 所示。 <img src="https://cdn.cuiqingcai.com/2019-11-27-033821.jpg" alt=""> 图 12-27 抓取进度 progress 中的 5m、1h、1d 指的是最近 5 分、1 小时、1 天内的请求情况，all 代表所有的请求情况。 蓝色的请求代表等待被执行的任务，绿色的代表成功的任务，黄色的代表请求失败后等待重试的任务，红色的代表失败次数过多而被忽略的任务，从这里我们可以直观看到爬取的进度和请求情况。</p>
                  <h3 id="8-删除项目"><a href="#8-删除项目" class="headerlink" title="8. 删除项目"></a>8. 删除项目</h3>
                  <p>pyspider 中没有直接删除项目的选项。如要删除任务，那么将项目的状态设置为 STOP，将分组的名称设置为 delete，等待 24 小时，则项目会自动删除。</p>
                  <h3 id="9-结语"><a href="#9-结语" class="headerlink" title="9. 结语"></a>9. 结语</h3>
                  <p>以上内容便是 pyspider 的常用用法。如要了解更多，可以参考 pyspider 的官方文档：<a href="http://docs.pyspider.org/" target="_blank" rel="noopener">http://docs.pyspider.org/</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2019-11-30 09:22:31" itemprop="dateCreated datePublished" datetime="2019-11-30T09:22:31+08:00">2019-11-30</time>
                </span>
                <span id="/8320.html" class="post-meta-item leancloud_visitors" data-flag-title="[Python3网络爬虫开发实战] 12.3-pyspider 用法详解" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>8.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>8 分钟</span>
                </span>
              </div>
            </article>
            <script>
              document.querySelectorAll('.random').forEach(item => item.src = "https://picsum.photos/id/" + Math.floor(Math.random() * Math.floor(300)) + "/200/133")

            </script>
            <nav class="pagination">
              <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
            </nav>
          </div>
          <script>
            window.addEventListener('tabs:register', () =>
            {
              let
              {
                activeClass
              } = CONFIG.comments;
              if (CONFIG.comments.storage)
              {
                activeClass = localStorage.getItem('comments_active') || activeClass;
              }
              if (activeClass)
              {
                let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
                if (activeTab)
                {
                  activeTab.click();
                }
              }
            });
            if (CONFIG.comments.storage)
            {
              window.addEventListener('tabs:click', event =>
              {
                if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
                let commentClass = event.target.classList[1];
                localStorage.setItem('comments_active', commentClass);
              });
            }

          </script>
        </div>
        <div class="toggle sidebar-toggle">
          <span class="toggle-line toggle-line-first"></span>
          <span class="toggle-line toggle-line-middle"></span>
          <span class="toggle-line toggle-line-last"></span>
        </div>
        <aside class="sidebar">
          <div class="sidebar-inner">
            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc"> 文章目录 </li>
              <li class="sidebar-nav-overview"> 站点概览 </li>
            </ul>
            <!--noindex-->
            <div class="post-toc-wrap sidebar-panel">
            </div>
            <!--/noindex-->
            <div class="site-overview-wrap sidebar-panel">
              <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <img class="site-author-image" itemprop="image" alt="崔庆才" src="/images/avatar.png">
                <p class="site-author-name" itemprop="name">崔庆才</p>
                <div class="site-description" itemprop="description">静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。</div>
              </div>
              <div class="site-state-wrap motion-element">
                <nav class="site-state">
                  <div class="site-state-item site-state-posts">
                    <a href="/archives/">
                      <span class="site-state-item-count">685</span>
                      <span class="site-state-item-name">日志</span>
                    </a>
                  </div>
                  <div class="site-state-item site-state-categories">
                    <a href="/categories/">
                      <span class="site-state-item-count">32</span>
                      <span class="site-state-item-name">分类</span></a>
                  </div>
                  <div class="site-state-item site-state-tags">
                    <a href="/tags/">
                      <span class="site-state-item-count">246</span>
                      <span class="site-state-item-name">标签</span></a>
                  </div>
                </nav>
              </div>
              <div class="links-of-author motion-element">
                <span class="links-of-author-item">
                  <a href="https://github.com/Germey" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Germey" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
                </span>
                <span class="links-of-author-item">
                  <a href="mailto:cqc@cuiqingcai.com.com" title="邮件 → mailto:cqc@cuiqingcai.com.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮件</a>
                </span>
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cuiqingcai" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;cuiqingcai" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
                </span>
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/Germey" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Germey" rel="noopener" target="_blank"><i class="fa fa-magic fa-fw"></i>知乎</a>
                </span>
              </div>
            </div>
            <div style=" width: 100%;" class="sidebar-panel sidebar-panel-image sidebar-panel-active">
              <a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">
                <img src="https://cdn.cuiqingcai.com/ei5og.jpg" style=" width: 100%;">
              </a>
            </div>
            <div class="sidebar-panel sidebar-panel-categories sidebar-panel-active">
              <h4 class="name"> 分类 </h4>
              <div class="content">
                <ul class="category-list">
                  <li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a><span class="category-list-count">5</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">23</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">14</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">26</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Luma/">Luma</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Net/">Net</a><span class="category-list-count">4</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Nexior/">Nexior</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a><span class="category-list-count">40</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">27</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Paper/">Paper</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">303</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%B1%95%E7%A4%BA/">个人展示</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/">个人日记</a><span class="category-list-count">9</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/">个人记录</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/">个人随笔</a><span class="category-list-count">21</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">5</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">安装配置</a><span class="category-list-count">59</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/">技术杂谈</a><span class="category-list-count">96</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a><span class="category-list-count">4</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/">生活笔记</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A6%8F%E5%88%A9%E4%B8%93%E5%8C%BA/">福利专区</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E8%81%8C%E4%BD%8D%E6%8E%A8%E8%8D%90/">职位推荐</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E8%89%BA%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81/">艺术二维码</a><span class="category-list-count">1</span></li>
                </ul>
              </div>
            </div>
            <div class="sidebar-panel sidebar-panel-friends sidebar-panel-active">
              <h4 class="name"> 友情链接 </h4>
              <ul class="friends">
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/j2dub.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.findhao.net/" target="_blank" rel="noopener">FindHao</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/6apxu.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.51dev.com/" target="_blank" rel="noopener">IT技术社区</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/bqlbs.png">
                  </span>
                  <span class="link">
                    <a href="http://www.urselect.com/" target="_blank" rel="noopener">优社电商</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/8s88c.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.yuanrenxue.com/" target="_blank" rel="noopener">猿人学</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/2wgg5.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.yunlifang.cn/" target="_blank" rel="noopener">云立方</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="http://qianxunclub.com/favicon.png">
                  </span>
                  <span class="link">
                    <a href="http://qianxunclub.com/" target="_blank" rel="noopener">千寻啊千寻</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/0044u.jpg">
                  </span>
                  <span class="link">
                    <a href="http://kodcloud.com/" target="_blank" rel="noopener">可道云</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/ygnpn.jpg">
                  </span>
                  <span class="link">
                    <a href="http://www.kunkundashen.cn/" target="_blank" rel="noopener">坤坤大神</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/x714o.jpg">
                  </span>
                  <span class="link">
                    <a href="http://www.hubwiz.com/" target="_blank" rel="noopener">汇智网</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/44hxf.png">
                  </span>
                  <span class="link">
                    <a href="http://redstonewill.com/" target="_blank" rel="noopener">红色石头</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/wkaus.jpg">
                  </span>
                  <span class="link">
                    <a href="https://zhaoshuai.me/" target="_blank" rel="noopener">碎念</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/pgo0r.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.chenwenguan.com/" target="_blank" rel="noopener">陈文管的博客</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/kk82a.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.lxlinux.net/" target="_blank" rel="noopener">良许Linux教程网</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/lj0t2.jpg">
                  </span>
                  <span class="link">
                    <a href="https://tanqingbo.cn/" target="_blank" rel="noopener">IT码农</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/i8cdr.png">
                  </span>
                  <span class="link">
                    <a href="https://junyiseo.com/" target="_blank" rel="noopener">均益个人博客</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/chwv2.png">
                  </span>
                  <span class="link">
                    <a href="https://brucedone.com/" target="_blank" rel="noopener">大鱼的鱼塘</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://www.91vps.com/favicon.ico">
                  </span>
                  <span class="link">
                    <a href="http://www.91vps.com/" target="_blank" rel="noopener">91VPS</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://webpage.qidian.qq.com/qidian/chatv3-gray/favicon.ico">
                  </span>
                  <span class="link">
                    <a href="https://www.qg.net/" target="_blank" rel="noopener">青果网络</a>
                  </span>
                </li>
              </ul>
            </div>
            <div class="sidebar-panel sidebar-panel-tags sidebar-panel-active">
              <h4 class="name"> 标签云 </h4>
              <div class="content">
                <a href="/tags/2022/" style="font-size: 20px;">2022</a> <a href="/tags/2048/" style="font-size: 10px;">2048</a> <a href="/tags/ADSL/" style="font-size: 10px;">ADSL</a> <a href="/tags/API/" style="font-size: 16px;">API</a> <a href="/tags/Ajax/" style="font-size: 12px;">Ajax</a> <a href="/tags/Bootstrap/" style="font-size: 11px;">Bootstrap</a> <a href="/tags/Bug/" style="font-size: 10px;">Bug</a> <a href="/tags/CDN/" style="font-size: 10px;">CDN</a> <a href="/tags/CQC/" style="font-size: 10px;">CQC</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/CSS-%E5%8F%8D%E7%88%AC%E8%99%AB/" style="font-size: 10px;">CSS 反爬虫</a> <a href="/tags/CV/" style="font-size: 10px;">CV</a> <a href="/tags/ChatGPT/" style="font-size: 10px;">ChatGPT</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/Flux/" style="font-size: 10px;">Flux</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub/" style="font-size: 13px;">GitHub</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hailuo/" style="font-size: 10px;">Hailuo</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hook/" style="font-size: 10px;">Hook</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/IT/" style="font-size: 10px;">IT</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JavaScript/" style="font-size: 14px;">JavaScript</a> <a href="/tags/K8s/" style="font-size: 10px;">K8s</a> <a href="/tags/LOGO/" style="font-size: 10px;">LOGO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Luma/" style="font-size: 10px;">Luma</a> <a href="/tags/MIUI/" style="font-size: 10px;">MIUI</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Midjourney/" style="font-size: 11px;">Midjourney</a> <a href="/tags/MongoDB/" style="font-size: 11px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/NBA/" style="font-size: 10px;">NBA</a> <a href="/tags/Nexior/" style="font-size: 10px;">Nexior</a> <a href="/tags/OCR/" style="font-size: 10px;">OCR</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/PHP/" style="font-size: 11px;">PHP</a> <a href="/tags/PPT/" style="font-size: 10px;">PPT</a> <a href="/tags/PS/" style="font-size: 10px;">PS</a> <a href="/tags/Pathlib/" style="font-size: 10px;">Pathlib</a> <a href="/tags/PhantomJS/" style="font-size: 10px;">PhantomJS</a> <a href="/tags/Playwright/" style="font-size: 10px;">Playwright</a> <a href="/tags/Python/" style="font-size: 17px;">Python</a> <a href="/tags/Python-%E7%88%AC%E8%99%AB/" style="font-size: 18px;">Python 爬虫</a> <a href="/tags/Python3/" style="font-size: 11px;">Python3</a> <a href="/tags/Python3%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/" style="font-size: 12px;">Python3爬虫教程</a> <a href="/tags/Pythonic/" style="font-size: 10px;">Pythonic</a> <a href="/tags/Python%E7%88%AC%E8%99%AB/" style="font-size: 19px;">Python爬虫</a> <a href="/tags/Python%E7%88%AC%E8%99%AB%E4%B9%A6/" style="font-size: 12px;">Python爬虫书</a> <a href="/tags/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/" style="font-size: 15px;">Python爬虫教程</a> <a href="/tags/QQ/" style="font-size: 10px;">QQ</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/ReCAPTCHA/" style="font-size: 10px;">ReCAPTCHA</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Riffusion/" style="font-size: 10px;">Riffusion</a> <a href="/tags/SAE/" style="font-size: 10px;">SAE</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/SVG/" style="font-size: 10px;">SVG</a> <a href="/tags/Scrapy-redis/" style="font-size: 10px;">Scrapy-redis</a> <a href="/tags/Scrapy%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">Scrapy分布式</a> <a href="/tags/Selenium/" style="font-size: 11px;">Selenium</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Suno/" style="font-size: 10px;">Suno</a> <a href="/tags/TKE/" style="font-size: 10px;">TKE</a> <a href="/tags/TXT/" style="font-size: 10px;">TXT</a> <a href="/tags/Terminal/" style="font-size: 10px;">Terminal</a> <a href="/tags/Ubuntu/" style="font-size: 11px;">Ubuntu</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Veo/" style="font-size: 10px;">Veo</a> <a href="/tags/Vercel/" style="font-size: 10px;">Vercel</a> <a href="/tags/Vs-Code/" style="font-size: 10px;">Vs Code</a> <a href="/tags/Vue/" style="font-size: 11px;">Vue</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/Web%E7%BD%91%E9%A1%B5/" style="font-size: 10px;">Web网页</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/Winpcap/" style="font-size: 10px;">Winpcap</a> <a href="/tags/WordPress/" style="font-size: 13px;">WordPress</a> <a href="/tags/XPath/" style="font-size: 12px;">XPath</a> <a href="/tags/Youtube/" style="font-size: 11px;">Youtube</a> <a href="/tags/acedata/" style="font-size: 12px;">acedata</a> <a href="/tags/aiohttp/" style="font-size: 10px;">aiohttp</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/api/" style="font-size: 13px;">api</a> <a href="/tags/chatgpt/" style="font-size: 10px;">chatgpt</a> <a href="/tags/cocos2d-x/" style="font-size: 10px;">cocos2d-x</a> <a href="/tags/dummy-change/" style="font-size: 10px;">dummy change</a> <a href="/tags/e6/" style="font-size: 10px;">e6</a> <a href="/tags/fitvids/" style="font-size: 10px;">fitvids</a>
              </div>
              <script>
                const tagsColors = ['#00a67c', '#5cb85c', '#d9534f', '#567e95', '#b37333', '#f4843d', '#15a287']
                const tagsElements = document.querySelectorAll('.sidebar-panel-tags .content a')
                tagsElements.forEach((item) =>
                {
                  item.style.backgroundColor = tagsColors[Math.floor(Math.random() * tagsColors.length)]
                })

              </script>
            </div>
          </div>
        </aside>
        <div id="sidebar-dimmer"></div>
      </div>
    </main>
    <footer class="footer">
      <div class="footer-inner">
        <div class="copyright">
          <span class="author" itemprop="copyrightHolder">崔庆才丨静觅</span> &copy; <span itemprop="copyrightYear">2025</span>
          <span class="with-love">
            <i class="fa fa-heart"></i>
          </span>
          <a href="https://cuiqingcai.com/sitemap.xml" style="display:none" title="爬虫教程" target="_blank"><strong>爬虫教程</strong></a>
          <a href="https://cuiqingcai.com/sitemap.html" style="display:none" title="爬虫教程" target="_blank"><strong>爬虫教程</strong></a>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-chart-area"></i>
          </span>
          <span title="站点总字数">3.3m</span>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-coffee"></i>
          </span>
          <span title="站点阅读时长">49:35</span>
        </div>
        <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 </div>
        <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18015597号-1 </a>
        </div>
        <script>
          (function ()
          {
            function leancloudSelector(url)
            {
              url = encodeURI(url);
              return document.getElementById(url).querySelector('.leancloud-visitors-count');
            }

            function addCount(Counter)
            {
              var visitors = document.querySelector('.leancloud_visitors');
              var url = decodeURI(visitors.id);
              var title = visitors.dataset.flagTitle;
              Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify(
              {
                url
              }))).then(response => response.json()).then((
              {
                results
              }) =>
              {
                if (results.length > 0)
                {
                  var counter = results[0];
                  leancloudSelector(url).innerText = counter.time + 1;
                  Counter('put', '/classes/Counter/' + counter.objectId,
                  {
                    time:
                    {
                      '__op': 'Increment',
                      'amount': 1
                    }
                  }).catch(error =>
                  {
                    console.error('Failed to save visitor count', error);
                  });
                }
                else
                {
                  Counter('post', '/classes/Counter',
                  {
                    title,
                    url,
                    time: 1
                  }).then(response => response.json()).then(() =>
                  {
                    leancloudSelector(url).innerText = 1;
                  }).catch(error =>
                  {
                    console.error('Failed to create', error);
                  });
                }
              }).catch(error =>
              {
                console.error('LeanCloud Counter Error', error);
              });
            }

            function showTime(Counter)
            {
              var visitors = document.querySelectorAll('.leancloud_visitors');
              var entries = [...visitors].map(element =>
              {
                return decodeURI(element.id);
              });
              Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify(
              {
                url:
                {
                  '$in': entries
                }
              }))).then(response => response.json()).then((
              {
                results
              }) =>
              {
                for (let url of entries)
                {
                  let target = results.find(item => item.url === url);
                  leancloudSelector(url).innerText = target ? target.time : 0;
                }
              }).catch(error =>
              {
                console.error('LeanCloud Counter Error', error);
              });
            }
            let
            {
              app_id,
              app_key,
              server_url
            } = {
              "enable": true,
              "app_id": "6X5dRQ0pnPWJgYy8SXOg0uID-gzGzoHsz",
              "app_key": "ziLDVEy73ne5HtFTiGstzHMS",
              "server_url": "https://6x5drq0p.lc-cn-n1-shared.com",
              "security": false
            };

            function fetchData(api_server)
            {
              var Counter = (method, url, data) =>
              {
                return fetch(`${api_server}/1.1${url}`,
                {
                  method,
                  headers:
                  {
                    'X-LC-Id': app_id,
                    'X-LC-Key': app_key,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(data)
                });
              };
              if (CONFIG.page.isPost)
              {
                if (CONFIG.hostname !== location.hostname) return;
                addCount(Counter);
              }
              else if (document.querySelectorAll('.post-title-link').length >= 1)
              {
                showTime(Counter);
              }
            }
            let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;
            if (api_server)
            {
              fetchData(api_server);
            }
            else
            {
              fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id).then(response => response.json()).then((
              {
                api_server
              }) =>
              {
                fetchData('https://' + api_server);
              });
            }
          })();

        </script>
      </div>
      <div class="footer-stat">
        <span id="cnzz_stat_icon_1279355174"></span>
        <script type="text/javascript">
          document.write(unescape("%3Cspan id='cnzz_stat_icon_1279355174'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279355174%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));

        </script>
      </div>
    </footer>
  </div>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/.js"></script>
  <script src="/js/schemes/pisces.js"></script>
  <script src="/.js"></script>
  <script src="/js/next-boot.js"></script>
  <script src="/.js"></script>
  <script>
    (function ()
    {
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x = document.getElementsByTagName("link");
      //Find the last canonical URL
      if (x.length > 0)
      {
        for (i = 0; i < x.length; i++)
        {
          if (x[i].rel.toLowerCase() == 'canonical' && x[i].href)
          {
            canonicalURL = x[i].href;
          }
        }
      }
      //Get protocol
      if (!canonicalURL)
      {
        curProtocol = window.location.protocol.split(':')[0];
      }
      else
      {
        curProtocol = canonicalURL.split(':')[0];
      }
      //Get current URL if the canonical URL does not exist
      if (!canonicalURL) canonicalURL = window.location.href;
      //Assign script content. Replace current URL with the canonical URL
      ! function ()
      {
        var e = /([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,
          r = canonicalURL,
          t = document.referrer;
        if (!e.test(r))
        {
          var n = (String(curProtocol).toLowerCase() === 'https') ? "https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif" : "//api.share.baidu.com/s.gif";
          t ? (n += "?r=" + encodeURIComponent(document.referrer), r && (n += "&l=" + r)) : r && (n += "?l=" + r);
          var i = new Image;
          i.src = n
        }
      }(window);
    })();

  </script>
  <script src="/js/local-search.js"></script>
  <script src="/.js"></script>
</body>

</html>
