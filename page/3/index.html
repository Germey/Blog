<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
  <meta name="theme-color" content="#222">
  <meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>
  <script id="hexo-configurations">
    var NexT = window.NexT ||
    {};
    var CONFIG = {
      "hostname": "cuiqingcai.com",
      "root": "/",
      "scheme": "Pisces",
      "version": "7.8.0",
      "exturl": false,
      "sidebar":
      {
        "position": "right",
        "width": 360,
        "display": "post",
        "padding": 18,
        "offset": 12,
        "onmobile": false,
        "widgets": [
          {
            "type": "image",
            "name": "阿布云",
            "enable": false,
            "url": "https://www.abuyun.com/http-proxy/introduce.html",
            "src": "https://cdn.cuiqingcai.com/88au8.jpg",
            "width": "100%"
      },
          {
            "type": "image",
            "name": "爬虫书",
            "url": "https://item.jd.com/13527222.html",
            "src": "https://cdn.cuiqingcai.com/ei5og.jpg",
            "width": "100%",
            "enable": true
      },
          {
            "type": "categories",
            "name": "分类",
            "enable": true
      },
          {
            "type": "image",
            "name": "IPIDEA",
            "url": "http://www.ipidea.net/?utm-source=cqc&utm-keyword=?cqc",
            "src": "https://cdn.cuiqingcai.com/0ywun.png",
            "width": "100%",
            "enable": false
      },
          {
            "type": "image",
            "name": "Storm Proxies",
            "src": "https://cdn.cuiqingcai.com/a2zad8.png",
            "url": "https://www.stormproxies.cn/?keyword=jingmi",
            "width": "100%",
            "enable": false
      },
          {
            "type": "friends",
            "name": "友情链接",
            "enable": true
      },
          {
            "type": "hot",
            "name": "猜你喜欢",
            "enable": true
      },
          {
            "type": "tags",
            "name": "标签云",
            "enable": true
      }]
      },
      "copycode":
      {
        "enable": true,
        "show_result": true,
        "style": "mac"
      },
      "back2top":
      {
        "enable": true,
        "sidebar": false,
        "scrollpercent": true
      },
      "bookmark":
      {
        "enable": false,
        "color": "#222",
        "save": "auto"
      },
      "fancybox": false,
      "mediumzoom": false,
      "lazyload": false,
      "pangu": true,
      "comments":
      {
        "style": "tabs",
        "active": "gitalk",
        "storage": true,
        "lazyload": false,
        "nav": null,
        "activeClass": "gitalk"
      },
      "algolia":
      {
        "hits":
        {
          "per_page": 10
        },
        "labels":
        {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      },
      "localsearch":
      {
        "enable": true,
        "trigger": "auto",
        "top_n_per_article": 10,
        "unescape": false,
        "preload": false
      },
      "motion":
      {
        "enable": false,
        "async": false,
        "transition":
        {
          "post_block": "bounceDownIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      "path": "search.xml"
    };

  </script>
  <meta name="keywords" content="爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书,静觅,崔庆才">
  <meta name="robots" content="index,follow">
  <meta name="GOOGLEBOT" content="index,follow">
  <meta name="author" content="静觅丨崔庆才的个人站点">
  <meta name="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
  <meta property="og:type" content="website">
  <meta property="og:title" content="静觅">
  <meta property="og:url" content="https://cuiqingcai.com/page/3/index.html">
  <meta property="og:site_name" content="静觅">
  <meta property="og:description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
  <meta property="og:locale" content="zh_CN">
  <meta property="article:author" content="崔庆才">
  <meta property="article:tag" content="爬虫教程">
  <meta property="article:tag" content="爬虫">
  <meta property="article:tag" content="Python">
  <meta property="article:tag" content="Python爬虫">
  <meta property="article:tag" content="Python爬虫教程">
  <meta property="article:tag" content="爬虫书">
  <meta property="article:tag" content="静觅">
  <meta property="article:tag" content="崔庆才">
  <meta name="twitter:card" content="summary">
  <link rel="canonical" href="https://cuiqingcai.com/page/3/">
  <script id="page-configurations">
    // https://hexo.io/docs/variables.html
    CONFIG.page = {
      sidebar: "",
      isHome: true,
      isPost: false,
      lang: 'zh-CN'
    };

  </script>
  <title>静觅丨崔庆才的个人站点 - Python爬虫教程</title>
  <meta name="google-site-verification" content="p_bIcnvirkFzG2dYKuNDivKD8-STet5W7D-01woA2fc" />
  <meta name="sogou_site_verification" content="kBOV53NQqT" />
  <noscript>
    <style>
      .use-motion .brand,
      .use-motion .menu-item,
      .sidebar-inner,
      .use-motion .post-block,
      .use-motion .pagination,
      .use-motion .comments,
      .use-motion .post-header,
      .use-motion .post-body,
      .use-motion .collection-header
      {
        opacity: initial;
      }

      .use-motion .site-title,
      .use-motion .site-subtitle
      {
        opacity: initial;
        top: initial;
      }

      .use-motion .logo-line-before i
      {
        left: initial;
      }

      .use-motion .logo-line-after i
      {
        right: initial;
      }

    </style>
  </noscript>
  <link rel="alternate" href="/atom.xml" title="静觅" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-container">
          <div class="site-nav-toggle">
            <div class="toggle" aria-label="切换导航栏">
              <span class="toggle-line toggle-line-first"></span>
              <span class="toggle-line toggle-line-middle"></span>
              <span class="toggle-line toggle-line-last"></span>
            </div>
          </div>
          <div class="site-meta">
            <a href="/" class="brand" rel="start">
              <span class="logo-line-before"><i></i></span>
              <h1 class="site-title">静觅 <span class="site-subtitle"> 崔庆才的个人站点 - Python爬虫教程 </span>
              </h1>
              <span class="logo-line-after"><i></i></span>
            </a>
          </div>
          <div class="site-nav-right">
            <div class="toggle popup-trigger">
              <i class="fa fa-search fa-fw fa-lg"></i>
            </div>
          </div>
        </div>
        <nav class="site-nav">
          <ul id="menu" class="main-menu menu">
            <li class="menu-item menu-item-home">
              <a href="/" rel="section">首页</a>
            </li>
            <li class="menu-item menu-item-archives">
              <a href="/archives/" rel="section">文章列表</a>
            </li>
            <li class="menu-item menu-item-tags">
              <a href="/tags/" rel="section">文章标签</a>
            </li>
            <li class="menu-item menu-item-categories">
              <a href="/categories/" rel="section">文章分类</a>
            </li>
            <li class="menu-item menu-item-about">
              <a href="/about/" rel="section">关于博主</a>
            </li>
            <li class="menu-item menu-item-message">
              <a href="/message/" rel="section">给我留言</a>
            </li>
            <li class="menu-item menu-item-search">
              <a role="button" class="popup-trigger">搜索 </a>
            </li>
          </ul>
        </nav>
        <div class="search-pop-overlay">
          <div class="popup search-popup">
            <div class="search-header">
              <span class="search-icon">
                <i class="fa fa-search"></i>
              </span>
              <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
              </div>
              <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
              </span>
            </div>
            <div id="search-result">
              <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span>0%</span>
    </div>
    <div class="reading-progress-bar"></div>
    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div class="content index posts-expand">
            <div class="carousel">
              <div id="wowslider-container">
                <div class="ws_images">
                  <ul>
                    <li><a target="_blank" href="https://item.jd.com/13527222.html"><img title="Python3网络爬虫开发实战（第二版）上市了！" src="https://cdn.cuiqingcai.com/prwgs.png" /></a></li>
                    <li><a target="_blank" href="https://t.lagou.com/fRCBRsRCSN6FA"><img title="52讲轻松搞定网络爬虫" src="https://cdn.cuiqingcai.com/fqq5e.png" /></a></li>
                    <li><a target="_blank" href="https://cuiqingcai.com/4320.html"><img title="Python3网络爬虫开发视频教程" src="https://cdn.cuiqingcai.com/bjrny.jpg" /></a></li>
                    <li><a target="_blank" href="https://cuiqingcai.com/5094.html"><img title="爬虫代理哪家强？十大付费代理详细对比评测出炉！" src="https://cdn.cuiqingcai.com/nifs6.jpg" /></a></li>
                  </ul>
                </div>
                <div class="ws_thumbs">
                  <div>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/prwgs.png" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/fqq5e.png" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/bjrny.jpg" /></a>
                    <a target="_blank" href="#"><img src="https://cdn.cuiqingcai.com/nifs6.jpg" /></a>
                  </div>
                </div>
                <div class="ws_shadow"></div>
              </div>
            </div>
            <link rel="stylesheet" href="/lib/wowslide/slide.css">
            <script src="/lib/wowslide/jquery.min.js"></script>
            <script src="/lib/wowslide/slider.js"></script>
            <script>
              jQuery("#wowslider-container").wowSlider(
              {
                effect: "cube",
                prev: "",
                next: "",
                duration: 20 * 100,
                delay: 100 * 100,
                width: 716,
                height: 297,
                autoPlay: true,
                playPause: true,
                stopOnHover: false,
                loop: false,
                bullets: 0,
                caption: true,
                captionEffect: "slide",
                controls: true,
                onBeforeStep: 0,
                images: 0
              });

            </script>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202232.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202232.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - parsel 的使用</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>前文我们了解了 lxml 使用 XPath 和 pyquery 使用 CSS Selector 来提取页面内容的方法，不论是 XPath 还是 CSS Selector，对于绝大多数的内容提取都足够了，大家可以选择适合自己的库来做内容提取。</p>
                  <p>不过这时候有人可能会问：我能不能二者穿插使用呀？有时候做内容提取的时候觉得 XPath 写起来比较方便，有时候觉得 CSS Selector 写起来比较方便，能不能二者结合起来使用呢？答案是可以的。</p>
                  <p>这里我们就介绍另一个解析库，叫做 parsel。</p>
                  <blockquote>
                    <p>注意：如果你用过 Scrapy 框架（后文会介绍）的话，你会发现 parsel 的 API 和 Scrapy 选择器的 API 极其相似，这是因为 Scrapy 的选择器就是基于 parsel 做了二次封装，因此学会了这个库的用法，后文 Scrapy 选择器的用法就融会贯通了。</p>
                  </blockquote>
                  <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2>
                  <p>parsel 这个库可以对 HTML 和 XML 进行解析，并支持使用 XPath 和 CSS Selector 对内容进行提取和修改，同时它还融合了正则表达式提取的功能。功能灵活而又强大，同时它也是 Python 最流行爬虫框架 Scrapy 的底层支持。</p>
                  <h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2>
                  <p>在本节开始之前，请确保已经安装好了 parsel 库，如尚未安装，可以使用 pip3 进行安装即可：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> parsel</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更详细的安装说明可以参考：<a href="https://setup.scrape.center/parsel。" target="_blank" rel="noopener">https://setup.scrape.center/parsel。</a></p>
                  <p>安装好之后，我们便可以开始本节的学习了。</p>
                  <h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2>
                  <p>首先我们还是用上一节的示例 HTML，声明 html 变量如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接着，一般我们会用 parsel 的 Selector 这个类来声明一个 Selector 对象，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们创建了一个 Selector 对象，传入了 text 参数，内容就是刚才声明的 HTML 字符串，赋值为 selector 变量。</p>
                  <p>有了 Selector 对象之后，我们可以使用 css 和 xpath 方法分别传入 CSS Selector 和 XPath 进行内容的提取，比如这里我们提取 class 包含 item-0 的节点，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">items = selector.css(<span class="string">'.item-0'</span>)</span><br><span class="line">print(len(items), type(items), items)</span><br><span class="line">items2 = selector.xpath(<span class="string">'//li[contains(@class, "item-0")]'</span>)</span><br><span class="line">print(len(items2), type(items), items2)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们先用 css 方法进行了节点提取，输出了提取结果的长度和内容，xpath 方法也是一样的写法，运行结果如下：</p>
                  <figure class="highlight">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">3 &lt;class 'parsel.selector.SelectorList'&gt; [&lt;Selector xpath="descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), ' item-0 ')]" data='&lt;li class="item-0"&gt;first item&lt;/li&gt;'&gt;, &lt;Selector xpath="descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), ' item-0 ')]" data='&lt;li class="item-0 active"&gt;&lt;a href="li...'&gt;, &lt;Selector xpath="descendant-or-self::*[@class and contains(concat(' ', normalize-space(@class), ' '), ' item-0 ')]" data='&lt;li class="item-0"&gt;&lt;a href="link5.htm...'&gt;]</span><br><span class="line">3 &lt;class 'parsel.selector.SelectorList'&gt; [&lt;Selector xpath='//li[contains(@class, "item-0")]' data='&lt;li class="item-0"&gt;first item&lt;/li&gt;'&gt;, &lt;Selector xpath='//li[contains(@class, "item-0")]' data='&lt;li class="item-0 active"&gt;&lt;a href="li...'&gt;, &lt;Selector xpath='//li[contains(@class, "item-0")]' data='&lt;li class="item-0"&gt;&lt;a href="link5.htm...'&gt;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到两个结果都是 SelectorList 对象，它其实是一个可迭代对象。另外可以用 len 方法获取它的长度，都是 3，提取结果代表的节点其实也是一样的，都是第 1、3、5 个 li 节点，每个节点还是以 Selector 对象的形式返回了，其中每个 Selector 对象的 data 属性里面包含了提取节点的 HTML 代码。</p>
                  <p>不过这里可能大家有个疑问，第一次我们不是用 css 方法来提取的节点吗？为什么结果中的 Selector 对象还输出了 xpath 属性而不是 css 属性呢？这是因为 css 方法背后，我们传入的 CSS Selector 首先被转成了 XPath，XPath 才真正被用作节点提取。其中 CSS Selector 转换为 XPath 这个过程是在底层用 cssselect 这个库实现的，比如 <code>.item-0</code> 这个 CSS Selector 转换为 XPath 的结果就是 <code>descendant-or-self::*[@class and contains(concat(&#39; &#39;, normalize-space(@class), &#39; &#39;), &#39; item-0 &#39;)]</code>，因此输出的 Selector 对象有了 xpath 属性了。不过这个大家不用担心，这个对提取结果是没有影响的，仅仅是换了一个表示方法而已。</p>
                  <h2 id="4-提取文本"><a href="#4-提取文本" class="headerlink" title="4. 提取文本"></a>4. 提取文本</h2>
                  <p>好，既然刚才提取的结果是一个可迭代对象 SelectorList，那么要获取提取到的所有 li 节点的文本内容就要对结果进行遍历了，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">items = selector.css(<span class="string">'.item-0'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    text = item.xpath(<span class="string">'.//text()'</span>).get()</span><br><span class="line">    print(text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们遍历了 items 变量，赋值为 item，那么这里 item 又变成了一个 Selector 对象，那么此时我们又可以调用其 css 或 xpath 方法进行内容提取了，比如这里我们就用 <code>.//text()</code> 这个 XPath 写法提取了当前节点的所有内容，此时如果不再调用其他方法，其返回结果应该依然为 Selector 构成的可迭代对象 SelectorList。SelectorList 有一个 get 方法，get 方法可以将 SelectorList 包含的 Selector 对象中的内容提取出来。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">first</span> <span class="built_in">item</span></span><br><span class="line"><span class="keyword">third</span> <span class="built_in">item</span></span><br><span class="line"><span class="keyword">fifth</span> <span class="built_in">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 get 方法的作用是从 SelectorList 里面提取第一个 Selector 对象，然后输出其中的结果。</p>
                  <p>我们再看一个实例：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = selector.xpath(<span class="string">'//li[contains(@class, "item-0")]//text()'</span>).get()</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">first</span> <span class="built_in">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其实这里我们使用 <code>//li[contains(@class, &quot;item-0&quot;)]//text()</code> 选取了所有 class 包含 item-0 的 li 节点的文本内容。应该来说，返回结果 SelectorList 应该对应三个 li 对象，而这里 get 方法仅仅返回了第一个 li 对象的文本内容，因为其实它会只提取第一个 Selector 对象的结果。</p>
                  <p>那有没有能提取所有 Selector 的对应内容的方法呢？有，那就是 getall 方法。</p>
                  <p>所以如果要提取所有对应的 li 节点的文本内容的话，写法可以改写为如下内容：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = selector.xpath(<span class="string">'//li[contains(@class, "item-0")]//text()'</span>).getall()</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'first item'</span>, <span class="string">'third item'</span>, <span class="string">'fifth item'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候，我们就能得到列表类型结果了，和 Selector 对象是一一对应的。</p>
                  <p>因此，如果要提取 SelectorList 里面对应的结果，可以使用 get 或 getall 方法，前者会获取第一个 Selector 对象里面的内容，后者会依次获取每个 Selector 对象对应的结果。</p>
                  <p>另外上述案例中，xpath 方法改写成 css 方法，可以这么实现：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = selector.css(<span class="string">'.item-0 *::text'</span>).getall()</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里<code>*</code> 用来提取所有子节点（包括纯文本节点），提取文本需要再加上<code>::text</code>，最终的运行结果是一样的。</p>
                  <p>到这里我们就简单了解了文本提取的方法。</p>
                  <h2 id="5-提取属性"><a href="#5-提取属性" class="headerlink" title="5. 提取属性"></a>5. 提取属性</h2>
                  <p>刚才我们演示了 HTML 中文本的提取，直接在 XPath 中加入 <code>//text()</code> 即可，那提取属性怎么做呢？类似的方式，也直接在 XPath 或者 CSS Selector 中表示出来就好了。</p>
                  <p>比如我们提取第三个 li 节点内部的 a 节点的 href 属性，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0.active a::attr(href)'</span>).get()</span><br><span class="line">print(result)</span><br><span class="line">result = selector.xpath(<span class="string">'//li[contains(@class, "item-0") and contains(@class, "active")]/a/@href'</span>).get()</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们实现了两种写法，分别用 css 和 xpath 方法实现。我们根据同时包含 item-0 和 active 这两个 class 为依据来选取第三个 li 节点，然后进一步选取了里面的 a 节点，对于 CSS Selector，选取属性需要加 <code>::attr()</code> 并传入对应的属性名称来选取，对于 XPath，直接用 <code>/@</code> 再加属性名称即可选取。最后统一用 get 方法提取结果即可。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">link3</span><span class="selector-class">.html</span></span><br><span class="line"><span class="selector-tag">link3</span><span class="selector-class">.html</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到两种方法都正确提取到了对应的 href 属性。</p>
                  <h2 id="6-正则提取"><a href="#6-正则提取" class="headerlink" title="6. 正则提取"></a>6. 正则提取</h2>
                  <p>除了常用的 css 和 xpath 方法，Selector 对象还提供了正则表达式提取方法，我们用一个实例来了解下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0'</span>).re(<span class="string">'link.*'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们先用 css 方法提取了所有 class 包含 item-0 的节点，然后使用 re 方法，传入了 <code>link.*</code>，用来匹配包含 link 的所有结果。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;'</span>, <span class="string">'link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，re 方法在这里遍历了所有提取到的 Selector 对象，然后根据传入的正则表达式查找出符合规则的节点源码并以列表的形式返回。</p>
                  <p>当然如果在调用 css 方法时已经提取了进一步的结果，比如提取了节点文本值，那么 re 方法就只会针对节点文本值进行提取：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0 *::text'</span>).re(<span class="string">'.*item'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight scheme">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="symbol">'first</span> item', <span class="symbol">'third</span> item', <span class="symbol">'fifth</span> item']</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外我们也可以利用 re_first 方法来提取第一个符合规则的结果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0'</span>).re_first(<span class="string">'&lt;span class="bold"&gt;(.*?)&lt;/span&gt;'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里调用了 re_first 方法，这里提取的是被 span 标签包含的文本值，提取结果用小括号括起来表示一个提取分组，最后输出的结果就是小括号部分对应的结果，运行结果如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">third</span> <span class="built_in">item</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过这几个例子我们知道了正则匹配的一些使用方法，re 对应多个结果，re_first 对应单个结果，可以在不同情况下选择对应的方法进行提取。</p>
                  <h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2>
                  <p>parsel 是一个融合了 XPath、CSS Selector 和正则表达式的提取库，功能强大又灵活，建议好好学习一下，同时也可以为后文学习 Scrapy 框架打下基础，有关 parsel 更多的用法可以参考其官方文档：<a href="https://parsel.readthedocs.io/。" target="_blank" rel="noopener">https://parsel.readthedocs.io/。</a></p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/ParselTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ParselTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-15 08:33:32" itemprop="dateCreated datePublished" datetime="2022-02-15T08:33:32+08:00">2022-02-15</time>
                </span>
                <span id="/202232.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - parsel 的使用" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>6.4k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>6 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202252.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202252.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - Ajax 分析方法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>这里还以前面的微博为例，我们知道拖动刷新的内容由 Ajax 加载，而且页面的 URL 没有变化，那么应该到哪里去查看这些 Ajax 请求呢？</p>
                  <h2 id="1-分析案例"><a href="#1-分析案例" class="headerlink" title="1. 分析案例"></a>1. 分析案例</h2>
                  <p>这里还需要借助浏览器的开发者工具，下面以 Chrome 浏览器为例来介绍。</p>
                  <p>首先，用 Chrome 浏览器打开微博的链接 <a href="https://m.weibo.cn/u/2830678474" target="_blank" rel="noopener">https://m.weibo.cn/u/2830678474</a>，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择) “检查” 选项，此时便会弹出开发者工具，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/7040b.png" alt=""></p>
                  <p>前面也提到过，这里其实就是在页面加载过程中浏览器与服务器之间发送请求和接收响应的所有记录。</p>
                  <p>Ajax 其实有其特殊的请求类型，它叫作 xhr。在图中我们可以发现一个名称以 getIndex 开头的请求，其 Type 为 xhr，这就是一个 Ajax 请求。用鼠标点击这个请求，可以查看这个请求的详细信息。</p>
                  <p><img src="https://cdn.cuiqingcai.com/1kiqe.png" alt=""></p>
                  <p>在右侧可以观察到其 Request Headers、URL 和 Response Headers 等信息。其中 Request Headers 中有一个信息为 <code>X-Requested-With:XMLHttpRequest</code>，这就标记了此请求是 Ajax 请求，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/t4hm0.png" alt=""></p>
                  <p>随后点击一下 Preview，即可看到响应的内容，它是 JSON 格式的。这里 Chrome 为我们自动做了解析，点击箭头即可展开和收起相应内容。</p>
                  <p>观察可以发现，这里的返回结果是我的个人信息，如昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。JavaScript 接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。</p>
                  <p><img src="https://cdn.cuiqingcai.com/kah0s.png" alt=""></p>
                  <p>另外，也可以切换到 Response 选项卡，从中观察到真实的返回数据，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/l1z1j.png" alt=""></p>
                  <p>接下来，切回到第一个请求，观察一下它的 Response 是什么，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/yfn4s.png" alt=""></p>
                  <p>这是最原始的链接 <a href="https://m.weibo.cn/u/2830678474" target="_blank" rel="noopener">https://m.weibo.cn/u/2830678474</a> 返回的结果，其代码只有不到 50 行，结构也非常简单，只是执行了一些 JavaScript。</p>
                  <p>所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是后来执行 JavaScript 后再次向后台发送了 Ajax 请求，浏览器拿到数据后再进一步渲染出来的。</p>
                  <h2 id="2-过滤请求"><a href="#2-过滤请求" class="headerlink" title="2. 过滤请求"></a>2. 过滤请求</h2>
                  <p>接下来，再利用 Chrome 开发者工具的筛选功能筛选出所有的 Ajax 请求。在请求的上方有一层筛选栏，直接点击 XHR，此时在下方显示的所有请求便都是 Ajax 请求了，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/0xqyh.png" alt=""></p>
                  <p>接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也一个个地出现 Ajax 请求，这样我们就可以捕获到所有的 Ajax 请求了。</p>
                  <p>随意点开一个条目，都可以清楚地看到其 Request URL、Request Headers、Response Headers、Response Body 等内容，此时想要模拟请求和提取就非常简单了。</p>
                  <p>下图所示的内容便是我的某一页微博的列表信息：</p>
                  <p><img src="https://cdn.cuiqingcai.com/3gv1x.png" alt=""></p>
                  <p>到现在为止，我们已经可以分析出 Ajax 请求的一些详细信息了，接下来只需要用程序模拟这些 Ajax 请求，就可以轻松提取我们所需要的信息了。</p>
                  <h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2>
                  <p>本节我们介绍了 Ajax 的基本原理和分析方法，在下一节中，我们用一个正式的实例来实现一下 Ajax 数据的爬取。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-14 21:11:31" itemprop="dateCreated datePublished" datetime="2022-02-14T21:11:31+08:00">2022-02-14</time>
                </span>
                <span id="/202252.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - Ajax 分析方法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202241.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202241.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 简易的TXT纯文本文件存储</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>将数据保存到 TXT 文本的操作非常简单，而且 TXT 文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用 TXT 文本存储。</p>
                  <p>本节中，我们就来看下利用 Python 保存 TXT 文本文件的方法。</p>
                  <h2 id="1-本节目标"><a href="#1-本节目标" class="headerlink" title="1. 本节目标"></a>1. 本节目标</h2>
                  <p>本节我们以电影示例网站 <a href="https://ssr1.scrape.center/" target="_blank" rel="noopener">https://ssr1.scrape.center/</a> 为例，爬取首页 10 部电影的数据，然后将相关信息存储为 TXT 文本格式。</p>
                  <h2 id="2-基本实例"><a href="#2-基本实例" class="headerlink" title="2. 基本实例"></a>2. 基本实例</h2>
                  <p>首先，可以用 requests 将网页源代码获取下来，然后使用 pyquery 解析库解析，接下来将提取的电影名称、类别、上映时间等信息保存到 TXT 文本中，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://ssr1.scrape.center/'</span></span><br><span class="line">html = requests.get(url).text</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">'.el-card'</span>).items()</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'movies.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="comment"># 电影名称</span></span><br><span class="line">    name = item.find(<span class="string">'a &gt; h2'</span>).text()</span><br><span class="line">    file.write(<span class="string">f'名称: <span class="subst">&#123;name&#125;</span>\n'</span>)</span><br><span class="line">    <span class="comment"># 类别</span></span><br><span class="line">    categories = [item.text() <span class="keyword">for</span> item <span class="keyword">in</span> item.find(<span class="string">'.categories button span'</span>).items()]</span><br><span class="line">    file.write(<span class="string">f'类别: <span class="subst">&#123;categories&#125;</span>\n'</span>)</span><br><span class="line">    <span class="comment"># 上映时间</span></span><br><span class="line">    published_at = item.find(<span class="string">'.info:contains(上映)'</span>).text()</span><br><span class="line">    published_at = re.search(<span class="string">'(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)'</span>, published_at).group(<span class="number">1</span>) \</span><br><span class="line">        <span class="keyword">if</span> published_at <span class="keyword">and</span> re.search(<span class="string">'\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;'</span>, published_at) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    file.write(<span class="string">f'上映时间: <span class="subst">&#123;published_at&#125;</span>\n'</span>)</span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    score = item.find(<span class="string">'p.score'</span>).text()</span><br><span class="line">    file.write(<span class="string">f'评分: <span class="subst">&#123;score&#125;</span>\n'</span>)</span><br><span class="line">    file.write(<span class="string">f'<span class="subst">&#123;<span class="string">"="</span> * <span class="number">50</span>&#125;</span>\n'</span>)</span><br><span class="line">file.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里主要是为了演示文件保存的方式，因此 requests 异常处理部分在此省去。首先，用 requests 提取首页的 HTML 代码，然后利用 pyquery 将电影的名称、类别、上映时间、评分信息提取出来。</p>
                  <p>利用 Python 提供的 open 方法打开一个文本文件，获取一个文件操作对象，这里赋值为 file，每提取一部分信息，就利用 file 对象的 write 方法将提取的内容写入文件。</p>
                  <p>全部提取完毕之后，最后调用 close 方法将其关闭，这样抓取的内容即可成功写入文本中了。</p>
                  <p>运行程序，可以发现在本地生成了一个 movies.txt 文件，其内容如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/uwg48.png" alt="image-20200531171232808"></p>
                  <p>这样电影信息的内容就被保存成文本形式了。</p>
                  <p>回过头来我们看下本节重点需要了解的内容，就是文本写入操作，其实就是 open、write、close 这三个方法的用法。</p>
                  <p>这里 open 方法的第一个参数即要保存的目标文件名称；第二个参数为 w，代表以覆盖写入的方式写入文本；另外，我们还指定了文件的编码为 utf-8。最后，写入完成后，还需要调用 close 方法来关闭文件对象。</p>
                  <h2 id="3-打开方式"><a href="#3-打开方式" class="headerlink" title="3. 打开方式"></a>3. 打开方式</h2>
                  <p>在刚才的实例中，open 方法的第二个参数设置成了 w，这样在每次写入文本时会清空源文件，然后将新的内容写入文件，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。</p>
                  <ul>
                    <li>r：以只读方式打开文件，意思就是只能读取文件内容，不能写入文件内容。这是默认模式。</li>
                    <li>rb：以二进制只读方式打开一个文件，通常用于打开二进制文件，比如音频、图片、视频等等。</li>
                    <li>r+：以读写方式打开一个文件，既可以读文件又可以写文件。</li>
                    <li>rb+：以二进制读写方式打开一个文件，同样既可以读又可以写，但读取和写入的都是二进制数据。</li>
                    <li>w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li>
                    <li>wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li>
                    <li>w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li>
                    <li>wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。</li>
                    <li>a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li>
                    <li>ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。</li>
                    <li>a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。</li>
                    <li>ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写。</li>
                  </ul>
                  <h2 id="4-简化写法"><a href="#4-简化写法" class="headerlink" title="4. 简化写法"></a>4. 简化写法</h2>
                  <p>另外，文件写入还有一种简写方法，那就是使用 with as 语法。在 with 控制块结束时，文件会自动关闭，所以就不需要再调用 close 方法了。</p>
                  <p>这种保存方式可以简写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">with</span> open(<span class="string">'movies.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>):</span><br><span class="line">    file.write(<span class="string">f'名称: <span class="subst">&#123;name&#125;</span>\n'</span>)</span><br><span class="line">    file.write(<span class="string">f'类别: <span class="subst">&#123;categories&#125;</span>\n'</span>)</span><br><span class="line">    file.write(<span class="string">f'上映时间: <span class="subst">&#123;published_at&#125;</span>\n'</span>)</span><br><span class="line">    file.write(<span class="string">f'评分: <span class="subst">&#123;score&#125;</span>\n'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>上面便是利用 Python 将结果保存为 TXT 文件的方法，这种方法简单易用，操作高效，是一种最基本的保存数据的方法。</p>
                  <h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2>
                  <p>本节我们了解了基本 TXT 文件存储的实现方式，建议熟练掌握。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/FileStorageTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/FileStorageTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-14 15:33:32" itemprop="dateCreated datePublished" datetime="2022-02-14T15:33:32+08:00">2022-02-14</time>
                </span>
                <span id="/202241.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 简易的TXT纯文本文件存储" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202231.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202231.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 网页解析利器 XPath</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>XPath，全称是 XML Path Language，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言。它最初是用来搜寻 XML 文档的，但是它同样适用于 HTML 文档的搜索。</p>
                  <p>所以在做爬虫时，我们完全可以使用 XPath 来做相应的信息抽取。本节我们就来了解下 XPath 的基本用法。</p>
                  <h2 id="1-XPath-概览"><a href="#1-XPath-概览" class="headerlink" title="1. XPath 概览"></a>1. XPath 概览</h2>
                  <p>XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式。另外，它还提供了超过 100 个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等。几乎所有我们想要定位的节点，都可以用 XPath 来选择。</p>
                  <p>XPath 于 1999 年 11 月 16 日成为 W3C 标准，它被设计为供 XSLT、XPointer 以及其他 XML 解析软件使用，更多的文档可以访问其官方网站：<a href="https://www.w3.org/TR/xpath/" target="_blank" rel="noopener">https://www.w3.org/TR/xpath/</a>。</p>
                  <h2 id="2-XPath-常用规则"><a href="#2-XPath-常用规则" class="headerlink" title="2. XPath 常用规则"></a>2. XPath 常用规则</h2>
                  <p>下表列举了 XPath 的几个常用规则。</p>
                  <p>表 XPath 常用规则</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">表　达　式</th>
                          <th style="text-align:left">描　　述</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>nodename</code></td>
                          <td style="text-align:left">选取此节点的所有子节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>/</code></td>
                          <td style="text-align:left">从当前节点选取直接子节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>//</code></td>
                          <td style="text-align:left">从当前节点选取子孙节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>.</code></td>
                          <td style="text-align:left">选取当前节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>..</code></td>
                          <td style="text-align:left">选取当前节点的父节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>@</code></td>
                          <td style="text-align:left">选取属性</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>这里列出了 XPath 的常用匹配规则，示例如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#x2F;&#x2F;title[@lang&#x3D;&#39;eng&#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是一个 XPath 规则，它代表选择所有名称为 <code>title</code>，同时属性 <code>lang</code> 的值为 <code>eng</code> 的节点。</p>
                  <p>后面会通过 Python 的 lxml 库，利用 XPath 进行 HTML 的解析。</p>
                  <h2 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3. 准备工作"></a>3. 准备工作</h2>
                  <p>使用之前，首先要确保安装好 lxml 库。如尚未安装，可以使用 pip3 来安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> lxml</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更详细的安装说明可以参考：<a href="https://setup.scrape.center/lxml。" target="_blank" rel="noopener">https://setup.scrape.center/lxml。</a></p>
                  <p>安装完成之后，我们就可以进行接下来的学习了。</p>
                  <h2 id="4-实例引入"><a href="#4-实例引入" class="headerlink" title="4. 实例引入"></a>4. 实例引入</h2>
                  <p>现在通过实例来感受一下使用 XPath 对网页进行解析的过程，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先导入 lxml 库的 etree 模块，然后声明了一段 HTML 文本，调用 HTML 类进行初始化，这样就成功构造了一个 XPath 解析对象。这里需要注意的是，HTML 文本中的最后一个 <code>li</code> 节点是没有闭合的，但是 etree 模块可以自动修正 HTML 文本。</p>
                  <p>这里我们调用 <code>tostring</code> 方法即可输出修正后的 HTML 代码，但是结果是 <code>bytes</code> 类型。这里利用 <code>decode</code> 方法将其转成 <code>str</code> 类型，结果如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-inactive"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link5.html"</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，经过处理之后，<code>li</code> 节点标签被补全，并且还自动添加了 <code>body</code>、<code>html</code> 节点。</p>
                  <p>另外，也可以直接读取文本文件进行解析，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中 test.html 的内容就是上面例子中的 HTML 代码，内容如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-inactive"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link5.html"</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这次的输出结果略有不同，多了一个 <code>DOCTYPE</code> 声明，不过对解析无任何影响，结果如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD HTML 4.0 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/REC-html40/loose.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-inactive"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link5.html"</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="5-所有节点"><a href="#5-所有节点" class="headerlink" title="5. 所有节点"></a>5. 所有节点</h2>
                  <p>我们一般会用 <code>//</code> 开头的 XPath 规则来选取所有符合要求的节点。这里以前面的 HTML 文本为例，如果要选取所有节点，可以这样实现：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//*'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&lt;Element html at <span class="number">0x10510d9c8</span>&gt;, &lt;Element body at <span class="number">0x10510da08</span>&gt;, &lt;Element div at <span class="number">0x10510da48</span>&gt;, &lt;Element ul at <span class="number">0x10510da88</span>&gt;, &lt;Element li at <span class="number">0x10510dac8</span>&gt;, &lt;Element a at <span class="number">0x10510db48</span>&gt;, &lt;Element li at <span class="number">0x10510db88</span>&gt;, &lt;Element a at <span class="number">0x10510dbc8</span>&gt;, &lt;Element li at <span class="number">0x10510dc08</span>&gt;, &lt;Element a at <span class="number">0x10510db08</span>&gt;, &lt;Element li at <span class="number">0x10510dc48</span>&gt;, &lt;Element a at <span class="number">0x10510dc88</span>&gt;, &lt;Element li at <span class="number">0x10510dcc8</span>&gt;, &lt;Element a at <span class="number">0x10510dd08</span>&gt;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里使用 <code>*</code> 代表匹配所有节点，也就是整个 HTML 文本中的所有节点都会被获取。可以看到，返回形式是一个列表，每个元素是 <code>Element</code> 类型，其后跟了节点的名称，如 <code>html</code>、<code>body</code>、<code>div</code>、<code>ul</code>、<code>li</code>、<code>a</code> 等，所有节点都包含在列表中了。</p>
                  <p>当然，此处匹配也可以指定节点名称。如果想获取所有 <code>li</code> 节点，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li'</span>)</span><br><span class="line">print(result)</span><br><span class="line">print(result[<span class="number">0</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里要选取所有 <code>li</code> 节点，可以使用 <code>//</code>，然后直接加上节点名称即可，调用时直接使用 <code>xpath</code> 方法即可。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&lt;Element li at <span class="number">0x105849208</span>&gt;, &lt;Element li at <span class="number">0x105849248</span>&gt;, &lt;Element li at <span class="number">0x105849288</span>&gt;, &lt;Element li at <span class="number">0x1058492c8</span>&gt;, &lt;Element li at <span class="number">0x105849308</span>&gt;]</span><br><span class="line">&lt;Element li at <span class="number">0x105849208</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里可以看到，提取结果是一个列表形式，其中每个元素都是一个 <code>Element</code> 对象。如果要取出其中一个对象，可以直接用中括号加索引，如 <code>[0]</code>。</p>
                  <h2 id="6-子节点"><a href="#6-子节点" class="headerlink" title="6. 子节点"></a>6. 子节点</h2>
                  <p>我们通过 <code>/</code> 或 <code>//</code> 即可查找元素的子节点或子孙节点。假如现在想选择 <code>li</code> 节点的所有直接子节点 <code>a</code>，可以这样实现：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li/a'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里通过追加 <code>/a</code> 即选择了所有 <code>li</code> 节点的所有直接子节点 <code>a</code>。因为 <code>//li</code> 用于选中所有 <code>li</code> 节点，<code>/a</code> 用于选中 <code>li</code> 节点的所有直接子节点 <code>a</code>，二者组合在一起即获取所有 <code>li</code> 节点的所有直接子节点 <code>a</code>。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&lt;Element a at <span class="number">0x106ee8688</span>&gt;, &lt;Element a at <span class="number">0x106ee86c8</span>&gt;, &lt;Element a at <span class="number">0x106ee8708</span>&gt;, &lt;Element a at <span class="number">0x106ee8748</span>&gt;, &lt;Element a at <span class="number">0x106ee8788</span>&gt;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此处的 <code>/</code> 用于选取直接子节点，如果要获取所有子孙节点，就可以使用 <code>//</code>。例如，要获取 <code>ul</code> 节点下的所有子孙节点 <code>a</code>，可以这样实现：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//ul//a'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果是相同的。</p>
                  <p>但是如果这里用 <code>//ul/a</code>，就无法获取任何结果了。因为 <code>/</code> 用于获取直接子节点，而在 <code>ul</code> 节点下没有直接的 <code>a</code> 子节点，只有 <code>li</code> 节点，所以无法获取任何匹配结果，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//ul/a'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>因此，这里我们要注意 <code>/</code> 和 <code>//</code> 的区别，其中 <code>/</code> 用于获取直接子节点，<code>//</code> 用于获取子孙节点。</p>
                  <h2 id="7-父节点"><a href="#7-父节点" class="headerlink" title="7. 父节点"></a>7. 父节点</h2>
                  <p>我们知道通过连续的 <code>/</code> 或 <code>//</code> 可以查找子节点或子孙节点，那么假如我们知道了子节点，怎样来查找父节点呢？这可以用 <code>..</code> 来实现。</p>
                  <p>比如，现在首先选中 <code>href</code> 属性为 <code>link4.html</code> 的 <code>a</code> 节点，然后获取其父节点，再获取其 <code>class</code> 属性，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//a[@href="link4.html"]/../@class'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#39;item-1&#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>检查一下结果发现，这正是我们获取的目标 <code>li</code> 节点的 <code>class</code> 属性。</p>
                  <p>同时，我们也可以通过 <code>parent::</code> 来获取父节点，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//a[@href="link4.html"]/parent::*/@class'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="8-属性匹配"><a href="#8-属性匹配" class="headerlink" title="8. 属性匹配"></a>8. 属性匹配</h2>
                  <p>在选取的时候，我们还可以用 <code>@</code> 符号进行属性过滤。比如，这里如果要选取 <code>class</code> 为 <code>item-0</code> 的 <code>li</code> 节点，可以这样实现:</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们通过加入 <code>[@class=&quot;item-0&quot;]</code>，限制了节点的 <code>class</code> 属性为 <code>item-0</code>，而 HTML 文本中符合条件的 <code>li</code> 节点有两个，所以结果应该返回两个匹配到的元素。结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;Element li at <span class="number">0x10a399288</span>&gt;, &lt;Element li at <span class="number">0x10a3992c8</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可见，匹配结果正是两个，至于是不是那正确的两个，后面再验证。</p>
                  <h2 id="9-文本获取"><a href="#9-文本获取" class="headerlink" title="9. 文本获取"></a>9. 文本获取</h2>
                  <p>我们用 XPath 中的 <code>text</code> 方法获取节点中的文本，接下来尝试获取前面 <code>li</code> 节点中的文本，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#39;\n     &#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>奇怪的是，我们并没有获取到任何文本，只获取到了一个换行符，这是为什么呢？因为 XPath 中 <code>text</code> 方法前面是 <code>/</code>，而此处 <code>/</code> 的含义是选取直接子节点，很明显 <code>li</code> 的直接子节点都是 <code>a</code> 节点，文本都是在 <code>a</code> 节点内部的，所以这里匹配到的结果就是被修正的 <code>li</code> 节点内部的换行符，因为自动修正的 <code>li</code> 节点的尾标签换行了。</p>
                  <p>即选中的是这两个节点：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link5.html"</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中一个节点因为自动修正，<code>li</code> 节点的尾标签添加的时候换行了，所以提取文本得到的唯一结果就是 <code>li</code> 节点的尾标签和 <code>a</code> 节点的尾标签之间的换行符。</p>
                  <p>因此，如果想获取 <code>li</code> 节点内部的文本，就有两种方式，一种是先选取 <code>a</code> 节点再获取文本，另一种就是使用 <code>//</code>。接下来，我们来看下二者的区别。</p>
                  <p>首先，选取 <code>a</code> 节点再获取文本，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]/a/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#39;first item&#39;, &#39;fifth item&#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里的返回值是两个，内容都是属性为 <code>item-0</code> 的 <code>li</code> 节点的文本，这也印证了前面属性匹配的结果是正确的。</p>
                  <p>这里我们是逐层选取的，先选取了 <code>li</code> 节点，又利用 <code>/</code> 选取了其直接子节点 <code>a</code>，然后再选取其文本，得到的结果恰好是符合我们预期的两个结果。</p>
                  <p>再来看下用另一种方式（即使用 <code>//</code>）选取的结果，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li[@class="item-0"]//text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'first item'</span>, <span class="string">'fifth item'</span>, <span class="string">'\n     '</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>不出所料，这里的返回结果是 3 个。可想而知，这里是选取所有子孙节点的文本，其中前两个就是 <code>li</code> 的子节点 <code>a</code> 内部的文本，另外一个就是最后一个 <code>li</code> 节点内部的文本，即换行符。</p>
                  <p>所以说，如果要想获取子孙节点内部的所有文本，可以直接用 <code>//</code> 加 <code>text</code> 方法的方式，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符。如果想获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用 <code>text</code> 方法获取其内部文本，这样可以保证获取的结果是整洁的。</p>
                  <h2 id="10-属性获取"><a href="#10-属性获取" class="headerlink" title="10. 属性获取"></a>10. 属性获取</h2>
                  <p>我们知道用 <code>text</code> 方法可以获取节点内部文本，那么节点属性该怎样获取呢？其实还是用 <code>@</code> 符号就可以。例如，我们想获取所有 <code>li</code> 节点下所有 <code>a</code> 节点的 <code>href</code> 属性，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">'./test.html'</span>, etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">'//li/a/@href'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们通过 <code>@href</code> 即可获取节点的 <code>href</code> 属性。注意，此处和属性匹配的方法不同，属性匹配是中括号加属性名和值来限定某个属性，如 <code>[@href=&quot;link1.html&quot;]</code>，而此处的 <code>@href</code> 指的是获取节点的某个属性，二者需要做好区分。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'link1.html'</span>, <span class="string">'link2.html'</span>, <span class="string">'link3.html'</span>, <span class="string">'link4.html'</span>, <span class="string">'link5.html'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，我们成功获取了所有 <code>li</code> 节点下 <code>a</code> 节点的 <code>href</code> 属性，它们以列表形式返回。</p>
                  <h2 id="11-属性多值匹配"><a href="#11-属性多值匹配" class="headerlink" title="11. 属性多值匹配"></a>11. 属性多值匹配</h2>
                  <p>有时候，某些节点的某个属性可能有多个值，例如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">'//li[@class="li"]/a/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 HTML 文本中 <code>li</code> 节点的 <code>class</code> 属性有两个值 <code>li</code> 和 <code>li-first</code>，此时如果还想用之前的属性匹配获取，就无法匹配了，此时的运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时就需要用 <code>contains</code> 方法了，代码可以改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">'//li[contains(@class, "li")]/a/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样通过 <code>contains</code> 方法，给其第一个参数传入属性名称，第二个参数传入属性值，只要此属性包含所传入的属性值，就可以完成匹配了。</p>
                  <p>此时运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#39;first item&#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此种方式在某个节点的某个属性有多个值时经常用到，如某个节点的 <code>class</code> 属性通常有多个。</p>
                  <h2 id="12-多属性匹配"><a href="#12-多属性匹配" class="headerlink" title="12. 多属性匹配"></a>12. 多属性匹配</h2>
                  <p>另外，我们可能还遇到一种情况，那就是根据多个属性确定一个节点，这时就需要同时匹配多个属性。此时可以使用运算符 <code>and</code> 来连接，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;li class="li li-first" name="item"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">'//li[contains(@class, "li") and @name="item"]/a/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里的 <code>li</code> 节点又增加了一个属性 <code>name</code>。要确定这个节点，需要同时根据 <code>class</code> 和 <code>name</code> 属性来选择，一个条件是 <code>class</code> 属性里面包含 <code>li</code> 字符串，另一个条件是 <code>name</code> 属性为 <code>item</code> 字符串，二者需要同时满足，需要用 <code>and</code> 操作符相连，相连之后置于中括号内进行条件筛选。运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&#39;first item&#39;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里的 <code>and</code> 其实是 XPath 中的运算符。另外，还有很多运算符，如 <code>or</code>、<code>mod</code> 等，在此总结为表 3-。</p>
                  <p>表 3- 运算符及其介绍</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">运算符</th>
                          <th style="text-align:left">描　　述</th>
                          <th style="text-align:left">实　　例</th>
                          <th style="text-align:left">返　回　值</th>
                          <th style="text-align:left"></th>
                          <th style="text-align:left"></th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>or</code></td>
                          <td style="text-align:left">或</td>
                          <td style="text-align:left"><code>age=19 or age=20</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 19，则返回 <code>true</code>。如果 <code>age</code> 是 21，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>and</code></td>
                          <td style="text-align:left">与</td>
                          <td style="text-align:left"><code>age&gt;19 and age&lt;21</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 20，则返回 <code>true</code>。如果 <code>age</code> 是 18，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>mod</code></td>
                          <td style="text-align:left">计算除法的余数</td>
                          <td style="text-align:left"><code>5 mod 2</code></td>
                          <td style="text-align:left">1</td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left">`</td>
                          <td style="text-align:left">`</td>
                          <td style="text-align:left">计算两个节点集</td>
                          <td style="text-align:left">`//book</td>
                          <td style="text-align:left">//cd`</td>
                          <td style="text-align:left">返回所有拥有 <code>book</code> 和 <code>cd</code> 元素的节点集</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>+</code></td>
                          <td style="text-align:left">加法</td>
                          <td style="text-align:left"><code>6 + 4</code></td>
                          <td style="text-align:left">10</td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>-</code></td>
                          <td style="text-align:left">减法</td>
                          <td style="text-align:left"><code>6 - 4</code></td>
                          <td style="text-align:left">2</td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>*</code></td>
                          <td style="text-align:left">乘法</td>
                          <td style="text-align:left"><code>6 * 4</code></td>
                          <td style="text-align:left">24</td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>div</code></td>
                          <td style="text-align:left">除法</td>
                          <td style="text-align:left"><code>8 div 4</code></td>
                          <td style="text-align:left">2</td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>=</code></td>
                          <td style="text-align:left">等于</td>
                          <td style="text-align:left"><code>age=19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 19，则返回 <code>true</code>。如果 <code>age</code> 是 20，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>!=</code></td>
                          <td style="text-align:left">不等于</td>
                          <td style="text-align:left"><code>age!=19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 18，则返回 <code>true</code>。如果 <code>age</code> 是 19，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>&lt;</code></td>
                          <td style="text-align:left">小于</td>
                          <td style="text-align:left"><code>age&lt;19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 18，则返回 <code>true</code>。如果 <code>age</code> 是 19，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>&lt;=</code></td>
                          <td style="text-align:left">小于或等于</td>
                          <td style="text-align:left"><code>&lt;=19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 19，则返回 <code>true</code>。如果 <code>age</code> 是 <code>20</code>，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>&gt;</code></td>
                          <td style="text-align:left">大于</td>
                          <td style="text-align:left"><code>age&gt;19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 20，则返回 <code>true</code>。如果 <code>age</code> 是 19，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                          <td style="text-align:left"></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>&gt;=</code></td>
                          <td style="text-align:left">大于或等于</td>
                          <td style="text-align:left"><code>age&gt;=19</code></td>
                          <td style="text-align:left">如果 <code>age</code> 是 19，则返回 <code>true</code>。如果 <code>age</code> 是 18，则返回 <code>false</code></td>
                          <td style="text-align:left"></td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>此表参考来源：<a href="http://www.w3school.com.cn/xpath/xpath_operators.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/xpath_operators.asp</a>。</p>
                  <h2 id="13-按序选择"><a href="#13-按序选择" class="headerlink" title="13. 按序选择"></a>13. 按序选择</h2>
                  <p>有时候，我们在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，这时该怎么办呢？</p>
                  <p>这时可以利用中括号传入索引的方法获取特定次序的节点，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/a/text()'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[last()]/a/text()'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[position()&lt;3]/a/text()'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[last()-2]/a/text()'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一次选择时，我们选取了第一个 <code>li</code> 节点，中括号中传入数字 1 即可。注意，这里和代码中不同，序号是以 1 开头的，不是以 0 开头。</p>
                  <p>第二次选择时，我们选取了最后一个 <code>li</code> 节点，中括号中调用 <code>last</code> 方法即可。</p>
                  <p>第三次选择时，我们选取了位置小于 3 的 <code>li</code> 节点，也就是位置序号为 1 和 2 的节点，得到的结果就是前两个 <code>li</code> 节点。</p>
                  <p>第四次选择时，我们选取了倒数第三个 <code>li</code> 节点，中括号中调用 <code>last</code> 方法再减去 2 即可。因为 <code>last</code> 方法代表最后一个，在此基础减 2 就是倒数第三个。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'first item'</span>]</span><br><span class="line">[<span class="string">'fifth item'</span>]</span><br><span class="line">[<span class="string">'first item'</span>, <span class="string">'second item'</span>]</span><br><span class="line">[<span class="string">'third item'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们使用了 <code>last</code>、<code>position</code> 等方法。在 XPath 中，提供了 100 多个方法，包括存取、数值、字符串、逻辑、节点、序列等处理功能，它们的具体作用可以参考：<a href="http://www.w3school.com.cn/xpath/xpath_functions.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/xpath_functions.asp</a>。</p>
                  <h2 id="14-节点轴选择"><a href="#14-节点轴选择" class="headerlink" title="14. 节点轴选择"></a>14. 节点轴选择</h2>
                  <p>XPath 提供了很多节点轴选择方法，包括获取子元素、兄弟元素、父元素、祖先元素等，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;&lt;span&gt;first item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/ancestor::*'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/ancestor::div'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/attribute::*'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/child::a[@href="link1.html"]'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/descendant::span'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/following::*[2]'</span>)</span><br><span class="line">print(result)</span><br><span class="line">result = html.xpath(<span class="string">'//li[1]/following-sibling::*'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[&lt;Element html at <span class="number">0x107941808</span>&gt;, &lt;Element body at <span class="number">0x1079418c8</span>&gt;, &lt;Element div at <span class="number">0x107941908</span>&gt;, &lt;Element ul at <span class="number">0x107941948</span>&gt;]</span><br><span class="line">[&lt;Element div at <span class="number">0x107941908</span>&gt;]</span><br><span class="line">[<span class="string">'item-0'</span>]</span><br><span class="line">[&lt;Element a at <span class="number">0x1079418c8</span>&gt;]</span><br><span class="line">[&lt;Element span at <span class="number">0x107941948</span>&gt;]</span><br><span class="line">[&lt;Element a at <span class="number">0x1079418c8</span>&gt;]</span><br><span class="line">[&lt;Element li at <span class="number">0x107941948</span>&gt;, &lt;Element li at <span class="number">0x107941988</span>&gt;, &lt;Element li at <span class="number">0x1079419c8</span>&gt;, &lt;Element li at <span class="number">0x107941a08</span>&gt;]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一次选择时，我们调用了 <code>ancestor</code> 轴，可以获取所有祖先节点。其后需要跟两个冒号，然后是节点的选择器，这里我们直接使用 <code>*</code>，表示匹配所有节点，因此返回结果是第一个 <code>li</code> 节点的所有祖先节点，包括 <code>html</code>、<code>body</code>、<code>div</code> 和 <code>ul</code>。</p>
                  <p>第二次选择时，我们又加了限定条件，这次在冒号后面加了 <code>div</code>，这样得到的结果就只有 <code>div</code> 这个祖先节点了。</p>
                  <p>第三次选择时，我们调用了 <code>attribute</code> 轴，可以获取所有属性值，其后跟的选择器还是 <code>*</code>，这代表获取节点的所有属性，返回值就是 <code>li</code> 节点的所有属性值。</p>
                  <p>第四次选择时，我们调用了 <code>child</code> 轴，可以获取所有直接子节点。这里我们又加了限定条件，选取 <code>href</code> 属性为 <code>link1.html</code> 的 <code>a</code> 节点。</p>
                  <p>第五次选择时，我们调用了 <code>descendant</code> 轴，可以获取所有子孙节点。这里我们又加了限定条件获取 <code>span</code> 节点，所以返回的结果只包含 <code>span</code> 节点而不包含 <code>a</code> 节点。</p>
                  <p>第六次选择时，我们调用了 <code>following</code> 轴，可以获取当前节点之后的所有节点。这里我们虽然使用的是 <code>*</code> 匹配，但又加了索引选择，所以只获取了第二个后续节点。</p>
                  <p>第七次选择时，我们调用了 <code>following-sibling</code> 轴，可以获取当前节点之后的所有同级节点。这里我们使用 <code>*</code> 匹配，所以获取了所有后续同级节点。</p>
                  <p>以上是 XPath 轴的简单用法，更多轴的用法可以参考：<a href="http://www.w3school.com.cn/xpath/xpath_axes.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/xpath_axes.asp</a>。</p>
                  <h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h2>
                  <p>到现在为止，我们基本上把可能用到的 XPath 选择器介绍完了。XPath 功能非常强大，内置函数非常多，熟练使用之后，可以大大提升 HTML 信息的提取效率。</p>
                  <p>如果想查询更多 XPath 的用法，可以查看：<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/xpath/index.asp</a>。</p>
                  <p>如果想查询更多 Python lxml 库的用法，可以查看 <a href="http://lxml.de/" target="_blank" rel="noopener">http://lxml.de/</a>。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/XPathTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/XPathTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-14 15:33:32" itemprop="dateCreated datePublished" datetime="2022-02-14T15:33:32+08:00">2022-02-14</time>
                </span>
                <span id="/202231.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 网页解析利器 XPath" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>14k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>13 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202243.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202243.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 高效实用的 MongoDB 文档存储</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>NoSQL，全称 Not Only SQL，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于键值对的，而且不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p>
                  <p>非关系型数据库又可细分如下：</p>
                  <ul>
                    <li>键值存储数据库：其代表有 Redis、Voldemort 和 Oracle BDB 等。</li>
                    <li>列存储数据库：其代表有 Cassandra、HBase 和 Riak 等。</li>
                    <li>文档型数据库：其代表有 CouchDB 和 MongoDB 等。</li>
                    <li>键值存储数据库：其代表有 Redis、Voldemort 和 Oracle BDB 等。</li>
                    <li>图形数据库：其代表有 Neo4J、InfoGrid 和 Infinite Graph 等。</li>
                  </ul>
                  <p>对于爬虫的数据存储来说，一条数据可能存在某些字段提取失败而缺失的情况，而且数据可能随时调整。另外，数据之间还存在嵌套关系。如果使用关系型数据库存储，一是需要提前建表，二是如果存在数据嵌套关系的话，需要进行序列化操作才可以存储，这非常不方便。如果用了非关系型数据库，就可以避免一些麻烦，更简单、高效。</p>
                  <p>本节中，我们主要介绍 MongoDB 存储操作。</p>
                  <p>MongoDB 是由 C++ 语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看 Python 3 下 MongoDB 的存储操作。</p>
                  <h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2>
                  <p>在开始之前，请确保已经安装好了 MongoDB 并启动了其服务，安装方式可以参考：<a href="https://setup.scrape.center/mongodb。" target="_blank" rel="noopener">https://setup.scrape.center/mongodb。</a></p>
                  <p>除了安装好 MongoDB 数据库，我们还需要安装好 Python 的 PyMongo 库，如尚未安装，可以使用 pip3 来安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> pymongo</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更详细的安装说明可以参考：<a href="https://setup.scrape.center/pymongo。" target="_blank" rel="noopener">https://setup.scrape.center/pymongo。</a></p>
                  <p>安装好 MongoDB 数据库和 PyMongo 库之后，我们便可以开始本节的学习了。</p>
                  <h2 id="2-连接-MongoDB"><a href="#2-连接-MongoDB" class="headerlink" title="2. 连接 MongoDB"></a>2. 连接 MongoDB</h2>
                  <p>连接 MongoDB 时，我们需要使用 PyMongo 库里面的 <code>MongoClient</code>。一般来说，传入 MongoDB 的 IP 及端口即可，其中第一个参数为地址 <code>host</code>，第二个参数为端口 <code>port</code>（如果不给它传递参数，默认是 27017）：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以创建 MongoDB 的连接对象了。</p>
                  <p>另外，<code>MongoClient</code> 的第一个参数 <code>host</code> 还可以直接传入 MongoDB 的连接字符串，它以 <code>mongodb</code> 开头，例如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这也可以达到同样的连接效果。</p>
                  <h2 id="3-指定数据库"><a href="#3-指定数据库" class="headerlink" title="3. 指定数据库"></a>3. 指定数据库</h2>
                  <p>在 MongoDB 中，可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以 test 数据库为例来说明，下一步需要在程序中指定要使用的数据库：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">db = client.test</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里调用 <code>client</code> 的 <code>test</code> 属性即可返回 test 数据库。当然，我们也可以这样指定：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">db = client[<span class="string">'test'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这两种方式是等价的。</p>
                  <h2 id="4-指定集合"><a href="#4-指定集合" class="headerlink" title="4. 指定集合"></a>4. 指定集合</h2>
                  <p>MongoDB 的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。</p>
                  <p>下一步需要指定要操作的集合，这里指定一个集合名称为 <code>students</code>。与指定数据库类似，指定集合也有两种方式：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">collection = db.students</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">collection = db[<span class="string">'students'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们便声明了一个集合对象。</p>
                  <h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2>
                  <p>接下来，便可以插入数据了。对于 <code>students</code> 这个集合，新建一条学生数据，这条数据以字典形式表示：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用 <code>collection</code> 的 <code>insert</code> 方法即可插入数据，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = collection.insert(student)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在 MongoDB 中，每条数据其实都有一个 <code>_id</code> 属性来唯一标识。如果没有显式指明该属性，MongoDB 会自动产生一个 <code>ObjectId</code> 类型的 <code>_id</code> 属性。<code>insert</code> 方法会在执行后返回 <code>_id</code> 值。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">5932</span>a68615c2606814c91f3d</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert([student1, student2])</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回结果是对应的 <code>_id</code> 的集合：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[ObjectId(<span class="string">'5932a80115c2606a59e8a048'</span>), ObjectId(<span class="string">'5932a80115c2606a59e8a049'</span>)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>实际上，在 PyMongo 3.x 版本中，官方已经不推荐使用 <code>insert</code> 方法了。当然，继续使用也没有什么问题。官方推荐使用 <code>insert_one</code> 和 <code>insert_many</code> 方法来分别插入单条记录和多条记录，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.InsertOneResult object at <span class="number">0x10d68b558</span>&gt;</span><br><span class="line"><span class="number">5932</span>ab0f15c2606f0c1cf6c5</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>与 <code>insert</code> 方法不同，这次返回的是 <code>InsertOneResult</code> 对象，我们可以调用其 <code>inserted_id</code> 属性获取 <code>_id</code>。</p>
                  <p>对于 <code>insert_many</code> 方法，我们可以将数据以列表形式传递，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.InsertManyResult object at <span class="number">0x101dea558</span>&gt;</span><br><span class="line">[ObjectId(<span class="string">'5932abf415c2607083d3b2ac'</span>), ObjectId(<span class="string">'5932abf415c2607083d3b2ad'</span>)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>该方法返回的是 <code>InsertManyResult</code> 类型的对象，调用 <code>inserted_ids</code> 属性可以获取插入数据的 <code>_id</code> 列表。</p>
                  <h2 id="6-查询"><a href="#6-查询" class="headerlink" title="6. 查询"></a>6. 查询</h2>
                  <p>插入数据后，我们可以利用 <code>find_one</code> 或 <code>find</code> 方法进行查询，其中 <code>find_one</code> 查询得到的是单个结果，<code>find</code> 则返回一个生成器对象。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;)</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们查询 <code>name</code> 为 <code>Mike</code> 的数据，它的返回结果是字典类型，运行结果如下：</p>
                  <figure class="highlight">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">&#123;'_id': ObjectId('5932a80115c2606a59e8a049'), 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male'&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，它多了 <code>_id</code> 属性，这就是 MongoDB 在插入过程中自动添加的。</p>
                  <p>此外，我们也可以根据 <code>ObjectId</code> 来查询，此时需要使用 bson 库里面的 <code>objectid</code>：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278c115c2602667ec6bae'</span>)&#125;)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其查询结果依然是字典类型，具体如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278c115c2602667ec6bae'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，如果查询结果不存在，则会返回 <code>None</code>。</p>
                  <p>对于多条数据的查询，我们可以使用 <code>find</code> 方法。例如，这里查找年龄为 20 的数据，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;)</span><br><span class="line">print(results)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.cursor.Cursor object at <span class="number">0x1032d5128</span>&gt;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278c115c2602667ec6bae'</span>), <span class="string">'id'</span>: <span class="string">'20170101'</span>, <span class="string">'name'</span>: <span class="string">'Jordan'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278c815c2602678bb2b8d'</span>), <span class="string">'id'</span>: <span class="string">'20170102'</span>, <span class="string">'name'</span>: <span class="string">'Kevin'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: ObjectId(<span class="string">'593278d815c260269d7645a8'</span>), <span class="string">'id'</span>: <span class="string">'20170103'</span>, <span class="string">'name'</span>: <span class="string">'Harden'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'gender'</span>: <span class="string">'male'</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回结果是 <code>Cursor</code> 类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。</p>
                  <p>如果要查询年龄大于 20 的数据，则写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号 <code>$gt</code>，意思是大于，键值为 20。</p>
                  <p>这里将比较符号归纳为表 5-3。</p>
                  <p>表 5-3 比较符号</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">符　　号</th>
                          <th style="text-align:left">含　　义</th>
                          <th style="text-align:left">示　　例</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>$lt</code></td>
                          <td style="text-align:left">小于</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$lt&#39;: 20}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$gt</code></td>
                          <td style="text-align:left">大于</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$gt&#39;: 20}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$lte</code></td>
                          <td style="text-align:left">小于等于</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$lte&#39;: 20}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$gte</code></td>
                          <td style="text-align:left">大于等于</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$gte&#39;: 20}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$ne</code></td>
                          <td style="text-align:left">不等于</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$ne&#39;: 20}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$in</code></td>
                          <td style="text-align:left">在范围内</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$in&#39;: [20, 23]}}</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$nin</code></td>
                          <td style="text-align:left">不在范围内</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$nin&#39;: [20, 23]}}</code></td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>另外，还可以进行正则匹配查询。例如，查询名字以 M 开头的学生数据，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find(&#123;<span class="string">'name'</span>: &#123;<span class="string">'$regex'</span>: <span class="string">'^M.*'</span>&#125;&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里使用 <code>$regex</code> 来指定正则匹配，<code>^M.*</code> 代表以 M 开头的正则表达式。</p>
                  <p>这里将一些功能符号再归类为下表。</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">符　　号</th>
                          <th style="text-align:left">含　　义</th>
                          <th style="text-align:left">示　　例</th>
                          <th style="text-align:left">示例含义</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>$regex</code></td>
                          <td style="text-align:left">匹配正则表达式</td>
                          <td style="text-align:left"><code>{&#39;name&#39;: {&#39;$regex&#39;: &#39;^M.*&#39;}}</code></td>
                          <td style="text-align:left"><code>name</code> 以 M 开头</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$exists</code></td>
                          <td style="text-align:left">属性是否存在</td>
                          <td style="text-align:left">{<code>&#39;name&#39;: {&#39;$exists&#39;: True}}</code></td>
                          <td style="text-align:left"><code>name</code> 属性存在</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$type</code></td>
                          <td style="text-align:left">类型判断</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$type&#39;: &#39;int&#39;}}</code></td>
                          <td style="text-align:left"><code>age</code> 的类型为 <code>int</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$mod</code></td>
                          <td style="text-align:left">数字模操作</td>
                          <td style="text-align:left"><code>{&#39;age&#39;: {&#39;$mod&#39;: [5, 0]}}</code></td>
                          <td style="text-align:left">年龄模 5 余 0</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$text</code></td>
                          <td style="text-align:left">文本查询</td>
                          <td style="text-align:left"><code>{&#39;$text&#39;: {&#39;$search&#39;: &#39;Mike&#39;}}</code></td>
                          <td style="text-align:left"><code>text</code> 类型的属性中包含 <code>Mike</code> 字符串</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$where</code></td>
                          <td style="text-align:left">高级条件查询</td>
                          <td style="text-align:left"><code>{&#39;$where&#39;: &#39;obj.fans_count == obj.follows_count&#39;}</code></td>
                          <td style="text-align:left">自身粉丝数等于关注数</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>关于这些操作的更详细用法，可以在 MongoDB 官方文档找到： <a href="https://docs.mongodb.com/manual/reference/operator/query/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/</a>。</p>
                  <h2 id="7-计数"><a href="#7-计数" class="headerlink" title="7. 计数"></a>7. 计数</h2>
                  <p>要统计查询结果有多少条数据，可以调用 <code>count</code> 方法。比如，统计所有数据条数：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">count = collection.find().count()</span><br><span class="line">print(count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或者统计符合某个条件的数据：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">count = collection.find(&#123;<span class="string">'age'</span>: <span class="number">20</span>&#125;).count()</span><br><span class="line">print(count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果是一个数值，即符合条件的数据条数。</p>
                  <h2 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h2>
                  <p>排序时，直接调用 <code>sort</code> 方法，并在其中传入排序的字段及升降序标志即可。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'Harden'</span>, <span class="string">'Jordan'</span>, <span class="string">'Kevin'</span>, <span class="string">'Mark'</span>, <span class="string">'Mike'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用 <code>pymongo.ASCENDING</code> 指定升序。如果要降序排列，可以传入 <code>pymongo.DESCENDING</code>。</p>
                  <h2 id="9-偏移"><a href="#9-偏移" class="headerlink" title="9. 偏移"></a>9. 偏移</h2>
                  <p>在某些情况下，我们可能想只取某几个元素，这时可以利用 <code>skip</code> 方法偏移几个位置，比如偏移 2，就忽略前两个元素，得到第三个及以后的元素：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'Kevin'</span>, <span class="string">'Mark'</span>, <span class="string">'Mike'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，还可以用 <code>limit</code> 方法指定要取的结果个数，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = collection.find().sort(<span class="string">'name'</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line">print([result[<span class="string">'name'</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'Kevin'</span>, <span class="string">'Mark'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果不使用 <code>limit</code> 方法，原本会返回三个结果，加了限制后，会截取两个结果返回。</p>
                  <p>值得注意的是，在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，因为这样很可能导致内存溢出。此时可以使用类似如下操作来查询：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line">collection.find(&#123;<span class="string">'_id'</span>: &#123;<span class="string">'$gt'</span>: ObjectId(<span class="string">'593278c815c2602678bb2b8d'</span>)&#125;&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时需要记录好上次查询的 <code>_id</code>。</p>
                  <h2 id="10-更新"><a href="#10-更新" class="headerlink" title="10. 更新"></a>10. 更新</h2>
                  <p>对于数据更新，我们可以使用 <code>update</code> 方法，指定更新的条件和更新后的数据即可。例如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们要更新 <code>name</code> 为 <code>Kevin</code> 的数据的年龄：首先指定查询条件，然后将数据查询出来，修改年龄后调用 <code>update</code> 方法将原条件和修改后的数据传入。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'ok'</span>: <span class="number">1</span>, <span class="string">'nModified'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'updatedExisting'</span>: <span class="literal">True</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>返回结果是字典形式，<code>ok</code> 代表执行成功，<code>nModified</code> 代表影响的数据条数。</p>
                  <p>另外，我们也可以使用 <code>$set</code> 操作符对数据进行更新，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样可以只更新 <code>student</code> 字典内存在的字段。如果原先还有其他字段，则不会更新，也不会删除。而如果不用 <code>$set</code> 的话，则会把之前的数据全部用 <code>student</code> 字典替换；如果原本存在其他字段，则会被删除。</p>
                  <p>另外，<code>update</code> 方法其实也是官方不推荐使用的方法。这里也分为 <code>update_one</code> 方法和 <code>update_many</code> 方法，用法更加严格，它们的第二个参数需要使用 <code>$</code> 类型操作符作为字典的键名，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里调用了 <code>update_one</code> 方法，其第二个参数不能再直接传入修改后的字典，而是需要使用 <code>{&#39;$set&#39;: student}</code> 这样的形式，其返回结果是 <code>UpdateResult</code> 类型。然后分别调用 <code>matched_count</code> 和 <code>modified_count</code> 属性，获得匹配的数据条数和影响的数据条数。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x10d17b678</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们再看一个例子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里指定查询条件为年龄大于 20，然后更新条件为 <code>{&#39;$inc&#39;: {&#39;age&#39;: 1}}</code>，也就是年龄加 1，执行之后会将第一条符合条件的数据年龄加 1。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x10b8874c8</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到匹配条数为 1 条，影响条数也为 1 条。</p>
                  <p>如果调用 <code>update_many</code> 方法，则会将所有符合条件的数据都更新，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时匹配条数就不再为 1 条了，运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.UpdateResult object at <span class="number">0x10c6384c8</span>&gt;</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这时所有匹配到的数据都会被更新。</p>
                  <h2 id="11-删除"><a href="#11-删除" class="headerlink" title="11. 删除"></a>11. 删除</h2>
                  <p>删除操作比较简单，直接调用 <code>remove</code> 方法指定删除的条件即可，此时符合条件的所有数据均会被删除。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = collection.remove(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'ok'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，这里依然存在两个新的推荐方法 —— <code>delete_one</code> 和 <code>delete_many</code>。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br><span class="line">print(result)</span><br><span class="line">print(result.deleted_count)</span><br><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">25</span>&#125;&#125;)</span><br><span class="line">print(result.deleted_count)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;pymongo.results.DeleteResult object at <span class="number">0x10e6ba4c8</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p><code>delete_one</code> 即删除第一条符合条件的数据，<code>delete_many</code> 即删除所有符合条件的数据。它们的返回结果都是 <code>DeleteResult</code> 类型，可以调用 <code>deleted_count</code> 属性获取删除的数据条数。</p>
                  <h2 id="12-其他操作"><a href="#12-其他操作" class="headerlink" title="12. 其他操作"></a>12. 其他操作</h2>
                  <p>另外，PyMongo 还提供了一些组合方法，如 <code>find_one_and_delete</code>、<code>find_one_and_replace</code> 和 <code>find_one_and_update</code>，它们是查找后删除、替换和更新操作，其用法与上述方法基本一致。</p>
                  <p>另外，还可以对索引进行操作，相关方法有 <code>create_index</code>、<code>create_indexes</code> 和 <code>drop_index</code> 等。</p>
                  <p>关于 PyMongo 的详细用法，可以参见官方文档：<a href="http://api.mongodb.com/python/current/api/pymongo/collection.html" target="_blank" rel="noopener">http://api.mongodb.com/python/current/api/pymongo/collection.html</a>。</p>
                  <p>另外，还有对数据库和集合本身等的一些操作，这里不再一一讲解，可以参见官方文档：<a href="http://api.mongodb.com/python/current/api/pymongo/" target="_blank" rel="noopener">http://api.mongodb.com/python/current/api/pymongo/</a>。</p>
                  <h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2>
                  <p>本节讲解了使用 PyMongo 操作 MongoDB 进行数据增删改查的方法，后面我们会在实战案例中应用这些操作进行数据存储。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/MongoDBTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/MongoDBTest</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-14 12:42:44" itemprop="dateCreated datePublished" datetime="2022-02-14T12:42:44+08:00">2022-02-14</time>
                </span>
                <span id="/202243.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 高效实用的 MongoDB 文档存储" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>9.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>9 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202224.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202224.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 基础爬虫案例爬取实战</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>在前面我们已经学习了 requests、正则表达式的基本用法，但我们还没有完整地实现一个爬取案例，这一节，我们就来实现一个完整的网站爬虫，把前面学习的知识点串联起来，同时加深对这些知识点的理解。</p>
                  <h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2>
                  <p>在本节开始之前，我们需要做好如下的准备工作：</p>
                  <ul>
                    <li>安装好 Python3，最低为 3.6 版本，并能成功运行 Python3 程序。</li>
                    <li>了解 Python HTTP 请求库 requests 的基本用法。</li>
                    <li>了解正则表达式的用法和 Python 中正则表达式库 re 的基本用法。</li>
                  </ul>
                  <p>以上内容在前面的章节中均有讲解，如尚未准备好建议先熟悉一下这些内容。</p>
                  <h2 id="2-爬取目标"><a href="#2-爬取目标" class="headerlink" title="2. 爬取目标"></a>2. 爬取目标</h2>
                  <p>本节我们以一个基本的静态网站作为案例进行爬取，需要爬取的链接为 <a href="https://ssr1.scrape.center/" target="_blank" rel="noopener">https://ssr1.scrape.center/</a>，这个网站里面包含了一些电影信息，界面如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/ub4f5.png" alt=""></p>
                  <p>这里首页展示了一个个电影的列表，每部电影包含了它的封面、名称、分类、上映时间、评分等内容，同时列表页还支持翻页，点击相应的页码我们就能进入到对应的新列表页。</p>
                  <p>如果我们点开其中一部电影，会进入到电影的详情页面，比如我们把第一个电影《霸王别姬》打开，会得到如下的页面：</p>
                  <p><img src="https://cdn.cuiqingcai.com/km8us.png" alt=""></p>
                  <p>这里显示的内容更加丰富、包括剧情简介、导演、演员等信息。</p>
                  <p>我们本节要完成的目标是：</p>
                  <ul>
                    <li>用 requests 爬取这个站点每一页的电影列表，顺着列表再爬取每个电影的详情页。</li>
                    <li>用 pyquery 和正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。</li>
                    <li>把以上爬取的内容存入 MongoDB 数据库。</li>
                    <li>使用多进程实现爬取的加速。</li>
                  </ul>
                  <p>好，那我们现在就开始吧。</p>
                  <h2 id="3-爬取列表页"><a href="#3-爬取列表页" class="headerlink" title="3. 爬取列表页"></a>3. 爬取列表页</h2>
                  <p>好，第一步的爬取我们肯定要从列表页入手，我们首先观察一下列表页的结构和翻页规则。在浏览器中访问 <a href="https://ssr1.scrape.center/" target="_blank" rel="noopener">https://ssr1.scrape.center/</a>，然后打开浏览器开发者工具，我们观察每一个电影信息区块对应的 HTML 以及进入到详情页的 URL 是怎样的，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/q295l.png" alt=""></p>
                  <p>可以看到每部电影对应的区块都是一个 div 节点，它的 class 属性都有 el-card 这个值。每个列表页有 10 个这样的 div 节点，也就对应着 10 部电影的信息。</p>
                  <p>好，我们再分析下从列表页是怎么进入到详情页的，我们选中电影的名称，看下结果：</p>
                  <p><img src="https://cdn.cuiqingcai.com/gi0nt.png" alt=""></p>
                  <p>可以看到这个名称实际上是一个 h2 节点，其内部的文字就是电影的标题。再看，h2 节点的外面包含了一个 a 节点，这个 a 节点带有 href 属性，这就是一个超链接，其中 href 的值为 <code>/detail/1</code>，这是一个相对网站的根 URL <a href="https://ssr1.scrape.center/" target="_blank" rel="noopener">https://ssr1.scrape.center/</a> 的路径，加上网站的根 URL 就构成了 <a href="https://ssr1.scrape.center/detail/1" target="_blank" rel="noopener">https://ssr1.scrape.center/detail/1</a> ，也就是这部电影的详情页的 URL。这样我们只需要提取到这个 href 属性就能构造出详情页的 URL 并接着爬取了。</p>
                  <p>好的，那接下来我们来分析下翻页的逻辑，我们拉到页面的最下方，可以看到分页页码，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/97yn6.png" alt=""></p>
                  <p>这里观察到一共有 100 条数据，10 页的内容，因此页码最多是 10。</p>
                  <p>接着我们点击第二页，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/r63xq.png" alt=""></p>
                  <p>可以看到网页的 URL 变成了 <a href="https://ssr1.scrape.center/page/2" target="_blank" rel="noopener">https://ssr1.scrape.center/page/2</a>，相比根 URL 多了 <code>/page/2</code> 这部分内容。网页的结构还是和原来一模一样，可以和第一页一样处理。</p>
                  <p>接着我们查看第三页、第四页等内容，可以发现有这么一个规律，其 URL 最后分别变成了 <code>/page/3</code>、<code>/page/4</code>。所以，<code>/page</code> 后面跟的就是列表页的页码，当然第一页也是一样，我们在根 URL 后面加上 <code>/page/1</code> 也是能访问的，只不过网站做了一下处理，默认的页码是 1，所以显示第一页的内容。</p>
                  <p>好，分析到这里，逻辑基本就清晰了。</p>
                  <p>所以，我们要完成列表页的爬取，可以这么实现：</p>
                  <ul>
                    <li>遍历页码构造 10 页的索引页 URL。</li>
                    <li>从每个索引页分析提取出每个电影的详情页 URL。</li>
                  </ul>
                  <p>好，那么我们写代码来实现一下吧。</p>
                  <p>首先，我们需要先定义一些基础的变量，并引入一些必要的库，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    format=<span class="string">'%(asctime)s - %(levelname)s: %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'https://ssr1.scrape.center'</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们引入了 requests 用来爬取页面，logging 用来输出信息，re 用来实现正则表达式解析，urljoin 用来做 URL 的拼接。</p>
                  <p>接着我们定义了下日志输出级别和输出格式，接着定义了 BASE_URL 为当前站点的根 URL，TOTAL_PAGE 为需要爬取的总页码数量。</p>
                  <p>好，定义好了之后，我们来实现一个页面爬取的方法吧，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'scraping %s...'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">'get invalid status code %s while scraping %s'</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">'error occurred while scraping %s'</span>, url, exc_info=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>考虑到我们不仅要爬取列表页，还要爬取详情页，所以在这里我们定义一个较通用的爬取页面的方法，叫做 scrape_page，它接收一个 url 参数，返回页面的 html 代码。这里首先判断了状态码是不是 200，如果是，则直接返回页面的 HTML 代码，如果不是，则会输出错误日志信息。另外这里实现了 requests 的异常处理，如果出现了爬取异常，则会输出对应的错误日志信息，我们将 logging 的 error 方法的 exc_info 参数设置为 True 则可以打印出 Traceback 错误堆栈信息。</p>
                  <p>好了，有了 scrape_page 方法之后，我们给这个方法传入一个 url，正常情况下它就可以返回页面的 HTML 代码了。</p>
                  <p>接着在这个基础上，我们来定义列表页的爬取方法吧，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span><span class="params">(page)</span>:</span></span><br><span class="line">    index_url = <span class="string">f'<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> scrape_page(index_url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>方法名称叫做 scrape_index，这个实现就很简单了，这个方法会接收一个 page 参数，即列表页的页码，我们在方法里面实现列表页的 URL 拼接，然后调用 scrape_page 方法爬取即可，这样就能得到列表页的 HTML 代码了。</p>
                  <p>获取了 HTML 代码之后，下一步就是解析列表页，并得到每部电影的详情页的 URL 了，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'&lt;a.*?href="(.*?)".*?class="name"&gt;'</span>)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL, item)</span><br><span class="line">        logging.info(<span class="string">'get detail url %s'</span>, detail_url)</span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们定义了 parse_index 方法，它接收一个 html 参数，即列表页的 HTML 代码。</p>
                  <p>在 parse_index 方法里面，我们首先定义了一个提取标题超链接 href 属性的正则表达式，内容为：</p>
                  <figure class="highlight cs">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;a.*?href=<span class="string">"(.*?)"</span>.*?<span class="keyword">class</span>=<span class="string">"name"</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们使用非贪婪通用匹配正则表达式 <code>.*?</code> 来匹配任意字符，同时在 href 属性的引号之间使用了分组匹配 <code>(.*?)</code> 正则表达式，这样 href 的属性值我们便能在匹配结果里面获取到了。紧接着，正则表达式后面紧跟了 <code>class=&quot;name&quot;</code> 来标示这个 <code>&lt;a&gt;</code> 节点是代表电影名称的节点。</p>
                  <p>好，现在有了正则表达式，那么怎么提取列表页所有的 href 值呢？使用 re 的 findall 方法就好了，第一个参数传入这个正则表达式构造的 pattern 对象，第二个参数传入 html，这样 findall 方法便会搜索 html 中所有能匹配该正则表达式的内容，然后把匹配到的结果返回，最后赋值为 items。</p>
                  <p>如果 items 为空，那么我们可以直接返回空的列表，如果 items 不为空，那么我们直接遍历处理即可。</p>
                  <p>遍历 items 得到的 item 就是我们在上文所说的类似 <code>/detail/1</code> 这样的结果。由于这并不是一个完整的 URL，所以我们需要借助 urljoin 方法把 BASE_URL 和 href 拼接起来，获得详情页的完整 URL，得到的结果就类似 <a href="https://ssr1.scrape.center/detail/1" target="_blank" rel="noopener">https://ssr1.scrape.center/detail/1</a> 这样的完整的 URL 了，最后 yield 返回即可。</p>
                  <p>这样我们通过调用 parse_index 方法并传入列表页的 HTML 代码就可以获得该列表页所有电影的详情页 URL 了。</p>
                  <p>好，接下来我们把上面的方法串联调用一下，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        logging.info(<span class="string">'detail urls %s'</span>, list(detail_urls))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了 main 方法来完成上面所有方法的调用，首先使用 range 方法遍历了一下页码，得到的 page 就是 1-10，接着把 page 变量传给 scrape_index 方法，得到列表页的 HTML，赋值为 index_html 变量。接下来再将 index_html 变量传给 parse_index 方法，得到列表页所有电影的详情页 URL，赋值为 detail_urls，结果是一个生成器，我们调用 list 方法就可以将其输出出来。</p>
                  <p>好，我们运行一下上面的代码，结果如下：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">50</span>,<span class="number">505</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/page/1...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">949</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/5</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/6</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/7</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/8</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/9</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">950</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/10</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">951</span> - INFO: detail urls [<span class="string">'https://ssr1.scrape.center/detail/1'</span>, <span class="string">'https://ssr1.scrape.center/detail/2'</span>, <span class="string">'https://ssr1.scrape.center/detail/3'</span>, <span class="string">'https://ssr1.scrape.center/detail/4'</span>, <span class="string">'https://ssr1.scrape.center/detail/5'</span>, <span class="string">'https://ssr1.scrape.center/detail/6'</span>, <span class="string">'https://ssr1.scrape.center/detail/7'</span>, <span class="string">'https://ssr1.scrape.center/detail/8'</span>, <span class="string">'https://ssr1.scrape.center/detail/9'</span>, <span class="string">'https://ssr1.scrape.center/detail/10'</span>]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">51</span>,<span class="number">951</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/page/2...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">52</span>,<span class="number">842</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/11</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">52</span>,<span class="number">842</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/12</span></span><br><span class="line">...</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于输出内容比较多，这里只贴了一部分。</p>
                  <p>可以看到，这里程序首先爬取了第一页列表页，然后得到了对应详情页的每个 URL，接着再接着爬第二页、第三页，一直到第十页，依次输出了每一页的详情页 URL。这样，我们就成功获取到了所有电影的详情页 URL 啦。</p>
                  <h2 id="4-爬取详情页"><a href="#4-爬取详情页" class="headerlink" title="4. 爬取详情页"></a>4. 爬取详情页</h2>
                  <p>现在我们已经可以成功获取所有详情页 URL 了，那么下一步当然就是解析详情页并提取出我们想要的信息了。</p>
                  <p>我们首先观察一下详情页的 HTML 代码吧，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/6j55t.png" alt=""></p>
                  <p>经过分析，我们想要提取的内容和对应的节点信息如下：</p>
                  <ul>
                    <li>封面：是一个 img 节点，其 class 属性为 cover。</li>
                    <li>名称：是一个 h2 节点，其内容便是名称。</li>
                    <li>类别：是 span 节点，其内容便是类别内容，其外侧是 button 节点，再外侧则是 class 为 categories 的 div 节点。</li>
                    <li>上映时间：是 span 节点，其内容包含了上映时间，其外侧是包含了 class 为 info 的 div 节点。另外提取结果中还多了「上映」二字，我们可以用正则表达式把日期提取出来。</li>
                    <li>评分：是一个 p 节点，其内容便是评分，p 节点的 class 属性为 score。</li>
                    <li>剧情简介：是一个 p 节点，其内容便是剧情简介，其外侧是 class 为 drama 的 div 节点。</li>
                  </ul>
                  <p>看似有点复杂是吧，不用担心，有了正则表达式，我们可以轻松搞定。</p>
                  <p>接着我们来实现一下代码吧。</p>
                  <p>刚才我们已经成功获取了详情页 URL，接着当然是定义一个详情页的爬取方法了，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> scrape_page(url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了一个 scrape_detail 方法，接收一个 url 参数，并通过调用 scrape_page 方法获得网页源代码。由于我们刚才已经实现了 scrape_page 方法，所以在这里我们不用再写一遍页面爬取的逻辑了，直接调用即可，做到了代码复用。</p>
                  <p>另外有人会说，这个 scrape_detail 方法里面只调用了 scrape_page 方法，别没有别的功能，那爬取详情页直接用 scrape_page 方法不就好了，还有必要再单独定义 scrape_detail 方法吗？有必要，单独定义一个 scrape_detail 方法在逻辑上会显得更清晰，而且以后如果我们想要对 scrape_detail 方法进行改动，比如添加日志输出，比如增加预处理，都可以在 scrape_detail 里面实现，而不用改动 scrape_page 方法，灵活性会更好。</p>
                  <p>好了，详情页的爬取方法已经实现了，接着就是详情页的解析了，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(html)</span>:</span></span><br><span class="line">    cover_pattern = re.compile(<span class="string">'class="item.*?&lt;img.*?src="(.*?)".*?class="cover"&gt;'</span>, re.S)</span><br><span class="line">    name_pattern = re.compile(<span class="string">'&lt;h2.*?&gt;(.*?)&lt;/h2&gt;'</span>)</span><br><span class="line">    categories_pattern = re.compile(<span class="string">'&lt;button.*?category.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/button&gt;'</span>, re.S)</span><br><span class="line">    published_at_pattern = re.compile(<span class="string">'(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)\s?上映'</span>)</span><br><span class="line">    drama_pattern = re.compile(<span class="string">'&lt;div.*?drama.*?&gt;.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;'</span>, re.S)</span><br><span class="line">    score_pattern = re.compile(<span class="string">'&lt;p.*?score.*?&gt;(.*?)&lt;/p&gt;'</span>, re.S)</span><br><span class="line">    cover = re.search(cover_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(cover_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    name = re.search(name_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(name_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    categories = re.findall(categories_pattern, html) <span class="keyword">if</span> re.findall(categories_pattern, html) <span class="keyword">else</span> []</span><br><span class="line">    published_at = re.search(published_at_pattern, html).group(<span class="number">1</span>) <span class="keyword">if</span> re.search(published_at_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama = re.search(drama_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(drama_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    score = float(re.search(score_pattern, html).group(<span class="number">1</span>).strip()) <span class="keyword">if</span> re.search(score_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'cover'</span>: cover,</span><br><span class="line">        <span class="string">'name'</span>: name,</span><br><span class="line">        <span class="string">'categories'</span>: categories,</span><br><span class="line">        <span class="string">'published_at'</span>: published_at,</span><br><span class="line">        <span class="string">'drama'</span>: drama,</span><br><span class="line">        <span class="string">'score'</span>: score</span><br><span class="line">    &#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了 parse_detail 方法用于解析详情页，它接收一个参数为 html，解析其中的内容，并以字典的形式返回结果。每个字段的解析情况如下所述：</p>
                  <ul>
                    <li>cover：封面，其值是带有 cover 这个 class 的 img 节点的 src 属性的值 ，所有直接 src 的内容使用 <code>(.*?)</code> 来表示即可，在 img 节点的前面我们再加上一些区分位置的标识符，如 item。由于结果只有一个，写好正则表达式后用 search 方法提取即可。</li>
                    <li>name：名称，其值是 h2 节点的文本值，我们直接在 h2 标签的中间使用 <code>(.*?)</code> 表示即可。由于结果只有一个，写好正则表达式后同样用 search 方法提取即可。</li>
                    <li>categories：类别，我们注意到每个 category 的值都是 button 节点里面的 span 节点的值，所以我们写好表示 button 节点的正则表达式后，再直接在其内部的 span 标签的中间使用 <code>(.*?)</code> 表示即可。由于结果有多个，所以这里使用 findall 方法提取，结果是一个列表。</li>
                    <li>published_at：上映时间，由于每个上映时间信息都包含了「上映」二字，另外日期又都是一个规整的格式，所以对于这个上映时间的提取，我们直接使用标准年月日的正则表达式 <code>(\d{4}-\d{2}-\d{2})</code> 表示即可。由于结果只有一个，直接使用 search 方法提取即可。</li>
                    <li>drama：直接提取 class 为 drama 的节点内部的 p 节点的文本即可，同样用 search 方法可以提取。</li>
                    <li>score：直接提取 class 为 score 的 p 节点的文本即可，但由于提取结果是字符串，所以我们还需要把它转成浮点数，即 float 类型。</li>
                  </ul>
                  <p>最后，上述的字段提取完毕之后，构造一个字典返回即可。</p>
                  <p>这样，我们就成功完成了详情页的提取和分析了。</p>
                  <p>最后，main 方法稍微改写一下，增加这两个方法的调用，改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">            detail_html = scrape_detail(detail_url)</span><br><span class="line">            data = parse_detail(detail_html)</span><br><span class="line">            logging.info(<span class="string">'get detail data %s'</span>, data)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们首先遍历了 detail_urls，获取了每个详情页的 URL，然后依次调用了 scrape_detail 和 parse_detail 方法，最后得到了每个详情页的提取结果，赋值为 data 并输出。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">35</span>,<span class="number">936</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/page/1...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">36</span>,<span class="number">833</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">36</span>,<span class="number">833</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/detail/1...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">39</span>,<span class="number">985</span> - INFO: <span class="keyword">get</span> detail data &#123;<span class="string">'cover'</span>: <span class="string">'https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c'</span>, <span class="string">'name'</span>: <span class="string">'霸王别姬 - Farewell My Concubine'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'爱情'</span>], <span class="string">'published_at'</span>: <span class="string">'1993-07-26'</span>, <span class="string">'drama'</span>: <span class="string">'影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，两人一个演生，一个饰旦，一向配合天衣无缝，尤其一出《霸王别姬》，更是誉满京城，为此，两人约定合演一辈子《霸王别姬》。但两人对戏剧与人生关系的理解有本质不同，段小楼深知戏非人生，程蝶衣则是人戏不分。段小楼在认为该成家立业之时迎娶了名妓菊仙（巩俐 饰），致使程蝶衣认定菊仙是可耻的第三者，使段小楼做了叛徒，自此，三人围绕一出《霸王别姬》生出的爱恨情仇战开始随着时代风云的变迁不断升级，终酿成悲剧。'</span>, <span class="string">'score'</span>: <span class="number">9.5</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">39</span>,<span class="number">985</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">39</span>,<span class="number">985</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/detail/2...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">41</span>,<span class="number">061</span> - INFO: <span class="keyword">get</span> detail data &#123;<span class="string">'cover'</span>: <span class="string">'https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c'</span>, <span class="string">'name'</span>: <span class="string">'这个杀手不太冷 - Léon'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'动作'</span>, <span class="string">'犯罪'</span>], <span class="string">'published_at'</span>: <span class="string">'1994-09-14'</span>, <span class="string">'drama'</span>: <span class="string">'里昂（让·雷诺 饰）是名孤独的职业杀手，受人雇佣。一天，邻居家小姑娘马蒂尔德（纳塔丽·波特曼 饰）敲开他的房门，要求在他那里暂避杀身之祸。原来邻居家的主人是警方缉毒组的眼线，只因贪污了一小包毒品而遭恶警（加里·奥德曼 饰）杀害全家的惩罚。马蒂尔德 得到里昂的留救，幸免于难，并留在里昂那里。里昂教小女孩使枪，她教里昂法文，两人关系日趋亲密，相处融洽。 女孩想着去报仇，反倒被抓，里昂及时赶到，将女孩救回。混杂着哀怨情仇的正邪之战渐次升级，更大的冲突在所难免……'</span>, <span class="string">'score'</span>: <span class="number">9.5</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-08</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">41</span>,<span class="number">062</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/3</span></span><br><span class="line">...</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于内容较多，这里省略了后续内容。</p>
                  <p>可以看到，这里我们就成功提取出来了每部电影的基本信息了，包括封面、名称、类别等等。</p>
                  <h2 id="5-保存数据"><a href="#5-保存数据" class="headerlink" title="5. 保存数据"></a>5. 保存数据</h2>
                  <p>好，成功提取到详情页信息之后，我们下一步就要把数据保存起来了。由于我们到现在我们还没有学习数据库的存储，所以现在我们临时先将数据保存成文本格式，在这里我们可以一个条目一个 JSON 文本。</p>
                  <p>定义保存数据的方法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line">RESULTS_DIR = <span class="string">'results'</span></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    name = data.get(<span class="string">'name'</span>)</span><br><span class="line">    data_path = <span class="string">f'<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json'</span></span><br><span class="line">    json.dump(data, open(data_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们首先定义了数据保存的文件夹 RESULTS_DIR，然后判断了下这个文件夹是否存在，如果不存在则创建。</p>
                  <p>接着，我们定义了保存数据的方法 save_data，首先我们获取了数据的 name 字段，即电影的名称，我们将电影的名称当做 JSON 文件的名称，接着构造了 JSON 文件的路径，然后用 json 的 dump 方法将数据保存成文本格式。在 dump 的方法设置了两个参数，一个是 ensure_ascii 设置为 False，可以保证的中文字符在文件中能以正常的中文文本呈现，而不是 unicode 字符；另一个 indent 为 2，则是设置了 JSON 数据的结果有两行缩进，让 JSON 数据的格式显得更加美观。</p>
                  <p>好的，那么接下来 main 方法稍微改写一下就好了，改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">            detail_html = scrape_detail(detail_url)</span><br><span class="line">            data = parse_detail(detail_html)</span><br><span class="line">            logging.info(<span class="string">'get detail data %s'</span>, data)</span><br><span class="line">            logging.info(<span class="string">'saving data to json file'</span>)</span><br><span class="line">            save_data(data)</span><br><span class="line">            logging.info(<span class="string">'data saved successfully'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里就是加了 save_data 方法的调用，并加了一些日志信息。</p>
                  <p>重新运行，我们看下输出结果：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">27</span>,<span class="number">094</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/page/1...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">28</span>,<span class="number">019</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">28</span>,<span class="number">019</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/detail/1...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">29</span>,<span class="number">183</span> - INFO: <span class="keyword">get</span> detail data &#123;<span class="string">'cover'</span>: <span class="string">'https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c'</span>, <span class="string">'name'</span>: <span class="string">'霸王别姬 - Farewell My Concubine'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'爱情'</span>], <span class="string">'published_at'</span>: <span class="string">'1993-07-26'</span>, <span class="string">'drama'</span>: <span class="string">'影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，两人一个演生，一个饰旦，一向配合天衣无缝，尤其一出《霸王别姬》，更是誉满京城，为此，两人约定合演一辈子《霸王别姬》。但两人对戏剧与人生关系的理解有本质不同，段小楼深知戏非人生，程蝶衣则是人戏不分。段小楼在认为该成家立业之时迎娶了名妓菊仙（巩俐 饰），致使程蝶衣认定菊仙是可耻的第三者，使段小楼做了叛徒，自此，三人围绕一出《霸王别姬》生出的爱恨情仇战开始随着时代风云的变迁不断升级，终酿成悲剧。'</span>, <span class="string">'score'</span>: <span class="number">9.5</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">29</span>,<span class="number">183</span> - INFO: saving data to json file</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">29</span>,<span class="number">288</span> - INFO: data saved successfully</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">29</span>,<span class="number">288</span> - INFO: <span class="keyword">get</span> detail url https:<span class="comment">//ssr1.scrape.center/detail/2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">29</span>,<span class="number">288</span> - INFO: scraping https:<span class="comment">//ssr1.scrape.center/detail/2...</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">30</span>,<span class="number">250</span> - INFO: <span class="keyword">get</span> detail data &#123;<span class="string">'cover'</span>: <span class="string">'https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c'</span>, <span class="string">'name'</span>: <span class="string">'这个杀手不太冷 - Léon'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'动作'</span>, <span class="string">'犯罪'</span>], <span class="string">'published_at'</span>: <span class="string">'1994-09-14'</span>, <span class="string">'drama'</span>: <span class="string">'里昂（让·雷诺 饰）是名孤独的职业杀手，受人雇佣。一天，邻居家小姑娘马蒂尔德（纳塔丽·波特曼 饰）敲开他的房门，要求在他那里暂避杀身之祸。原来邻居家的主人是警方缉毒组的眼线，只因贪污了一小包毒品而遭恶警（加里·奥德曼 饰）杀害全家的惩罚。马蒂尔德 得到里昂的留救，幸免于难，并留在里昂那里。里昂教小女孩使枪，她教里昂法文，两人关系日趋亲密，相处融洽。 女孩想着去报仇，反倒被抓，里昂及时赶到，将女孩救回。混杂着哀怨情仇的正邪之战渐次升级，更大的冲突在所难免……'</span>, <span class="string">'score'</span>: <span class="number">9.5</span>&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">30</span>,<span class="number">250</span> - INFO: saving data to json file</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-09</span> <span class="number">01</span>:<span class="number">10</span>:<span class="number">30</span>,<span class="number">253</span> - INFO: data saved successfully</span><br><span class="line">...</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过运行结果可以发现，这里成功输出了将数据存储到 JSON 文件的信息。</p>
                  <p>运行完毕之后我们可以观察下本地的结果，可以看到 results 文件夹下就多了 100 个 JSON 文件，每部电影数据都是一个 JSON 文件，文件名就是电影名，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/yse4w.png" alt=""></p>
                  <h2 id="6-多进程加速"><a href="#6-多进程加速" class="headerlink" title="6. 多进程加速"></a>6. 多进程加速</h2>
                  <p>由于整个的爬取是单进程的，而且只能逐条爬取，速度稍微有点慢，我们有没有方法来对整个爬取过程进行加速呢？</p>
                  <p>在前面我们讲了多进程的基本原理和使用方法，下面我们就来实践一下多进程的爬取吧。</p>
                  <p>由于一共有 10 页详情页，这 10 页内容是互不干扰的，所以我们可以一页开一个进程来爬取。而且由于这 10 个列表页页码正好可以提前构造成一个列表，所以我们可以选用多进程里面的进程池 Pool 来实现这个过程。</p>
                  <p>这里我们需要改写下 main 方法的调用，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(page)</span>:</span></span><br><span class="line">    index_html = scrape_index(page)</span><br><span class="line">    detail_urls = parse_index(index_html)</span><br><span class="line">    <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">        detail_html = scrape_detail(detail_url)</span><br><span class="line">        data = parse_detail(detail_html)</span><br><span class="line">        logging.info(<span class="string">'get detail data %s'</span>, data)</span><br><span class="line">        logging.info(<span class="string">'saving data to json data'</span>)</span><br><span class="line">        save_data(data)</span><br><span class="line">        logging.info(<span class="string">'data saved successfully'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = range(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.map(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们首先给 main 方法添加了一个参数 page，用以表示列表页的页码。接着我们声明了一个进程池，并声明了 pages 为所有需要遍历的页码，即 1-10。最后调用 map 方法，第一个参数就是需要被调用的参数，第二个参数就是 pages，即需要遍历的页码。</p>
                  <p>这样 pages 就会被依次遍历，把 1-10 这 10 个页码分别传递给 main 方法，并把每次的调用变成一个进程，加入到进程池中执行，进程池会根据当前运行环境来决定运行多少进程。比如我的机器的 CPU 有 8 个核，那么进程池的大小会默认设定为 8，这样就会同时有 8 个进程并行执行。</p>
                  <p>运行输出结果和之前类似，但是可以明显看到加了多进程执行之后，爬取速度快了非常多。可以清空一下之前的爬取数据，可以发现数据依然可以被正常保存成 JSON 文件。</p>
                  <h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2>
                  <p>好了，到现在为止，我们就完成了全站电影数据的爬取并实现了存储和优化。</p>
                  <p>我们本节用到的库有 requests、multiprocessing、re、logging 等，通过这个案例实战，我们把前面学习到的知识都串联了起来，其中的一些实现方法可以好好思考和体会，也希望这个案例能够让你对爬虫的实现有更实际的了解。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/ScrapeSsr1。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/ScrapeSsr1。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-14 09:23:56" itemprop="dateCreated datePublished" datetime="2022-02-14T09:23:56+08:00">2022-02-14</time>
                </span>
                <span id="/202224.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 基础爬虫案例爬取实战" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>15k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>14 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202222.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202222.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 方便好用的 requests</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>上一节中，我们了解了 urllib 的基本用法，但是其中确实有不方便的地方，比如处理网页验证和 Cookie 时，需要写 Opener 和 Handler 来处理。另外我们要实现 POST、PUT 等请求时写法也不太方便。</p>
                  <p>为了更加方便地实现这些操作，就有了更为强大的库 requests，有了它，Cookie、登录验证、代理设置等操作都不是事儿。</p>
                  <p>接下来，让我们领略一下它的强大之处吧。</p>
                  <h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2>
                  <p>在开始之前，请确保已经正确安装好了 requests 库，如尚未安装可以使用 pip3 来安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> requests</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更加详细的安装说明可以参考 <a href="https://setup.scrape.center/requests。" target="_blank" rel="noopener">https://setup.scrape.center/requests。</a></p>
                  <h2 id="2-实例引入"><a href="#2-实例引入" class="headerlink" title="2. 实例引入"></a>2. 实例引入</h2>
                  <p>urllib 库中的 urlopen 方法实际上是以 GET 方式请求网页，而 requests 中相应的方法就是 get 方法，是不是感觉表达更明确一些？下面通过实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">print(type(r))</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(type(r.text))</span><br><span class="line">print(r.text[:<span class="number">100</span>])</span><br><span class="line">print(r.cookies)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">requests</span>.<span class="title">models</span>.<span class="title">Response</span>'&gt;</span></span><br><span class="line"><span class="class">200</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;!<span class="title">DOCTYPE</span> <span class="title">html</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!--<span class="title">STATUS</span> <span class="title">OK</span>--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charse</span></span><br><span class="line"><span class="class">&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用 get 方法实现与 urlopen 相同的操作，得到一个 Response 对象，然后分别输出了 Response 的类型、状态码、响应体的类型、内容以及 Cookie。</p>
                  <p>通过运行结果可以发现，它的返回类型是 <code>requests.models.Response</code>，响应体的类型是字符串 str，Cookie 的类型是 RequestsCookieJar。</p>
                  <p>使用 get 方法成功实现一个 GET 请求，这倒不算什么，更方便之处在于其他的请求类型依然可以用一句话来完成，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>)</span><br><span class="line">r = requests.post(<span class="string">'https://httpbin.org/post'</span>)</span><br><span class="line">r = requests.put(<span class="string">'https://httpbin.org/put'</span>)</span><br><span class="line">r = requests.delete(<span class="string">'https://httpbin.org/delete'</span>)</span><br><span class="line">r = requests.patch(<span class="string">'https://httpbin.org/patch'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里分别用 post、put、delete 等方法实现了 POST、PUT、DELETE 等请求。是不是比 urllib 简单太多了？</p>
                  <p>其实这只是冰山一角，更多的还在后面。</p>
                  <h2 id="3-GET-请求"><a href="#3-GET-请求" class="headerlink" title="3. GET 请求"></a>3. GET 请求</h2>
                  <p>HTTP 中最常见的请求之一就是 GET 请求，下面首先来详细了解一下利用 requests 构建 GET 请求的方法。</p>
                  <h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h4>
                  <p>首先，构建一个最简单的 GET 请求，请求的链接为 <a href="https://httpbin.org/get" target="_blank" rel="noopener">https://httpbin.org/get</a>，该网站会判断如果客户端发起的是 GET 请求的话，它返回相应的请求信息：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;*&#x2F;*&quot;,</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;python-requests&#x2F;2.22.0&quot;,</span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e6e3a2e-6b1a28288d721c9e425a462a&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;origin&quot;: &quot;17.20.233.237&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https:&#x2F;&#x2F;httpbin.org&#x2F;get&quot;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，我们成功发起了 GET 请求，返回结果中包含请求头、URL、IP 等信息。</p>
                  <p>那么，对于 GET 请求，如果要附加额外的信息，一般怎样添加呢？比如现在想添加两个参数，其中 name 是 germey，age 是 25，URL 就可以写成如下内容：</p>
                  <figure class="highlight avrasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">https:</span>//httpbin<span class="meta">.org</span>/get?name=germey&amp;age=<span class="number">25</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>要构造这个请求链接，是不是要直接写成这样呢？</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get?name=germey&amp;age=25'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样也可以，但是是不是有点不人性化呢？这些参数还需要我们手动去拼接，实现起来有点不优雅。</p>
                  <p>一般情况下，这种信息我们利用 params 这个参数就可以直接传递了，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>, params=data)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"25"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"germey"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>,</span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.10.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"122.4.215.33"</span>,</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"https://httpbin.org/get?age=22&amp;name=germey"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们把 URL 参数通过一个字典的形式传给 get 方法的 params 参数，通过返回信息我们可以判断，请求的链接自动被构造成了：<a href="https://httpbin.org/get?age=22&amp;name=germey" target="_blank" rel="noopener">https://httpbin.org/get?age=22&amp;name=germey</a>，这样我们就不用再去自己构造 URL 了，非常方便。</p>
                  <p>另外，网页的返回类型实际上是 str 类型，但是它很特殊，是 JSON 格式的。所以，如果想直接解析返回结果，得到一个 JSON 格式的数据的话，可以直接调用 json 方法。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>)</span><br><span class="line">print(type(r.text))</span><br><span class="line">print(r.json())</span><br><span class="line">print(type(r.json()))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span>'<span class="title">str</span>'&gt;</span></span><br><span class="line">&#123;'headers': &#123;'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.10.0'&#125;, 'url': 'http://httpbin.org/get', 'args': &#123;&#125;, 'origin': '182.33.248.131'&#125;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，调用 json 方法，就可以将返回结果是 JSON 格式的字符串转化为字典。</p>
                  <p>但需要注意的是，如果返回结果不是 JSON 格式，便会出现解析错误，抛出 json.decoder.JSONDecodeError 异常。</p>
                  <h4 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a>抓取网页</h4>
                  <p>上面的请求链接返回的是 JSON 形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容了。下面以一个实例页面 <a href="https://ssr1.scrape.center/" target="_blank" rel="noopener">https://ssr1.scrape.center/</a> 来试一下，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://ssr1.scrape.center/'</span>)</span><br><span class="line">pattern = re.compile(<span class="string">'&lt;h2.*?&gt;(.*?)&lt;/h2&gt;'</span>, re.S)</span><br><span class="line">titles = re.findall(pattern, r.text)</span><br><span class="line">print(titles)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这个例子中我们用到了最基础的正则表达式来匹配出所有的问题内容。关于正则表达式的相关内容，我们会在下一节详细介绍，这里作为实例来配合讲解。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[<span class="string">'肖申克的救赎 - The Shawshank Redemption'</span>, <span class="string">'霸王别姬 - Farewell My Concubine'</span>, <span class="string">'泰坦尼克号 - Titanic'</span>, <span class="string">'罗马假日 - Roman Holiday'</span>, <span class="string">'这个杀手不太冷 - Léon'</span>, <span class="string">'魂断蓝桥 - Waterloo Bridge'</span>, <span class="string">'唐伯虎点秋香 - Flirting Scholar'</span>, <span class="string">'喜剧之王 - The King of Comedy'</span>, <span class="string">'楚门的世界 - The Truman Show'</span>, <span class="string">'活着 - To Live'</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们发现，这里成功提取出了所有的电影标题，一个最基本的抓取和提取流程就完成了。</p>
                  <h4 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a>抓取二进制数据</h4>
                  <p>在上面的例子中，我们抓取的是网站的一个页面，实际上它返回的是一个 HTML 文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？</p>
                  <p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。</p>
                  <p>下面以示例网站的站点图标为例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://scrape.center/favicon.ico'</span>)</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.content)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/1sfy2.png" alt="image-20210704202919308"></p>
                  <p>这里打印了 Response 对象的两个属性，一个是 text，另一个是 content。</p>
                  <p>运行结果如图所示，分别是 r.text 和 r.content 的结果。</p>
                  <p><img src="https://cdn.cuiqingcai.com/vexbl.png" alt="image-20210704203039567"></p>
                  <p><img src="https://cdn.cuiqingcai.com/xfo4w.png" alt="image-20210704202959490"></p>
                  <p>可以注意到，前者出现了乱码，后者结果前带有一个 b，这代表是 bytes 类型的数据。由于图片是二进制数据，所以前者在打印时转化为 str 类型，也就是图片直接转化为字符串，这理所当然会出现乱码。</p>
                  <p>上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，我们将刚才提取到的信息保存下来就好了，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://scrape.center/favicon.ico'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(r.content)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里用了 open 方法，它的第一个参数是文件名称，第二个参数代表以二进制写的形式打开，可以向文件里写入二进制数据。</p>
                  <p>运行结束之后，可以发现在文件夹中出现了名为 favicon.ico 的图标，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/16oto.png" alt="image-20210704203204899"></p>
                  <p>这样，我们就把二进制数据成功保存成一张图片了，这个小图标就被我们成功爬取下来了。</p>
                  <p>同样地，音频和视频文件我们也可以用这种方法获取。</p>
                  <h4 id="添加-headers"><a href="#添加-headers" class="headerlink" title="添加 headers"></a>添加 headers</h4>
                  <p>我们知道，在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，那么这个怎么来设置呢？</p>
                  <p>很简单，我们使用 headers 参数就可以完成了。</p>
                  <p>在刚才的实例中，实际上我们是没有设置 Request Headers 信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p>
                  <p>要添加 Headers 信息，比如我们这里想添加一个 User-Agent 字段，我们可以这么来写：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">'https://ssr1.scrape.center/'</span>, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，我们可以在 headers 这个参数中任意添加其他的字段信息。</p>
                  <h2 id="4-POST-请求"><a href="#4-POST-请求" class="headerlink" title="4. POST 请求"></a>4. POST 请求</h2>
                  <p>前面我们了解了最基本的 GET 请求，另外一种比较常见的请求方式是 POST。使用 requests 实现 POST 请求同样非常简单，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'germey'</span>, <span class="string">'age'</span>: <span class="string">'25'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"https://httpbin.org/post"</span>, data=data)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里还是请求 <a href="https://httpbin.org/post" target="_blank" rel="noopener">https://httpbin.org/post</a>，该网站可以判断如果请求是 POST 方式，就把相关请求信息返回。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;age&quot;: &quot;25&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;germey&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;*&#x2F;*&quot;,</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;18&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;python-requests&#x2F;2.22.0&quot;,</span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5e6e3b52-0f36782ea980fce53c8c6524&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;17.20.232.237&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，我们成功获得了返回结果，其中 form 部分就是提交的数据，这就证明 POST 请求成功发送了。</p>
                  <h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5. 响应"></a>5. 响应</h2>
                  <p>发送请求后，得到的自然就是响应。在上面的实例中，我们使用 text 和 content 获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如状态码、响应头、Cookie 等。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://ssr1.scrape.center/'</span>)</span><br><span class="line">print(type(r.status_code), r.status_code)</span><br><span class="line">print(type(r.headers), r.headers)</span><br><span class="line">print(type(r.cookies), r.cookies)</span><br><span class="line">print(type(r.url), r.url)</span><br><span class="line">print(type(r.history), r.history)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里分别打印输出 status_code 属性得到状态码，输出 headers 属性得到响应头，输出 cookies 属性得到 Cookie，输出 url 属性得到 URL，输出 history 属性得到请求历史。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; 200</span></span><br><span class="line">&lt;class 'requests.structures.CaseInsensitiveDict'&gt; &#123;'Server': 'nginx/1.17.8', 'Date': 'Sat, 30 May 2020 16:56:40 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', 'Vary': 'Accept-Encoding', 'X-Frame-Options': 'DENY', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=15724800; includeSubDomains', 'Content-Encoding': 'gzip'&#125;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">requests</span>.<span class="title">cookies</span>.<span class="title">RequestsCookieJar</span>'&gt; &lt;<span class="title">RequestsCookieJar</span>[]&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt; <span class="title">https</span>:</span>//ssr1.scrape.center/</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt; []</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，headers 和 cookies 这两个属性得到的结果分别是 CaseInsensitiveDict 和 RequestsCookieJar 类型。</p>
                  <p>在第一章我们知道，状态码是用来表示响应状态的，比如返回 200 代表我们得到的响应是没问题的，上面的例子正好输出的结果也是 200，所以我们可以通过判断 Response 的状态码来知道爬取是否爬取成功。</p>
                  <p>requests 还提供了一个内置的状态码查询对象 requests.codes，用法示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://ssr1.scrape.center/'</span>)</span><br><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> r.status_code == requests.codes.ok <span class="keyword">else</span> print(<span class="string">'Request Successfully'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用 requests.codes.ok 得到的是成功的状态码 200。</p>
                  <p>这样的话，我们就不用再在程序里面写状态吗对应的数字了，用字符串表示状态码会显得更加直观。</p>
                  <p>当然，肯定不能只有 ok 这个条件码。</p>
                  <p>下面列出了返回码和相应的查询条件：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="comment"># 信息性状态码</span></span><br><span class="line"><span class="number">100</span>: (<span class="string">'continue'</span>,),</span><br><span class="line"><span class="number">101</span>: (<span class="string">'switching_protocols'</span>,),</span><br><span class="line"><span class="number">102</span>: (<span class="string">'processing'</span>,),</span><br><span class="line"><span class="number">103</span>: (<span class="string">'checkpoint'</span>,),</span><br><span class="line"><span class="number">122</span>: (<span class="string">'uri_too_long'</span>, <span class="string">'request_uri_too_long'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功状态码</span></span><br><span class="line"><span class="number">200</span>: (<span class="string">'ok'</span>, <span class="string">'okay'</span>, <span class="string">'all_ok'</span>, <span class="string">'all_okay'</span>, <span class="string">'all_good'</span>, <span class="string">'\\o/'</span>, <span class="string">'✓'</span>),</span><br><span class="line"><span class="number">201</span>: (<span class="string">'created'</span>,),</span><br><span class="line"><span class="number">202</span>: (<span class="string">'accepted'</span>,),</span><br><span class="line"><span class="number">203</span>: (<span class="string">'non_authoritative_info'</span>, <span class="string">'non_authoritative_information'</span>),</span><br><span class="line"><span class="number">204</span>: (<span class="string">'no_content'</span>,),</span><br><span class="line"><span class="number">205</span>: (<span class="string">'reset_content'</span>, <span class="string">'reset'</span>),</span><br><span class="line"><span class="number">206</span>: (<span class="string">'partial_content'</span>, <span class="string">'partial'</span>),</span><br><span class="line"><span class="number">207</span>: (<span class="string">'multi_status'</span>, <span class="string">'multiple_status'</span>, <span class="string">'multi_stati'</span>, <span class="string">'multiple_stati'</span>),</span><br><span class="line"><span class="number">208</span>: (<span class="string">'already_reported'</span>,),</span><br><span class="line"><span class="number">226</span>: (<span class="string">'im_used'</span>,),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重定向状态码</span></span><br><span class="line"><span class="number">300</span>: (<span class="string">'multiple_choices'</span>,),</span><br><span class="line"><span class="number">301</span>: (<span class="string">'moved_permanently'</span>, <span class="string">'moved'</span>, <span class="string">'\\o-'</span>),</span><br><span class="line"><span class="number">302</span>: (<span class="string">'found'</span>,),</span><br><span class="line"><span class="number">303</span>: (<span class="string">'see_other'</span>, <span class="string">'other'</span>),</span><br><span class="line"><span class="number">304</span>: (<span class="string">'not_modified'</span>,),</span><br><span class="line"><span class="number">305</span>: (<span class="string">'use_proxy'</span>,),</span><br><span class="line"><span class="number">306</span>: (<span class="string">'switch_proxy'</span>,),</span><br><span class="line"><span class="number">307</span>: (<span class="string">'temporary_redirect'</span>, <span class="string">'temporary_moved'</span>, <span class="string">'temporary'</span>),</span><br><span class="line"><span class="number">308</span>: (<span class="string">'permanent_redirect'</span>,</span><br><span class="line">      <span class="string">'resume_incomplete'</span>, <span class="string">'resume'</span>,), <span class="comment"># These 2 to be removed in 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端错误状态码</span></span><br><span class="line"><span class="number">400</span>: (<span class="string">'bad_request'</span>, <span class="string">'bad'</span>),</span><br><span class="line"><span class="number">401</span>: (<span class="string">'unauthorized'</span>,),</span><br><span class="line"><span class="number">402</span>: (<span class="string">'payment_required'</span>, <span class="string">'payment'</span>),</span><br><span class="line"><span class="number">403</span>: (<span class="string">'forbidden'</span>,),</span><br><span class="line"><span class="number">404</span>: (<span class="string">'not_found'</span>, <span class="string">'-o-'</span>),</span><br><span class="line"><span class="number">405</span>: (<span class="string">'method_not_allowed'</span>, <span class="string">'not_allowed'</span>),</span><br><span class="line"><span class="number">406</span>: (<span class="string">'not_acceptable'</span>,),</span><br><span class="line"><span class="number">407</span>: (<span class="string">'proxy_authentication_required'</span>, <span class="string">'proxy_auth'</span>, <span class="string">'proxy_authentication'</span>),</span><br><span class="line"><span class="number">408</span>: (<span class="string">'request_timeout'</span>, <span class="string">'timeout'</span>),</span><br><span class="line"><span class="number">409</span>: (<span class="string">'conflict'</span>,),</span><br><span class="line"><span class="number">410</span>: (<span class="string">'gone'</span>,),</span><br><span class="line"><span class="number">411</span>: (<span class="string">'length_required'</span>,),</span><br><span class="line"><span class="number">412</span>: (<span class="string">'precondition_failed'</span>, <span class="string">'precondition'</span>),</span><br><span class="line"><span class="number">413</span>: (<span class="string">'request_entity_too_large'</span>,),</span><br><span class="line"><span class="number">414</span>: (<span class="string">'request_uri_too_large'</span>,),</span><br><span class="line"><span class="number">415</span>: (<span class="string">'unsupported_media_type'</span>, <span class="string">'unsupported_media'</span>, <span class="string">'media_type'</span>),</span><br><span class="line"><span class="number">416</span>: (<span class="string">'requested_range_not_satisfiable'</span>, <span class="string">'requested_range'</span>, <span class="string">'range_not_satisfiable'</span>),</span><br><span class="line"><span class="number">417</span>: (<span class="string">'expectation_failed'</span>,),</span><br><span class="line"><span class="number">418</span>: (<span class="string">'im_a_teapot'</span>, <span class="string">'teapot'</span>, <span class="string">'i_am_a_teapot'</span>),</span><br><span class="line"><span class="number">421</span>: (<span class="string">'misdirected_request'</span>,),</span><br><span class="line"><span class="number">422</span>: (<span class="string">'unprocessable_entity'</span>, <span class="string">'unprocessable'</span>),</span><br><span class="line"><span class="number">423</span>: (<span class="string">'locked'</span>,),</span><br><span class="line"><span class="number">424</span>: (<span class="string">'failed_dependency'</span>, <span class="string">'dependency'</span>),</span><br><span class="line"><span class="number">425</span>: (<span class="string">'unordered_collection'</span>, <span class="string">'unordered'</span>),</span><br><span class="line"><span class="number">426</span>: (<span class="string">'upgrade_required'</span>, <span class="string">'upgrade'</span>),</span><br><span class="line"><span class="number">428</span>: (<span class="string">'precondition_required'</span>, <span class="string">'precondition'</span>),</span><br><span class="line"><span class="number">429</span>: (<span class="string">'too_many_requests'</span>, <span class="string">'too_many'</span>),</span><br><span class="line"><span class="number">431</span>: (<span class="string">'header_fields_too_large'</span>, <span class="string">'fields_too_large'</span>),</span><br><span class="line"><span class="number">444</span>: (<span class="string">'no_response'</span>, <span class="string">'none'</span>),</span><br><span class="line"><span class="number">449</span>: (<span class="string">'retry_with'</span>, <span class="string">'retry'</span>),</span><br><span class="line"><span class="number">450</span>: (<span class="string">'blocked_by_windows_parental_controls'</span>, <span class="string">'parental_controls'</span>),</span><br><span class="line"><span class="number">451</span>: (<span class="string">'unavailable_for_legal_reasons'</span>, <span class="string">'legal_reasons'</span>),</span><br><span class="line"><span class="number">499</span>: (<span class="string">'client_closed_request'</span>,),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端错误状态码</span></span><br><span class="line"><span class="number">500</span>: (<span class="string">'internal_server_error'</span>, <span class="string">'server_error'</span>, <span class="string">'/o\\'</span>, <span class="string">'✗'</span>),</span><br><span class="line"><span class="number">501</span>: (<span class="string">'not_implemented'</span>,),</span><br><span class="line"><span class="number">502</span>: (<span class="string">'bad_gateway'</span>,),</span><br><span class="line"><span class="number">503</span>: (<span class="string">'service_unavailable'</span>, <span class="string">'unavailable'</span>),</span><br><span class="line"><span class="number">504</span>: (<span class="string">'gateway_timeout'</span>,),</span><br><span class="line"><span class="number">505</span>: (<span class="string">'http_version_not_supported'</span>, <span class="string">'http_version'</span>),</span><br><span class="line"><span class="number">506</span>: (<span class="string">'variant_also_negotiates'</span>,),</span><br><span class="line"><span class="number">507</span>: (<span class="string">'insufficient_storage'</span>,),</span><br><span class="line"><span class="number">509</span>: (<span class="string">'bandwidth_limit_exceeded'</span>, <span class="string">'bandwidth'</span>),</span><br><span class="line"><span class="number">510</span>: (<span class="string">'not_extended'</span>,),</span><br><span class="line"><span class="number">511</span>: (<span class="string">'network_authentication_required'</span>, <span class="string">'network_auth'</span>, <span class="string">'network_authentication'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>比如，如果想判断结果是不是 404 状态，可以用 <code>requests.codes.not_found</code> 来比对。</p>
                  <h2 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a>6. 高级用法</h2>
                  <p>前面我们了解了 requests 的基本用法，如基本的 GET、POST 请求以及 Response 对象。下面我们再来了解下 requests 的一些高级用法，如文件上传、Cookie 设置、代理设置等。</p>
                  <h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3>
                  <p>我们知道 requests 可以模拟提交一些数据。假如有的网站需要上传文件，我们也可以用它来实现，这非常简单，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">'https://httpbin.org/post'</span>, files=files)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在前一节中我们保存了一个文件 favicon.ico，这次用它来模拟文件上传的过程。需要注意的是，favicon.ico 需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"files"</span>: &#123;</span><br><span class="line">    <span class="string">"file"</span>: <span class="string">"data:application/octet-stream;base64,AAABAAI..."</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"form"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>,</span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"6665"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"multipart/form-data; boundary=41fc691282cc894f8f06adabb24f05fb"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.22.0"</span>,</span><br><span class="line">    <span class="string">"X-Amzn-Trace-Id"</span>: <span class="string">"Root=1-5e6e3c0b-45b07bdd3a922e364793ef48"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"json"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"16.20.232.237"</span>,</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"https://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>以上省略部分内容，这个网站会返回响应，里面包含 files 这个字段，而 form 字段是空的，这证明文件上传部分会单独有一个 files 字段来标识。</p>
                  <h3 id="Cookie-设置"><a href="#Cookie-设置" class="headerlink" title="Cookie 设置"></a>Cookie 设置</h3>
                  <p>前面我们使用 urllib 处理过 Cookie，写法比较复杂，而有了 requests，获取和设置 Cookie 只需一步即可完成。</p>
                  <p>我们先用一个实例看一下获取 Cookie 的过程：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(r.cookies)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">    print(key + <span class="string">'='</span> + value)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;RequestsCookieJar[&lt;Cookie BDORZ=<span class="number">27315</span> <span class="keyword">for</span> .baidu.com/&gt;]&gt;</span><br><span class="line">BDORZ=<span class="number">27315</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们首先调用 cookies 属性即可成功得到 Cookie，可以发现它是 RequestCookieJar 类型。然后用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 条目的名称和值，实现 Cookie 的遍历解析。</p>
                  <p>当然，我们也可以直接用 Cookie 来维持登录状态，下面我们以 GitHub 为例来说明一下，首先我们登录 GitHub，然后将 Headers 中的 Cookie 内容复制下来，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/odrdk.png" alt="image-20200301214840166"></p>
                  <p>这里可以替换成你自己的 Cookie，将其设置到 Headers 里面，然后发送请求，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="string">'_octo=GH1.1.1849343058.1576602081; _ga=GA1.2.90460451.1576602111; __Host-user_session_same_site=nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw_; _device_id=a7ca73be0e8f1a81d1e2ebb5349f9075; user_session=nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw_; logged_in=yes; dotcom_user=Germey; tz=Asia%2FShanghai; has_recent_activity=1; _gat=1; _gh_sess=your_session_info'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">'https://github.com/'</span>, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们发现，结果中包含了登录后才能包含的结果，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/3j50b.png" alt="image-20200301215251376"></p>
                  <p>可以看到这里包含了我的 GitHub 用户名信息，你如果尝试之后同样可以得到你的用户信息。</p>
                  <p>得到这样类似的结果，就说明我们用 Cookie 就成功模拟了登录状态，这样我们就能爬取登录之后才能看到的页面了。</p>
                  <p>当然，我们也可以通过 cookies 参数来设置 Cookie 的信息，这里我们可以构造一个 RequestsCookieJar 对象，然后把刚才复制的 Cookie 处理下并赋值，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">'_octo=GH1.1.1849343058.1576602081; _ga=GA1.2.90460451.1576602111; __Host-user_session_same_site=nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw_; _device_id=a7ca73be0e8f1a81d1e2ebb5349f9075; user_session=nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw_; logged_in=yes; dotcom_user=Germey; tz=Asia%2FShanghai; has_recent_activity=1; _gat=1; _gh_sess=your_session_info'</span></span><br><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies.split(<span class="string">';'</span>):</span><br><span class="line">    key, value = cookie.split(<span class="string">'='</span>, <span class="number">1</span>)</span><br><span class="line">    jar.set(key, value)</span><br><span class="line">r = requests.get(<span class="string">'https://github.com/'</span>, cookies=jar, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们首先新建了一个 RequestCookieJar 对象，然后将复制下来的 cookies 利用 split 方法分割，接着利用 set 方法设置好每个 Cookie 的 key 和 value，然后通过调用 requests 的 get 方法并传递给 cookies 参数即可。</p>
                  <p>测试后，发现同样可以正常登录。</p>
                  <h3 id="Session-维持"><a href="#Session-维持" class="headerlink" title="Session 维持"></a>Session 维持</h3>
                  <p>在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，也就是说相当于你用了两个浏览器打开了不同的页面。</p>
                  <p>设想这样一个场景，第一个请求利用 requests 的 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次 requests 的 get 方法去请求个人信息页面。</p>
                  <p>实际上，这相当于打开了两个浏览器，是两个完全独立的操作，对应两个完全不相关的 Session，能成功获取个人信息吗？那当然不能。</p>
                  <p>有人可能说了，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来显得很烦琐，我们有更简单的解决方法。</p>
                  <p>其实解决这个问题的主要方法就是维持同一个 Session，也就是相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但是我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 —— Session 对象。</p>
                  <p>利用它，我们可以方便地维护一个 Session，而且不用担心 Cookie 的问题，它会帮我们自动处理好。</p>
                  <p>我们先做一个小实验吧，如果沿用之前的写法，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">'https://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们请求了一个测试网址 <a href="https://httpbin.org/cookies/set/number/123456789" target="_blank" rel="noopener">https://httpbin.org/cookies/set/number/123456789</a>。请求这个网址时，可以设置一个 Cookie 条目，名称叫作 number，内容是 123456789，随后又请求了 <a href="https://httpbin.org/cookies" target="_blank" rel="noopener">https://httpbin.org/cookies</a>，此网址可以获取当前的 Cookie 信息。</p>
                  <p>这样能成功获取到设置的 Cookie 吗？试试看。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这并不行。</p>
                  <p>这时候，我们再用刚才所说的 Session 试试看：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'https://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">'https://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>再看下运行结果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;<span class="string">"number"</span>: <span class="string">"123456789"</span>&#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这些可以看到 Cookies 被成功获取了！这下能体会到同一个会话和不同会话的区别了吧！</p>
                  <p>所以，利用 Session，可以做到模拟同一个会话而不用担心 Cookie 的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p>
                  <p>Session 在平常用得非常广泛，可以用于模拟在一个浏览器中打开同一站点的不同页面，后面会有专门的章节来讲解这部分内容。</p>
                  <h3 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a>SSL 证书验证</h3>
                  <p>现在很多网站都要求使用 HTTPS 协议，但是有些网站可能并没有设置好 HTTPS 证书，或者网站的 HTTPS 证书可能并不被 CA 机构认可，这时候，这些网站可能就会出现 SSL 证书错误的提示。</p>
                  <p>比如这个示例网站：<a href="https://ssr2.scrape.center/" target="_blank" rel="noopener">https://ssr2.scrape.center/</a>，如果我们用 Chrome 浏览器打开这个 URL，则会提示「您的连接不是私密连接」这样的错误，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/gyo9f.png" alt="image-20210704204017465"></p>
                  <p>我们可以在浏览器中通过一些设置来忽略证书的验证。</p>
                  <p>但是如果我们想用 requests 来请求这类网站，会遇到什么问题呢？我们用代码来试一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://ssr2.scrape.center/'</span>)</span><br><span class="line">print(response.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">requests.exceptions.SSLError: HTTPSConnectionPool(host=<span class="string">'ssr2.scrape.center'</span>, port=<span class="number">443</span>): Max retries exceeded <span class="keyword">with</span> url: / (Caused by SSLError(SSLCertVerificationError(<span class="number">1</span>, <span class="string">'[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)'</span>)))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里直接抛出了 SSLError 错误，原因就是因为我们请求的 URL 的证书是无效的。</p>
                  <p>那如果我们一定要爬取这个网站怎么办呢？我们可以使用 verify 参数控制是否验证证书，如果将其设置为 False，在请求时就不会再验证证书是否有效。如果不加 verify 参数的话，默认值是 True，会自动验证。</p>
                  <p>我们改写代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://ssr2.scrape.center/'</span>, verify=<span class="literal">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就会打印出请求成功的状态码：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">/usr/local/lib/python3<span class="number">.7</span>/site-packages/urllib3/connectionpool.py:<span class="number">857</span>: InsecureRequestWarning: Unverified HTTPS request <span class="keyword">is</span> being made. Adding certificate verification <span class="keyword">is</span> strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html<span class="comment">#ssl-warnings</span></span><br><span class="line">  InsecureRequestWarning)</span><br><span class="line"><span class="number">200</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>不过我们发现报了一个警告，它建议我们给它指定证书。我们可以通过设置忽略警告的方式来屏蔽这个警告：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response = requests.get(<span class="string">'https://ssr2.scrape.center/'</span>, verify=<span class="literal">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或者通过捕获警告到日志的方式忽略警告：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">logging.captureWarnings(<span class="literal">True</span>)</span><br><span class="line">response = requests.get(<span class="string">'https://ssr2.scrape.center/'</span>, verify=<span class="literal">False</span>)</span><br><span class="line">print(response.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，我们也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">'https://ssr2.scrape.center/'</span>, cert=(<span class="string">'/path/server.crt'</span>, <span class="string">'/path/server.key'</span>))</span><br><span class="line">print(response.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，上面的代码是演示实例，我们需要有 crt 和 key 文件，并且指定它们的路径。另外注意，本地私有证书的 key 必须是解密状态，加密状态的 key 是不支持的。</p>
                  <h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3>
                  <p>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到 timeout 参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>, timeout=<span class="number">1</span>)</span><br><span class="line">print(r.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过这样的方式，我们可以将超时时间设置为 1 秒，如果 1 秒内没有响应，那就抛出异常。</p>
                  <p>实际上，请求分为两个阶段，即连接（connect）和读取（read）。</p>
                  <p>上面设置的 timeout 将用作连接和读取这二者的 timeout 总和。</p>
                  <p>如果要分别指定，就可以传入一个元组：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>, timeout=(<span class="number">5</span>, <span class="number">30</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果想永久等待，可以直接将 timeout 设置为 None，或者不设置直接留空，因为默认是 None。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>, timeout=<span class="literal">None</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>或直接不加参数：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">r = requests.get(<span class="string">'https://httpbin.org/get'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3>
                  <p>在上一节我们讲到，在访问启用了基本身份认证的网站时，我们会首先遇到一个认证窗口，例如：<a href="https://ssr3.scrape.center/" target="_blank" rel="noopener">https://ssr3.scrape.center/</a>，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/4cha6.png" alt="image-20210704202140395"></p>
                  <p>这个网站就是启用了基本身份认证，在上一节中我们可以利用 urllib 来实现身份的校验，但实现起来相对繁琐。那在 reqeusts 中怎么做呢？当然也有办法。</p>
                  <p>我们可以使用 requests 自带的身份认证功能，通过 auth 参数即可设置，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://ssr3.scrape.center/'</span>, auth=HTTPBasicAuth(<span class="string">'admin'</span>, <span class="string">'admin'</span>))</span><br><span class="line">print(r.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个示例网站的用户名和密码都是 admin，在这里我们可以直接设置。</p>
                  <p>如果用户名和密码正确的话，请求时就会自动认证成功，会返回 200 状态码；如果认证失败，则返回 401 状态码。</p>
                  <p>当然，如果参数都传一个 HTTPBasicAuth 类，就显得有点烦琐了，所以 requests 提供了一个更简单的写法，可以直接传一个元组，它会默认使用 HTTPBasicAuth 这个类来认证。</p>
                  <p>所以上面的代码可以直接简写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'https://ssr3.scrape.center/'</span>, auth=(<span class="string">'admin'</span>, <span class="string">'admin'</span>))</span><br><span class="line">print(r.status_code)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此外，requests 还提供了其他认证方式，如 OAuth 认证，不过此时需要安装 oauth 包，安装命令如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 install requests_oauthlib</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>使用 OAuth1 认证的示例方法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests_oauthlib <span class="keyword">import</span> OAuth1</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://api.twitter.com/1.1/account/verify_credentials.json'</span></span><br><span class="line">auth = OAuth1(<span class="string">'YOUR_APP_KEY'</span>, <span class="string">'YOUR_APP_SECRET'</span>,</span><br><span class="line">              <span class="string">'USER_OAUTH_TOKEN'</span>, <span class="string">'USER_OAUTH_TOKEN_SECRET'</span>)</span><br><span class="line">requests.get(url, auth=auth)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更多详细的功能就可以参考 requests_oauthlib 的官方文档：<a href="https://requests-oauthlib.readthedocs.org/" target="_blank" rel="noopener">https://requests-oauthlib.readthedocs.org/</a>，在此就不再赘述了。</p>
                  <h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3>
                  <p>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的 IP，导致一定时间段内无法访问。</p>
                  <p>那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到 proxies 参数。可以用这样的方式设置：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">'http'</span>: <span class="string">'http://10.10.10.10:1080'</span>,</span><br><span class="line">  <span class="string">'https'</span>: <span class="string">'http://10.10.10.10:1080'</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">'https://httpbin.org/get'</span>, proxies=proxies)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，直接运行这个实例可能不行，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。</p>
                  <p>若代理需要使用上文所述的身份认证，可以使用类似 <a href="http://user:password@host:port">http://user:password@host:port</a> 这样的语法来设置代理，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;<span class="string">'https'</span>: <span class="string">'http://user:password@10.10.10.10:1080/'</span>,&#125;</span><br><span class="line">requests.get(<span class="string">'https://httpbin.org/get'</span>, proxies=proxies)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>除了基本的 HTTP 代理外，requests 还支持 SOCKS 协议的代理。</p>
                  <p>首先，需要安装 socks 这个库：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 install &quot;requests[socks]&quot;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后就可以使用 SOCKS 协议代理了，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'socks5://user:password@host:port'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'socks5://user:password@host:port'</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">'https://httpbin.org/get'</span>, proxies=proxies)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h3>
                  <p>我们使用 requests 库的 get 和 post 方法当然直接可以发送请求，但有没有想过，这个请求在 requests 内部是怎么实现的呢？</p>
                  <p>实际上，requests 在发送请求的时候，是在内部构造了一个 Request 对象，并给这个对象赋予了各种参数，包括 url、headers、data 等等，然后直接把这个 Request 对象发送出去，请求成功后会再得到一个 Response 对象，再解析即可。</p>
                  <p>那么这个 Request 是什么类型呢？实际上它就是 Prepared Request。</p>
                  <p>我们深入一下，不用 get 方法，直接构造一个 Prepared Request 对象来试试，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://httpbin.org/post'</span></span><br><span class="line">data = &#123;<span class="string">'name'</span>: <span class="string">'germey'</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">s = Session()</span><br><span class="line">req = Request(<span class="string">'POST'</span>, url, data=data, headers=headers)</span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line">r = s.send(prepped)</span><br><span class="line">print(r.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们引入了 Request 这个类，然后用 url、data 和 headers 参数构造了一个 Request 对象，这时需要再调用 Session 的 prepare_request 方法将其转换为一个 Prepared Request 对象，然后调用 send 方法发送，运行结果如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"germey"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>,</span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"11"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36"</span>,</span><br><span class="line">    <span class="string">"X-Amzn-Trace-Id"</span>: <span class="string">"Root=1-5e5bd6a9-6513c838f35b06a0751606d8"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"json"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"167.220.232.237"</span>,</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，我们达到了同样的 POST 请求效果。</p>
                  <p>有了 Request 这个对象，就可以将请求当作独立的对象来看待，这样在一些场景中我们可以直接操作这个 Request 对象，更灵活地实现请求的调度和各种操作。</p>
                  <p>更多的用法可以参考 requests 的官方文档：<a href="http://docs.python-requests.org/" target="_blank" rel="noopener">http://docs.python-requests.org/</a>。</p>
                  <h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2>
                  <p>本节的 requests 库的基本用法就介绍到这里了，怎么样？有没有感觉它比 urllib 使用起来更为方便。本节内容需要好好掌握，在后文我们会在实战中使用 requests 完成一个网站的爬取，巩固 requests 的相关知识。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/RequestsTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/RequestsTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-13 08:56:31" itemprop="dateCreated datePublished" datetime="2022-02-13T08:56:31+08:00">2022-02-13</time>
                </span>
                <span id="/202222.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 方便好用的 requests" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>22k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>20 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202221.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202221.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - urllib 爬虫初体验</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>首先我们介绍一个 Python 库，叫做 urllib，利用它我们可以实现 HTTP 请求的发送，而不用去关心 HTTP 协议本身甚至更低层的实现。我们只需要指定请求的 URL、请求头、请求体等信息即可实现 HTTP 请求的发送，同时 urllib 还可以把服务器返回的响应转化为 Python 对象，通过该对象我们便可以方便地获取响应的相关信息了，如响应状态码、响应头、响应体等等。</p>
                  <blockquote>
                    <p>注意：在 Python 2 中，有 urllib 和 urllib2 两个库来实现请求的发送。而在 Python 3 中，已经不存在 urllib2 这个库了，统一为 urllib，其官方文档链接为：<a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.html</a>。</p>
                  </blockquote>
                  <p>首先，我们来了解一下 urllib 库的使用方法，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。它包含如下 4 个模块。</p>
                  <ul>
                    <li><strong>request</strong>：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。</li>
                    <li><strong>error</strong>：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li>
                    <li><strong>parse</strong>：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析和合并等。</li>
                    <li><strong>robotparser</strong>：主要用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li>
                  </ul>
                  <h2 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a>1. 发送请求</h2>
                  <p>使用 urllib 的 request 模块，我们可以方便地实现请求的发送并得到响应。我们先来看下它的具体用法。</p>
                  <h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a><code>urlopen</code></h3>
                  <p>urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理授权验证（Authentication）、重定向（Redirection)、浏览器 Cookie 以及其他内容。</p>
                  <p>下面我们来看一下它的强大之处。这里以 Python 官网为例，我们来把这个网页抓下来：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/yqq2r.png" alt="image-20200315212839610"></p>
                  <p>图 运行结果</p>
                  <p>这里我们只用了两行代码，便完成了 Python 官网的抓取，输出了网页的源代码。得到源代码之后呢？我们想要的链接、图片地址、文本信息不就都可以提取出来了吗？</p>
                  <p>接下来，看看它返回的到底是什么。利用 <code>type</code> 方法输出响应的类型：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(type(response))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>输出结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">http</span>.<span class="title">client</span>.<span class="title">HTTPResponse</span>'&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，它是一个 <code>HTTPResposne</code> 类型的对象，主要包含 <code>read</code>、<code>readinto</code>、<code>getheader</code>、<code>getheaders</code>、<code>fileno</code> 等方法，以及 <code>msg</code>、<code>version</code>、<code>status</code>、<code>reason</code>、<code>debuglevel</code>、<code>closed</code> 等属性。</p>
                  <p>得到这个对象之后，我们把它赋值为 <code>response</code> 变量，然后就可以调用这些方法和属性，得到返回结果的一系列信息了。</p>
                  <p>例如，调用 <code>read</code> 方法可以得到返回的网页内容，调用 <code>status</code> 属性可以得到返回结果的状态码，如 200 代表请求成功，404 代表网页未找到等。</p>
                  <p>下面再通过一个实例来看看：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(response.status)</span><br><span class="line">print(response.getheaders())</span><br><span class="line">print(response.getheader(<span class="string">'Server'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">200</span></span><br><span class="line">[(<span class="string">'Server'</span>, <span class="string">'nginx'</span>), (<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>), (<span class="string">'X-Frame-Options'</span>, <span class="string">'DENY'</span>), (<span class="string">'Via'</span>, <span class="string">'1.1 vegur'</span>), (<span class="string">'Via'</span>, <span class="string">'1.1 varnish'</span>), (<span class="string">'Content-Length'</span>, <span class="string">'48775'</span>), (<span class="string">'Accept-Ranges'</span>, <span class="string">'bytes'</span>), (<span class="string">'Date'</span>, <span class="string">'Sun, 15 Mar 2020 13:29:01 GMT'</span>), (<span class="string">'Via'</span>, <span class="string">'1.1 varnish'</span>), (<span class="string">'Age'</span>, <span class="string">'708'</span>), (<span class="string">'Connection'</span>, <span class="string">'close'</span>), (<span class="string">'X-Served-By'</span>, <span class="string">'cache-bwi5120-BWI, cache-tyo19943-TYO'</span>), (<span class="string">'X-Cache'</span>, <span class="string">'HIT, HIT'</span>), (<span class="string">'X-Cache-Hits'</span>, <span class="string">'2, 518'</span>), (<span class="string">'X-Timer'</span>, <span class="string">'S1584278942.717942,VS0,VE0'</span>), (<span class="string">'Vary'</span>, <span class="string">'Cookie'</span>), (<span class="string">'Strict-Transport-Security'</span>, <span class="string">'max-age=63072000; includeSubDomains'</span>)]</span><br><span class="line">nginx</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可见，前两个输出分别输出了响应的状态码和响应的头信息，最后一个输出通过调用 <code>getheader</code> 方法并传递一个参数 <code>Server</code> 获取了响应头中的 <code>Server</code> 值，结果是 <code>nginx</code>，意思是服务器是用 Nginx 搭建的。</p>
                  <p>利用最基本的 <code>urlopen</code> 方法，可以完成最基本的简单网页的 GET 请求抓取。</p>
                  <p>如果想给链接传递一些参数，该怎么实现呢？首先看一下 <code>urlopen</code> 方法的 API：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">urllib.request.urlopen(url, data=<span class="literal">None</span>, [timeout,]*, cafile=<span class="literal">None</span>, capath=<span class="literal">None</span>, cadefault=<span class="literal">False</span>, context=<span class="literal">None</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，除了第一个参数可以传递 URL 之外，我们还可以传递其他内容，比如 <code>data</code>（附加数据）、<code>timeout</code>（超时时间）等。</p>
                  <p>下面我们详细说明这几个参数的用法。</p>
                  <h4 id="data-参数"><a href="#data-参数" class="headerlink" title="data 参数"></a><code>data</code> 参数</h4>
                  <p><code>data</code> 参数是可选的。如果要添加该参数，需要使用 <code>bytes</code> 方法将参数转化为字节流编码格式的内容，即 <code>bytes</code> 类型。另外，如果传递了这个参数，则它的请求方式就不再是 GET 方式，而是 POST 方式。</p>
                  <p>下面用实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;<span class="string">'name'</span>: <span class="string">'germey'</span>&#125;), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://httpbin.org/post'</span>, data=data)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们传递了一个参数 <code>word</code>，值是 <code>hello</code>。它需要被转码成 <code>bytes</code>（字节流）类型。其中转字节流采用了 <code>bytes</code> 方法，该方法的第一个参数需要是 <code>str</code>（字符串）类型，需要用 <code>urllib.parse</code> 模块里的 <code>urlencode</code> 方法来将参数字典转化为字符串；第二个参数指定编码格式，这里指定为 <code>utf-8</code>。</p>
                  <p>这里请求的站点是 httpbin.org，它可以提供 HTTP 请求测试。本次我们请求的 URL 为 <a href="https://httpbin.org/post" target="_blank" rel="noopener">https://httpbin.org/post</a>，这个链接可以用来测试 POST 请求，它可以输出 Request 的一些信息，其中就包含我们传递的 <code>data</code> 参数。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"germey"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"identity"</span>,</span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"11"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Python-urllib/3.7"</span>,</span><br><span class="line">    <span class="string">"X-Amzn-Trace-Id"</span>: <span class="string">"Root=1-5ed27e43-9eee361fec88b7d3ce9be9db"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"json"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"17.220.233.154"</span>,</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"https://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们传递的参数出现在了 <code>form</code> 字段中，这表明是模拟了表单提交的方式，以 POST 方式传输数据。</p>
                  <h4 id="timeout-参数"><a href="#timeout-参数" class="headerlink" title="timeout 参数"></a><code>timeout</code> 参数</h4>
                  <p><code>timeout</code> 参数用于设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。它支持 HTTP、HTTPS、FTP 请求。</p>
                  <p>下面用实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://httpbin.org/get'</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">print(response.read())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果可能如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line">Traceback (most recent call last): File <span class="string">"/var/py/python/urllibtest.py"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt; response =</span><br><span class="line">urllib.request.urlopen(<span class="string">'https://httpbin.org/get'</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">...</span><br><span class="line">urllib.error.URLError: &lt;urlopen error _ssl.c:<span class="number">1059</span>: The handshake operation timed out&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们设置的超时时间是 1 秒。程序运行 1 秒过后，服务器依然没有响应，于是抛出了 <code>URLError</code> 异常。该异常属于 <code>urllib.error</code> 模块，错误原因是超时。</p>
                  <p>因此，可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用 <code>try…except</code> 语句来实现，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'https://httpbin.org/get'</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(<span class="string">'TIME OUT'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们请求了 <a href="https://httpbin.org/get" target="_blank" rel="noopener">https://httpbin.org/get</a> 这个测试链接，设置的超时时间是 0.1 秒，然后捕获了 <code>URLError</code> 这个异常，然后判断异常类型是 <code>socket.timeout</code>，意思就是超时异常。因此，得出它确实是因为超时而报错，打印输出了 <code>TIME OUT</code>。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">TIME OUT</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>按照常理来说，0.1 秒内基本不可能得到服务器响应，因此输出了 <code>TIME OUT</code> 的提示。</p>
                  <p>通过设置 <code>timeout</code> 这个参数来实现超时处理，有时还是很有用的。</p>
                  <h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4>
                  <p>除了 <code>data</code> 参数和 <code>timeout</code> 参数外，还有 <code>context</code> 参数，它必须是 <code>ssl.SSLContext</code> 类型，用来指定 SSL 设置。</p>
                  <p>此外，<code>cafile</code> 和 <code>capath</code> 这两个参数分别指定 CA 证书和它的路径，这个在请求 HTTPS 链接时会有用。</p>
                  <p><code>cadefault</code> 参数现在已经弃用了，其默认值为 <code>False</code>。</p>
                  <p>前面讲解了 <code>urlopen</code> 方法的用法，通过这个最基本的方法，我们可以完成简单的请求和网页抓取。若需更加详细的信息，可以参见官方文档：<a href="https://docs.python.org/3/library/urllib.request.html" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.request.html</a>。</p>
                  <h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a><code>Request</code></h3>
                  <p>我们知道利用 <code>urlopen</code> 方法可以实现最基本请求的发起，但这几个简单的参数并不足以构建一个完整的请求。如果请求中需要加入 <code>Headers</code> 等信息，就可以利用更强大的 <code>Request</code> 类来构建。</p>
                  <p>首先，我们用实例来感受一下 <code>Request</code> 类的用法：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(<span class="string">'https://python.org'</span>)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，我们依然用 <code>urlopen</code> 方法来发送这个请求，只不过这次该方法的参数不再是 URL，而是一个 <code>Request</code> 类型的对象。通过构造这个数据结构，一方面我们可以将请求独立成一个对象，另一方面可更加丰富和灵活地配置参数。</p>
                  <p>下面我们看一下 <code>Request</code> 可以通过怎样的参数来构造，它的构造方法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span><span class="params">(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中，第一个参数 <code>url</code> 用于请求 URL，这是必传参数，其他都是可选参数。</p>
                  <p>第二个参数 <code>data</code> 如果要传，必须传 <code>bytes</code>（字节流）类型的。如果它是字典，可以先用 <code>urllib.parse</code> 模块里的 <code>urlencode()</code> 编码。</p>
                  <p>第三个参数 <code>headers</code> 是一个字典，它就是请求头。我们在构造请求时，既可以通过 <code>headers</code> 参数直接构造，也可以通过调用请求实例的 <code>add_header()</code> 方法添加。</p>
                  <p>添加请求头最常用的方法就是通过修改 <code>User-Agent</code> 来伪装浏览器。默认的 <code>User-Agent</code> 是 <code>Python-urllib</code>，我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 Firefox&#x2F;2.0.0.11</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第四个参数 <code>origin_req_host</code> 指的是请求方的 host 名称或者 IP 地址。</p>
                  <p>第五个参数 <code>unverifiable</code> 表示这个请求是否是无法验证的，默认是 <code>False</code>，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 <code>unverifiable</code> 的值就是 <code>True</code>。</p>
                  <p>第六个参数 <code>method</code> 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。</p>
                  <p>下面我们传入多个参数来构建请求：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://httpbin.org/post'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;<span class="string">'name'</span>: <span class="string">'germey'</span>&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们通过 4 个参数构造了一个请求，其中 <code>url</code> 即请求 URL，<code>headers</code> 中指定了 <code>User-Agent</code> 和 <code>Host</code>，参数 <code>data</code> 用 <code>urlencode</code> 和 <code>bytes</code> 方法转成字节流。另外，指定了请求方式为 POST。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight javascript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"germey"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"identity"</span>,</span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"11"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)"</span>,</span><br><span class="line">    <span class="string">"X-Amzn-Trace-Id"</span>: <span class="string">"Root=1-5ed27f77-884f503a2aa6760df7679f05"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"json"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"17.220.233.154"</span>,</span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"https://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>观察结果可以发现，我们成功设置了 <code>data</code>、<code>headers</code> 和 <code>method</code>。</p>
                  <p>另外，<code>headers</code> 也可以用 <code>add_header</code> 方法来添加：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">req = request.Request(url=url, data=data, method=<span class="string">'POST'</span>)</span><br><span class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如此一来，我们就可以更加方便地构造请求，实现请求的发送啦。</p>
                  <h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3>
                  <p>在上面的过程中，我们虽然可以构造请求，但是对于一些更高级的操作（比如 Cookies 处理、代理设置等），该怎么办呢？</p>
                  <p>接下来，就需要更强大的工具 Handler 登场了。简而言之，我们可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookie 的，有处理代理设置的。利用它们，我们几乎可以做到 HTTP 请求中所有的事情。</p>
                  <p>首先，介绍一下 <code>urllib.request</code> 模块里的 <code>BaseHandler</code> 类，它是所有其他 Handler 的父类，它提供了最基本的方法，例如 <code>default_open</code>、<code>protocol_request</code> 等。</p>
                  <p>接下来，就有各种 Handler 子类继承这个 <code>BaseHandler</code> 类，举例如下。</p>
                  <ul>
                    <li><code>HTTPDefaultErrorHandler</code> 用于处理 HTTP 响应错误，错误都会抛出 <code>HTTPError</code> 类型的异常。</li>
                    <li><code>HTTPRedirectHandler</code> 用于处理重定向。</li>
                    <li><code>HTTPCookieProcessor</code> 用于处理 Cookies。</li>
                    <li><code>ProxyHandler</code> 用于设置代理，默认代理为空。</li>
                    <li><code>HTTPPasswordMgr</code> 用于管理密码，它维护了用户名和密码的表。</li>
                    <li><code>HTTPBasicAuthHandler</code> 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li>
                  </ul>
                  <p>另外，还有其他的 Handler 类，这里就不一一列举了，详情可以参考官方文档： <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a>。</p>
                  <p>关于怎么使用它们，现在先不用着急，后面会有实例演示。</p>
                  <p>另一个比较重要的类就是 <code>OpenerDirector</code>，我们可以称为 Opener。我们之前用过 <code>urlopen</code> 这个方法，实际上它就是 urllib 为我们提供的一个 Opener。</p>
                  <p>那么，为什么要引入 Opener 呢？因为需要实现更高级的功能。之前使用的 <code>Request</code> 和 <code>urlopen</code> 相当于类库为你封装好了极其常用的请求方法，利用它们可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以需要深入一层进行配置，使用更底层的实例来完成操作，所以这里就用到了 Opener。</p>
                  <p>Opener 可以使用 <code>open</code> 方法，返回的类型和 <code>urlopen</code> 如出一辙。那么，它和 Handler 有什么关系呢？简而言之，就是利用 Handler 来构建 Opener。</p>
                  <p>下面用几个实例来看看它们的用法。</p>
                  <h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4>
                  <p>在访问某些设置了身份认证的网站时，例如 <a href="https://ssr3.scrape.center/，我们可能会遇到这样的认证窗口，如图" target="_blank" rel="noopener">https://ssr3.scrape.center/，我们可能会遇到这样的认证窗口，如图</a> 2- 所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/fries.png" alt="image-20210704202140395"></p>
                  <p>图 2- 认证窗口</p>
                  <p>如果遇到了这种情况，那么这个网站就是启用了基本身份认证，英文叫作 HTTP Basic Access Authentication，它是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。</p>
                  <p>那么，如果要请求这样的页面，该怎么办呢？借助 <code>HTTPBasicAuthHandler</code> 就可以完成，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line">username = <span class="string">'admin'</span></span><br><span class="line">password = <span class="string">'admin'</span></span><br><span class="line">url = <span class="string">'https://ssr3.scrape.center/'</span></span><br><span class="line"></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(<span class="literal">None</span>, url, username, password)</span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p)</span><br><span class="line">opener = build_opener(auth_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = opener.open(url)</span><br><span class="line">    html = result.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(html)</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先实例化 <code>HTTPBasicAuthHandler</code> 对象，其参数是 <code>HTTPPasswordMgrWithDefaultRealm</code> 对象，它利用 <code>add_password</code> 方法添加进去用户名和密码，这样就建立了一个处理验证的 Handler。</p>
                  <p>接下来，利用这个 Handler 并使用 <code>build_opener</code> 方法构建一个 Opener，这个 Opener 在发送请求时就相当于已经验证成功了。</p>
                  <p>接下来，利用 Opener 的 <code>open</code> 方法打开链接，就可以完成验证了。这里获取到的结果就是验证后的页面源码内容。</p>
                  <h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4>
                  <p>在做爬虫的时候，免不了要使用代理，如果要添加代理，可以这样做：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1:8080'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'https://127.0.0.1:8080'</span></span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.open(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    print(response.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们在本地需要先事先搭建一个 HTTP 代理，运行在 8080 端口上。</p>
                  <p>这里使用了 <code>ProxyHandler</code>，其参数是一个字典，键名是协议类型（比如 HTTP 或者 HTTPS 等），键值是代理链接，可以添加多个代理。</p>
                  <p>然后，利用这个 Handler 及 <code>build_opener</code> 方法构造一个 Opener，之后发送请求即可。</p>
                  <h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4>
                  <p>Cookie 的处理就需要相关的 Handler 了。</p>
                  <p>我们先用实例来看看怎样将网站的 Cookie 获取下来，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">"="</span> + item.value)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先，我们必须声明一个 <code>CookieJar</code> 对象。接下来，就需要利用 <code>HTTPCookieProcessor</code> 来构建一个 Handler，最后利用 <code>build_opener</code> 方法构建出 Opener，执行 <code>open</code> 函数即可。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">BAIDUID&#x3D;A09E6C4E38753531B9FB4C60CE9FDFCB:FG&#x3D;1</span><br><span class="line">BIDUPSID&#x3D;A09E6C4E387535312F8AA46280C6C502</span><br><span class="line">H_PS_PSSID&#x3D;31358_1452_31325_21088_31110_31253_31605_31271_31463_30823</span><br><span class="line">PSTM&#x3D;1590854698</span><br><span class="line">BDSVRTM&#x3D;10</span><br><span class="line">BD_HOME&#x3D;1</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里输出了每个 Cookie 条目的名称和值。</p>
                  <p>不过既然能输出，那可不可以输出成文件格式呢？我们知道 Cookie 实际上也是以文本形式保存的。</p>
                  <p>答案当然是肯定的，这里通过下面的实例来看看：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request, http.cookiejar</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'cookie.txt'</span></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时 <code>CookieJar</code> 就需要换成 <code>MozillaCookieJar</code>，它在生成文件时会用到，是 <code>CookieJar</code> 的子类，可以用来处理 Cookie 和文件相关的事件，比如读取和保存 Cookie，可以将 Cookie 保存成 Mozilla 型浏览器的 Cookie 格式。</p>
                  <p>运行之后，可以发现生成了一个 cookie.txt 文件，其内容如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"># Netscape HTTP Cookie File</span><br><span class="line"># http:&#x2F;&#x2F;curl.haxx.se&#x2F;rfc&#x2F;cookie_spec.html</span><br><span class="line"># This is a generated file!  Do not edit.</span><br><span class="line"></span><br><span class="line">.baidu.com	TRUE	&#x2F;	FALSE	1622390755	BAIDUID	0B4A68D74B0C0E53E5B82AFD9BF9178F:FG&#x3D;1</span><br><span class="line">.baidu.com	TRUE	&#x2F;	FALSE	3738338402	BIDUPSID	0B4A68D74B0C0E53471FA6329280FA58</span><br><span class="line">.baidu.com	TRUE	&#x2F;	FALSE		H_PS_PSSID	31262_1438_31325_21127_31110_31596_31673_31464_30823_26350</span><br><span class="line">.baidu.com	TRUE	&#x2F;	FALSE	3738338402	PSTM	1590854754</span><br><span class="line">www.baidu.com	FALSE	&#x2F;	FALSE		BDSVRTM	0</span><br><span class="line">www.baidu.com	FALSE	&#x2F;	FALSE		BD_HOME	1</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，<code>LWPCookieJar</code> 同样可以读取和保存 Cookie，但是保存的格式和 <code>MozillaCookieJar</code> 不一样，它会保存成 libwww-perl（LWP）格式的 Cookie 文件。</p>
                  <p>要保存成 LWP 格式的 Cookie 文件，可以在声明时就改为：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">cookie = http.cookiejar.LWPCookieJar(filename)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此时生成的内容如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#LWP-Cookies-2.0</span><br><span class="line">Set-Cookie3: BAIDUID&#x3D;&quot;1F30EEDA35C7A94320275F991CA5B3A5:FG&#x3D;1&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.baidu.com&quot;; path_spec; domain_dot; expires&#x3D;&quot;2021-05-30 16:06:39Z&quot;; comment&#x3D;bd; version&#x3D;0</span><br><span class="line">Set-Cookie3: BIDUPSID&#x3D;1F30EEDA35C7A9433C97CF6245CBC383; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.baidu.com&quot;; path_spec; domain_dot; expires&#x3D;&quot;2088-06-17 19:20:46Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: H_PS_PSSID&#x3D;31626_1440_21124_31069_31254_31594_30841_31673_31464_31715_30823; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.baidu.com&quot;; path_spec; domain_dot; discard; version&#x3D;0</span><br><span class="line">Set-Cookie3: PSTM&#x3D;1590854799; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.baidu.com&quot;; path_spec; domain_dot; expires&#x3D;&quot;2088-06-17 19:20:46Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: BDSVRTM&#x3D;11; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;www.baidu.com&quot;; path_spec; discard; version&#x3D;0</span><br><span class="line">Set-Cookie3: BD_HOME&#x3D;1; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;www.baidu.com&quot;; path_spec; discard; version&#x3D;0</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由此看来，生成的格式还是有比较大差异的。</p>
                  <p>那么，生成了 Cookie 文件后，怎样从文件中读取并利用呢？</p>
                  <p>下面我们以 <code>LWPCookieJar</code> 格式为例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> urllib.request, http.cookiejar</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.LWPCookieJar()</span><br><span class="line">cookie.load(<span class="string">'cookie.txt'</span>, ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里调用 <code>load</code> 方法来读取本地的 Cookie 文件，获取到了 Cookie 的内容。不过前提是我们首先生成了 <code>LWPCookieJar</code> 格式的 Cookie，并保存成文件，然后读取 Cookie 之后使用同样的方法构建 Handler 和 Opener 即可完成操作。</p>
                  <p>运行结果正常的话，会输出百度网页的源代码。</p>
                  <p>通过上面的方法，我们可以实现绝大多数请求功能的设置了。</p>
                  <p>这便是 urllib 库中 request 模块的基本用法，如果想实现更多的功能，可以参考官方文档的说明：<a href="https://docs.python.org/3/library/urllib.request.html#basehandler-objects" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.request.html#basehandler-objects</a>。</p>
                  <h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a>2. 处理异常</h2>
                  <p>在前一节中，我们了解了请求的发送过程，但是在网络不好的情况下，如果出现了异常，该怎么办呢？这时如果不处理这些异常，程序很可能因报错而终止运行，所以异常处理还是十分有必要的。</p>
                  <p>urllib 的 error 模块定义了由 request 模块产生的异常。如果出现了问题，request 模块便会抛出 error 模块中定义的异常。</p>
                  <h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a><code>URLError</code></h3>
                  <p><code>URLError</code> 类来自 urllib 库的 error 模块，它继承自 <code>OSError</code> 类，是 error 异常模块的基类，由 request 模块产生的异常都可以通过捕获这个类来处理。</p>
                  <p>它具有一个属性 <code>reason</code>，即返回错误的原因。</p>
                  <p>下面用一个实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/404'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们打开一个不存在的页面，照理来说应该会报错，但是这时我们捕获了 <code>URLError</code> 这个异常，运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Not Found</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>程序没有直接报错，而是输出了如上内容，这样就可以避免程序异常终止，同时异常得到了有效处理。</p>
                  <h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a><code>HTTPError</code></h3>
                  <p>它是 <code>URLError</code> 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。</p>
                  <ul>
                    <li><code>code</code>：返回 HTTP 状态码，比如 404 表示网页不存在，500 表示服务器内部错误等。</li>
                    <li><code>reason</code>：同父类一样，用于返回错误的原因。</li>
                    <li><code>headers</code>：返回请求头。</li>
                  </ul>
                  <p>下面我们用几个实例来看看：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/404'</span>)</span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Not Found</span><br><span class="line">404</span><br><span class="line">Server: nginx&#x2F;1.10.3 (Ubuntu)</span><br><span class="line">Date: Sat, 30 May 2020 16:08:42 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: close</span><br><span class="line">Set-Cookie: PHPSESSID&#x3D;kp1a1b0o3a0pcf688kt73gc780; path&#x3D;&#x2F;</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Vary: Cookie</span><br><span class="line">Expires: Wed, 11 Jan 1984 05:00:00 GMT</span><br><span class="line">Cache-Control: no-cache, must-revalidate, max-age&#x3D;0</span><br><span class="line">Link: &lt;https:&#x2F;&#x2F;cuiqingcai.com&#x2F;wp-json&#x2F;&gt;; rel&#x3D;&quot;https:&#x2F;&#x2F;api.w.org&#x2F;&quot;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>依然是同样的网址，这里捕获了 <code>HTTPError</code> 异常，输出了 <code>reason</code>、<code>code</code> 和 <code>headers</code> 属性。</p>
                  <p>因为 <code>URLError</code> 是 <code>HTTPError</code> 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误，所以上述代码的更好写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/404'</span>)</span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Request Successfully'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以做到先捕获 <code>HTTPError</code>，获取它的错误原因、状态码、<code>headers</code> 等信息。如果不是 <code>HTTPError</code> 异常，就会捕获 <code>URLError</code> 异常，输出错误原因。最后，用 <code>else</code> 来处理正常的逻辑。这是一个较好的异常处理写法。</p>
                  <p>有时候，<code>reason</code> 属性返回的不一定是字符串，也可能是一个对象。再看下面的实例：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'https://www.baidu.com'</span>, timeout=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(type(e.reason))</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(<span class="string">'TIME OUT'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们直接设置超时时间来强制抛出 <code>timeout</code> 异常。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span>'<span class="title">socket</span>.<span class="title">timeout</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">TIME</span> <span class="title">OUT</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，<code>reason</code> 属性的结果是 <code>socket.timeout</code> 类。所以，这里我们可以用 <code>isinstance</code> 方法来判断它的类型，作出更详细的异常判断。</p>
                  <p>本节中，我们讲述了 error 模块的相关用法，通过合理地捕获异常可以做出更准确的异常判断，使程序更加稳健。</p>
                  <h2 id="3-解析链接"><a href="#3-解析链接" class="headerlink" title="3. 解析链接"></a>3. 解析链接</h2>
                  <p>前面说过，urllib 库里还提供了 parse 模块，它定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。它支持如下协议的 URL 处理：<code>file</code>、<code>ftp</code>、<code>gopher</code>、<code>hdl</code>、<code>http</code>、<code>https</code>、<code>imap</code>、<code>mailto</code>、<code>mms</code>、<code>news</code>、<code>nntp</code>、<code>prospero</code>、<code>rsync</code>、<code>rtsp</code>、<code>rtspu</code>、<code>sftp</code>、<code>sip</code>、<code>sips</code>、<code>snews</code>、<code>svn</code>、<code>svn+ssh</code>、<code>telnet</code> 和 <code>wais</code>。本节中，我们介绍一下该模块中常用的方法来看一下它的便捷之处。</p>
                  <h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a><code>urlparse</code></h3>
                  <p>该方法可以实现 URL 的识别和分段，这里先用一个实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'https://www.baidu.com/index.html;user?id=5#comment'</span>)</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们利用 <code>urlparse</code> 方法进行了一个 URL 的解析。首先，输出了解析结果的类型，然后将结果也输出出来。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">urllib</span>.<span class="title">parse</span>.<span class="title">ParseResult</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">ParseResult</span><span class="params">(scheme=<span class="string">'https'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，返回结果是一个 <code>ParseResult</code> 类型的对象，它包含 6 个部分，分别是 <code>scheme</code>、<code>netloc</code>、<code>path</code>、<code>params</code>、<code>query</code> 和 <code>fragment</code>。</p>
                  <p>观察一下该实例的 URL：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;index.html;user?id&#x3D;5#comment</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，<code>urlparse</code> 方法将其拆分成了 6 个部分。大体观察可以发现，解析时有特定的分隔符。比如，<code>://</code> 前面的就是 <code>scheme</code>，代表协议；第一个 <code>/</code> 符号前面便是 <code>netloc</code>，即域名，后面是 <code>path</code>，即访问路径；分号<code>;</code>后面是 <code>params</code>，代表参数；问号 <code>?</code> 后面是查询条件 <code>query</code>，一般用作 GET 类型的 URL；井号 <code>#</code> 后面是锚点，用于直接定位页面内部的下拉位置。</p>
                  <p>所以，可以得出一个标准的链接格式，具体如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>一个标准的 URL 都会符合这个规则，利用 <code>urlparse</code> 方法可以将它拆分开来。</p>
                  <p>除了这种最基本的解析方式外，<code>urlparse</code> 方法还有其他配置吗？接下来，看一下它的 API 用法：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">urllib.parse.urlparse(urlstring, scheme=<span class="string">''</span>, allow_fragments=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，它有 3 个参数。</p>
                  <ul>
                    <li><code>urlstring</code>：这是必填项，即待解析的 URL。</li>
                    <li><code>scheme</code>：它是默认的协议（比如 <code>http</code> 或 <code>https</code> 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。我们用实例来看一下：</li>
                  </ul>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'www.baidu.com/index.html;user?id=5#comment'</span>, scheme=<span class="string">'https'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ParseResult(scheme=<span class="string">'https'</span>, netloc=<span class="string">''</span>, path=<span class="string">'www.baidu.com/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，我们提供的 URL 没有包含最前面的 <code>scheme</code> 信息，但是通过默认的 <code>scheme</code> 参数，返回的结果是 <code>https</code>。</p>
                  <p>假设我们带上了 <code>scheme</code>：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = urlparse(<span class="string">'http://www.baidu.com/index.html;user?id=5#comment'</span>, scheme=<span class="string">'https'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>则结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可见，<code>scheme</code> 参数只有在 URL 中不包含 <code>scheme</code> 信息时才生效。如果 URL 中有 <code>scheme</code> 信息，就会返回解析出的 <code>scheme</code>。</p>
                  <ul>
                    <li><code>allow_fragments</code>：即是否忽略 <code>fragment</code>。如果它被设置为 <code>False</code>，<code>fragment</code> 部分就会被忽略，它会被解析为 <code>path</code>、<code>parameters</code> 或者 <code>query</code> 的一部分，而 <code>fragment</code> 部分为空。</li>
                  </ul>
                  <p>下面我们用实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'https://www.baidu.com/index.html;user?id=5#comment'</span>, allow_fragments=<span class="literal">False</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ParseResult(scheme=<span class="string">'https'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html'</span>, params=<span class="string">'user'</span>, query=<span class="string">'id=5#comment'</span>, fragment=<span class="string">''</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>假设 URL 中不包含 <code>params</code> 和 <code>query</code>，我们再通过实例看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'https://www.baidu.com/index.html#comment'</span>, allow_fragments=<span class="literal">False</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ParseResult(scheme=<span class="string">'https'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html#comment'</span>, params=<span class="string">''</span>, query=<span class="string">''</span>, fragment=<span class="string">''</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，当 URL 中不包含 <code>params</code> 和 <code>query</code> 时，<code>fragment</code> 便会被解析为 <code>path</code> 的一部分。</p>
                  <p>返回结果 <code>ParseResult</code> 实际上是一个元组，我们既可以用索引顺序来获取，也可以用属性名获取。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">'https://www.baidu.com/index.html#comment'</span>, allow_fragments=<span class="literal">False</span>)</span><br><span class="line">print(result.scheme, result[<span class="number">0</span>], result.netloc, result[<span class="number">1</span>], sep=<span class="string">'\n'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们分别用索引和属性名获取了 <code>scheme</code> 和 <code>netloc</code>，其运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https</span><br><span class="line">https</span><br><span class="line">www.baidu.com</span><br><span class="line">www.baidu.com</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，二者的结果是一致的，两种方法都可以成功获取。</p>
                  <h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a><code>urlunparse</code></h3>
                  <p>有了 <code>urlparse</code> 方法，相应地就有了它的对立方法 <code>urlunparse</code>。它接收的参数是一个可迭代对象，但是它的长度必须是 6，否则会抛出参数数量不足或者过多的问题。先用一个实例看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"></span><br><span class="line">data = [<span class="string">'https'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'user'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]</span><br><span class="line">print(urlunparse(data))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里参数 <code>data</code> 用了列表类型。当然，你也可以用其他类型，比如元组或者特定的数据结构。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;index.html;user?a&#x3D;6#comment</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就成功实现了 URL 的构造。</p>
                  <h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a><code>urlsplit</code></h3>
                  <p>这个方法和 <code>urlparse</code> 方法非常相似，只不过它不再单独解析 <code>params</code> 这一部分，只返回 5 个结果。上面例子中的 <code>params</code> 会合并到 <code>path</code> 中。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit</span><br><span class="line"></span><br><span class="line">result = urlsplit(<span class="string">'https://www.baidu.com/index.html;user?id=5#comment'</span>)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">SplitResult(scheme=<span class="string">'https'</span>, netloc=<span class="string">'www.baidu.com'</span>, path=<span class="string">'/index.html;user'</span>, query=<span class="string">'id=5'</span>, fragment=<span class="string">'comment'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，返回结果是 <code>SplitResult</code>，它其实也是一个元组类型，既可以用属性获取值，也可以用索引来获取。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlsplit</span><br><span class="line"></span><br><span class="line">result = urlsplit(<span class="string">'https://www.baidu.com/index.html;user?id=5#comment'</span>)</span><br><span class="line">print(result.scheme, result[<span class="number">0</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https https</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a><code>urlunsplit</code></h3>
                  <p>与 <code>urlunparse</code> 方法类似，它也是将链接各个部分组合成完整链接的方法，传入的参数也是一个可迭代对象，例如列表、元组等，唯一的区别是长度必须为 5。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunsplit</span><br><span class="line"></span><br><span class="line">data = [<span class="string">'https'</span>, <span class="string">'www.baidu.com'</span>, <span class="string">'index.html'</span>, <span class="string">'a=6'</span>, <span class="string">'comment'</span>]</span><br><span class="line">print(urlunsplit(data))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;index.html?a&#x3D;6#comment</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a><code>urljoin</code></h3>
                  <p>有了 <code>urlunparse</code> 和 <code>urlunsplit</code> 方法，我们可以完成链接的合并，不过前提是必须要有特定长度的对象，链接的每一部分都要清晰分开。</p>
                  <p>此外，生成链接还有另一个方法，那就是 <code>urljoin</code> 方法。我们可以提供一个 <code>base_url</code>（基础链接）作为第一个参数，将新的链接作为第二个参数，该方法会分析 <code>base_url</code> 的 <code>scheme</code>、<code>netloc</code> 和 <code>path</code> 这 3 个内容并对新链接缺失的部分进行补充，最后返回结果。</p>
                  <p>下面通过几个实例看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com'</span>, <span class="string">'FAQ.html'</span>))</span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))</span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html'</span>))</span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com/about.html'</span>, <span class="string">'https://cuiqingcai.com/FAQ.html?question=2'</span>))</span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com?wd=abc'</span>, <span class="string">'https://cuiqingcai.com/index.php'</span>))</span><br><span class="line">print(urljoin(<span class="string">'https://www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))</span><br><span class="line">print(urljoin(<span class="string">'www.baidu.com'</span>, <span class="string">'?category=2#comment'</span>))</span><br><span class="line">print(urljoin(<span class="string">'www.baidu.com#comment'</span>, <span class="string">'?category=2'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;FAQ.html</span><br><span class="line">https:&#x2F;&#x2F;cuiqingcai.com&#x2F;FAQ.html</span><br><span class="line">https:&#x2F;&#x2F;cuiqingcai.com&#x2F;FAQ.html</span><br><span class="line">https:&#x2F;&#x2F;cuiqingcai.com&#x2F;FAQ.html?question&#x3D;2</span><br><span class="line">https:&#x2F;&#x2F;cuiqingcai.com&#x2F;index.php</span><br><span class="line">https:&#x2F;&#x2F;www.baidu.com?category&#x3D;2#comment</span><br><span class="line">www.baidu.com?category&#x3D;2#comment</span><br><span class="line">www.baidu.com?category&#x3D;2</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以发现，<code>base_url</code> 提供了三项内容 <code>scheme</code>、<code>netloc</code> 和 <code>path</code>。如果这 3 项在新的链接里不存在，就予以补充；如果新的链接存在，就使用新的链接的部分。而 <code>base_url</code> 中的 <code>params</code>、<code>query</code> 和 <code>fragment</code> 是不起作用的。</p>
                  <p>通过 <code>urljoin</code> 方法，我们可以轻松实现链接的解析、拼合与生成。</p>
                  <h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a><code>urlencode</code></h3>
                  <p>这里我们再介绍一个常用的方法 —— <code>urlencode</code>，它在构造 GET 请求参数的时候非常有用，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'germey'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">'https://www.baidu.com?'</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先声明一个字典来将参数表示出来，然后调用 <code>urlencode</code> 方法将其序列化为 GET 请求参数。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com?name&#x3D;germey&amp;age&#x3D;25</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，参数成功地由字典类型转化为 GET 请求参数了。</p>
                  <p>这个方法非常常用。有时为了更加方便地构造参数，我们会事先用字典来表示。要转化为 URL 的参数时，只需要调用该方法即可。</p>
                  <h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a><code>parse_qs</code></h3>
                  <p>有了序列化，必然就有反序列化。如果我们有一串 GET 请求参数，利用 <code>parse_qs</code> 方法，就可以将它转回字典，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;age=25'</span></span><br><span class="line">print(parse_qs(query))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;<span class="string">'name'</span>: [<span class="string">'germey'</span>], <span class="string">'age'</span>: [<span class="string">'25'</span>]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这样就成功转回为字典类型了。</p>
                  <h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a><code>parse_qsl</code></h3>
                  <p>另外，还有一个 <code>parse_qsl</code> 方法，它用于将参数转化为元组组成的列表，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qsl</span><br><span class="line"></span><br><span class="line">query = <span class="string">'name=germey&amp;age=25'</span></span><br><span class="line">print(parse_qsl(query))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[(<span class="string">'name'</span>, <span class="string">'germey'</span>), (<span class="string">'age'</span>, <span class="string">'25'</span>)]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，运行结果是一个列表，而列表中的每一个元素都是一个元组，元组的第一个内容是参数名，第二个内容是参数值。</p>
                  <h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a><code>quote</code></h3>
                  <p>该方法可以将内容转化为 URL 编码的格式。URL 中带有中文参数时，有时可能会导致乱码的问题，此时可以用这个方法可以将中文字符转化为 URL 编码，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">'壁纸'</span></span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd='</span> + quote(keyword)</span><br><span class="line">print(url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们声明了一个中文的搜索文字，然后用 <code>quote</code> 方法对其进行 URL 编码，最后得到的结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;%E5%A3%81%E7%BA%B8</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a><code>unquote</code></h3>
                  <p>有了 <code>quote</code> 方法，当然还有 <code>unquote</code> 方法，它可以进行 URL 解码，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8'</span></span><br><span class="line">print(unquote(url))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这是上面得到的 URL 编码后的结果，这里利用 <code>unquote</code> 方法还原，结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;壁纸</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，利用 <code>unquote</code> 方法可以方便地实现解码。</p>
                  <p>本节中，我们介绍了 parse 模块的一些常用 URL 处理方法。有了这些方法，我们可以方便地实现 URL 的解析和构造，建议熟练掌握。</p>
                  <h2 id="4-分析-Robots-协议"><a href="#4-分析-Robots-协议" class="headerlink" title="4. 分析 Robots 协议"></a>4. 分析 Robots 协议</h2>
                  <p>利用 urllib 的 robotparser 模块，我们可以实现网站 Robots 协议的分析。本节中，我们来简单了解一下该模块的用法。</p>
                  <h3 id="1-Robots-协议"><a href="#1-Robots-协议" class="headerlink" title="1. Robots 协议"></a>1. Robots 协议</h3>
                  <p>Robots 协议也称作爬虫协议、机器人协议，它的全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作 robots.txt 的文本文件，一般放在网站的根目录下。</p>
                  <p>当搜索爬虫访问一个站点时，它首先会检查这个站点根目录下是否存在 robots.txt 文件，如果存在，搜索爬虫会根据其中定义的爬取范围来爬取。如果没有找到这个文件，搜索爬虫便会访问所有可直接访问的页面。</p>
                  <p>下面我们看一个 robots.txt 的样例：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">Allow: &#x2F;public&#x2F;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这实现了对所有搜索爬虫只允许爬取 public 目录的功能，将上述内容保存成 robots.txt 文件，放在网站的根目录下，和网站的入口文件（比如 index.php、index.html 和 index.jsp 等）放在一起。</p>
                  <p>上面的 <code>User-agent</code> 描述了搜索爬虫的名称，这里将其设置为 <code>*</code> 则代表该协议对任何爬取爬虫有效。比如，我们可以设置：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: Baiduspider</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就代表我们设置的规则对百度爬虫是有效的。如果有多条 <code>User-agent</code> 记录，就有多个爬虫会受到爬取限制，但至少需要指定一条。</p>
                  <p><code>Disallow</code> 指定了不允许抓取的目录，比如上例子中设置为 <code>/</code> 则代表不允许抓取所有页面。</p>
                  <p><code>Allow</code> 一般和 <code>Disallow</code> 一起使用，一般不会单独使用，用来排除某些限制。上例中我们设置为 <code>/public/</code>，则表示所有页面不允许抓取，但可以抓取 public 目录。</p>
                  <p>下面我们再来看几个例子。禁止所有爬虫访问任何目录的代码如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>允许所有爬虫访问任何目录的代码如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: *</span><br><span class="line">Disallow:</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，直接把 robots.txt 文件留空也是可以的。</p>
                  <p>禁止所有爬虫访问网站某些目录的代码如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;private&#x2F;</span><br><span class="line">Disallow: &#x2F;tmp&#x2F;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>只允许某一个爬虫访问的代码如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: WebCrawler</span><br><span class="line">Disallow:</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这些是 robots.txt 的一些常见写法。</p>
                  <h3 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h3>
                  <p>大家可能会疑惑，爬虫名是从哪儿来的？为什么就叫这个名？其实它是有固定名字的了，比如百度的就叫作 BaiduSpider。表 2- 列出了一些常见搜索爬虫的名称及对应的网站。</p>
                  <p>表 一些常见搜索爬虫的名称及其对应的网站</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">爬虫名称</th>
                          <th style="text-align:left">名称</th>
                          <th style="text-align:left">网站</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left">BaiduSpider</td>
                          <td style="text-align:left">百度</td>
                          <td style="text-align:left">www.baidu.com</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">Googlebot</td>
                          <td style="text-align:left">谷歌</td>
                          <td style="text-align:left">www.google.com</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">360Spider</td>
                          <td style="text-align:left">360 搜索</td>
                          <td style="text-align:left">www.so.com</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">YodaoBot</td>
                          <td style="text-align:left">有道</td>
                          <td style="text-align:left">www.youdao.com</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">ia_archiver</td>
                          <td style="text-align:left">Alexa</td>
                          <td style="text-align:left">www.alexa.cn</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">Scooter</td>
                          <td style="text-align:left">altavista</td>
                          <td style="text-align:left">www.altavista.com</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">Bingbot</td>
                          <td style="text-align:left">必应</td>
                          <td style="text-align:left">www.bing.com</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3>
                  <p>了解 Robots 协议之后，我们就可以使用 robotparser 模块来解析 robots.txt 了。该模块提供了一个类 <code>RobotFileParser</code>，它可以根据某网站的 robots.txt 文件来判断一个爬虫是否有权限来爬取这个网页。</p>
                  <p>该类用起来非常简单，只需要在构造方法里传入 robots.txt 的链接即可。首先看一下它的声明：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">urllib.robotparser.RobotFileParser(url=<span class="string">''</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，也可以在声明时不传入，默认为空，最后再使用 <code>set_url</code> 方法设置一下即可。</p>
                  <p>下面列出了这个类常用的几个方法。</p>
                  <ul>
                    <li><code>set_url</code>：用来设置 robots.txt 文件的链接。如果在创建 <code>RobotFileParser</code> 对象时传入了链接，那么就不需要再使用这个方法设置了。</li>
                    <li><code>read</code>：读取 robots.txt 文件并进行分析。注意，这个方法执行一个读取和分析操作，如果不调用这个方法，接下来的判断都会为 <code>False</code>，所以一定记得调用这个方法。这个方法不会返回任何内容，但是执行了读取操作。</li>
                    <li><code>parse</code>：用来解析 robots.txt 文件，传入的参数是 robots.txt 某些行的内容，它会按照 robots.txt 的语法规则来分析这些内容。</li>
                    <li><code>can_fetch</code>：该方法用两个参数，第一个是 <code>User-Agent</code>，第二个是要抓取的 URL。返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 <code>True</code> 或 <code>False</code>。</li>
                    <li><code>mtime</code>：返回的是上次抓取和分析 robots.txt 的时间，这对于长时间分析和抓取的搜索爬虫是很有必要的，你可能需要定期检查来抓取最新的 robots.txt。</li>
                    <li><code>modified</code>：它同样对长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li>
                  </ul>
                  <p>下面我们用实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line"></span><br><span class="line">rp = RobotFileParser()</span><br><span class="line">rp.set_url(<span class="string">'https://www.baidu.com/robots.txt'</span>)</span><br><span class="line">rp.read()</span><br><span class="line">print(rp.can_fetch(<span class="string">'Baiduspider'</span>, <span class="string">'https://www.baidu.com'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'Baiduspider'</span>, <span class="string">'https://www.baidu.com/homepage/'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'Googlebot'</span>, <span class="string">'https://www.baidu.com/homepage/'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里以百度为例，首先创建 <code>RobotFileParser</code> 对象，然后通过 <code>set_url</code> 方法设置了 robots.txt 的链接。当然，不用这个方法的话，可以在声明时直接用如下方法设置：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">rp = RobotFileParser(<span class="string">'https://www.baidu.com/robots.txt'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接着利用 <code>can_fetch</code> 方法判断网页是否可以被抓取。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里同样可以使用 <code>parse</code> 方法执行读取和分析，示例如下：<br>可以看到这里我们利用 Baiduspider 可以抓取百度等首页以及 homepage 页面，但是 Googlebot 就不能抓取 homepage 页面。</p>
                  <p>打开百度的 robots.txt 文件看下，可以看到如下的信息：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">User-agent: Baiduspider</span><br><span class="line">Disallow: &#x2F;baidu</span><br><span class="line">Disallow: &#x2F;s?</span><br><span class="line">Disallow: &#x2F;ulink?</span><br><span class="line">Disallow: &#x2F;link?</span><br><span class="line">Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;</span><br><span class="line">Disallow: &#x2F;bh</span><br><span class="line"></span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Disallow: &#x2F;baidu</span><br><span class="line">Disallow: &#x2F;s?</span><br><span class="line">Disallow: &#x2F;shifen&#x2F;</span><br><span class="line">Disallow: &#x2F;homepage&#x2F;</span><br><span class="line">Disallow: &#x2F;cpro</span><br><span class="line">Disallow: &#x2F;ulink?</span><br><span class="line">Disallow: &#x2F;link?</span><br><span class="line">Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;</span><br><span class="line">Disallow: &#x2F;bh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由此我们可以看到，Baiduspider 没有限制 homepage 页面的抓取，而 Googlebot 则限制了 homepage 页面的抓取。</p>
                  <p>这里同样可以使用 parse 方法执行读取和分析，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line"></span><br><span class="line">rp = RobotFileParser()</span><br><span class="line">rp.parse(urlopen(<span class="string">'https://www.baidu.com/robots.txt'</span>).read().decode(<span class="string">'utf-8'</span>).split(<span class="string">'\n'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'Baiduspider'</span>, <span class="string">'https://www.baidu.com'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'Baiduspider'</span>, <span class="string">'https://www.baidu.com/homepage/'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'Googlebot'</span>, <span class="string">'https://www.baidu.com/homepage/'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果一样：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>本节介绍了 robotparser 模块的基本用法和实例，利用它，我们可以方便地判断哪些页面可以抓取，哪些页面不可以抓取。</p>
                  <h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2>
                  <p>本节内容比较多，我们介绍了 urllib 的 request、error、parse、robotparser 模块的基本用法。这些是一些基础模块，其中有一些模块的实用性还是很强的，比如我们可以利用 parse 模块来进行 URL 的各种处理。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/UrllibTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/UrllibTest</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-13 07:44:31" itemprop="dateCreated datePublished" datetime="2022-02-13T07:44:31+08:00">2022-02-13</time>
                </span>
                <span id="/202221.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - urllib 爬虫初体验" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>27k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>24 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202223.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202223.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 强大灵活的正则表达式</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>在上一节中，我们已经可以用 requests 来获取网页的源代码，得到 HTML 代码。但我们真正想要的数据是包含在 HTML 代码之中的，怎么才能从 HTML 代码中获取我们想要的信息呢？正则表达式就是其中一个有效的方法。</p>
                  <p>本节中，我们了解一下正则表达式的相关用法。正则表达式是处理字符串的强大工具，它有自己特定的语法结构，有了它，实现字符串的检索、替换、匹配验证都不在话下。</p>
                  <p>当然，对于爬虫来说，有了它，从 HTML 里提取想要的信息就非常方便了。</p>
                  <h3 id="1-实例引入"><a href="#1-实例引入" class="headerlink" title="1. 实例引入"></a>1. 实例引入</h3>
                  <p>说了这么多，可能我们对它到底是个什么还是比较模糊，下面就用几个实例来看一下正则表达式的用法。</p>
                  <p>打开开源中国提供的正则表达式测试工具 <a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。例如，这里输入待匹配的文本，具体如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Hello, my phone number is 010-86432100 and email is cqc@cuiqingcai.com, and my website is https:&#x2F;&#x2F;cuiqingcai.com</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这段字符串中包含了一个电话号码和一个电子邮件和一个 URL，接下来就尝试用正则表达式提取出来，如图所示。</p>
                  <p>在网页右侧选择「匹配 Email 地址」，就可以看到下方出现了文本中的 E-mail。</p>
                  <p><img src="https://cdn.cuiqingcai.com/lsdsz.png" alt=""></p>
                  <p>如果选择「匹配网址 URL」，就可以看到下方出现了文本中的 URL。</p>
                  <p>在网页右侧选择 “匹配 Email 地址”，就可以看到下方出现了文本中的 E-mail。如果选择 “匹配网址 URL”，就可以看到下方出现了文本中的 URL。是不是非常神奇？</p>
                  <p><img src="https://cdn.cuiqingcai.com/ijr13.png" alt=""></p>
                  <p>其实，这里就是用了正则表达式匹配，也就是用一定的规则将特定的文本提取出来。比如，电子邮件开头是一段字符串，然后是一个 <code>@</code> 符号，最后是某个域名，这是有特定的组成格式的。另外，对于 URL，开头是协议类型，然后是冒号加双斜线，最后是域名加路径。</p>
                  <p>对于 URL 来说，可以用下面的正则表达式匹配：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[a-zA-z]+:&#x2F;&#x2F;[^\s]*</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似 URL 的文本，就会被提取出来。</p>
                  <p>这个正则表达式看上去是乱糟糟的一团，其实不然，这里面都是有特定的语法规则的。比如，<code>a-z</code> 代表匹配任意的小写字母，<code>\s</code> 表示匹配任意的空白字符，<code>*</code> 就代表匹配前面的字符任意多个，这一长串的正则表达式就是这么多匹配规则的组合。</p>
                  <p>写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源代码里有多少 URL，用匹配 URL 的正则表达式去匹配即可。</p>
                  <p>上面我们说了几个匹配规则，表 2- 列出了常用的匹配规则。</p>
                  <p>表 2- 常用的匹配规则</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">模　　式</th>
                          <th style="text-align:left">描　　述</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>\w</code></td>
                          <td style="text-align:left">匹配字母、数字及下划线</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\W</code></td>
                          <td style="text-align:left">匹配不是字母、数字及下划线的字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\s</code></td>
                          <td style="text-align:left">匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\S</code></td>
                          <td style="text-align:left">匹配任意非空字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\d</code></td>
                          <td style="text-align:left">匹配任意数字，等价于 <code>[0-9]</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\D</code></td>
                          <td style="text-align:left">匹配任意非数字的字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\A</code></td>
                          <td style="text-align:left">匹配字符串开头</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\Z</code></td>
                          <td style="text-align:left">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\z</code></td>
                          <td style="text-align:left">匹配字符串结尾，如果存在换行，同时还会匹配换行符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\G</code></td>
                          <td style="text-align:left">匹配最后匹配完成的位置</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\n</code></td>
                          <td style="text-align:left">匹配一个换行符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>\t</code></td>
                          <td style="text-align:left">匹配一个制表符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>^</code></td>
                          <td style="text-align:left">匹配一行字符串的开头</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>$</code></td>
                          <td style="text-align:left">匹配一行字符串的结尾</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>.</code></td>
                          <td style="text-align:left">匹配任意字符，除了换行符，当 <code>re.DOTALL</code> 标记被指定时，则可以匹配包括换行符的任意字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[...]</code></td>
                          <td style="text-align:left">用来表示一组字符，单独列出，比如 <code>[amk]</code> 匹配 <code>a</code>、<code>m</code> 或 <code>k</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[^...]</code></td>
                          <td style="text-align:left">不在 <code>[]</code> 中的字符，比如 匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 之外的字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>*</code></td>
                          <td style="text-align:left">匹配 0 个或多个表达式</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>+</code></td>
                          <td style="text-align:left">匹配 1 个或多个表达式</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>?</code></td>
                          <td style="text-align:left">匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>{n}</code></td>
                          <td style="text-align:left">精确匹配 n 个前面的表达式</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>{n, m}</code></td>
                          <td style="text-align:left">匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">`a</td>
                          <td style="text-align:left">b`</td>
                          <td>匹配 a 或 b</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>()</code></td>
                          <td style="text-align:left">匹配括号内的表达式，也表示一个组</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>看完了之后，可能有点晕晕的吧，不过不用担心，后面我们会详细讲解一些常见规则的用法。</p>
                  <p>其实正则表达式不是 Python 独有的，它也可以用在其他编程语言中。Python 的 re 库提供了整个正则表达式的实现，利用这个库，可以在 Python 中使用正则表达式。在 Python 中写正则表达式几乎都用这个库，下面就来了解它的一些常用方法。</p>
                  <h2 id="2-match"><a href="#2-match" class="headerlink" title="2. match"></a>2. <code>match</code></h2>
                  <p>这里首先介绍第一个常用的匹配方法 —— <code>match</code>，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p>
                  <p><code>match</code> 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 <code>None</code>。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line">print(len(content))</span><br><span class="line">result = re.match(<span class="string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">41</span></span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">'Hello 123 4567 World_This'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>用它来匹配这个长字符串。开头的 <code>^</code> 是匹配字符串的开头，也就是以 <code>Hello</code> 开头；然后 <code>\s</code> 匹配空白字符，用来匹配目标字符串的空格；<code>\d</code> 匹配数字，3 个 <code>\d</code> 匹配 <code>123</code>；然后再写 1 个 <code>\s</code> 匹配空格；后面还有 <code>4567</code>，我们其实可以依然用 4 个 <code>\d</code> 来匹配，但是这么写比较烦琐，所以后面可以跟 <code>{4}</code> 以代表匹配前面的规则 4 次，也就是匹配 4 个数字；后面再紧接 1 个空白字符，最后的 <code>\w{10}</code> 匹配 10 个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。</p>
                  <p>而在 <code>match</code> 方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。</p>
                  <p>打印输出结果，可以看到结果是 <code>SRE_Match</code> 对象，这证明成功匹配。该对象有两个方法：<code>group</code> 方法可以输出匹配到的内容，结果是 <code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code> 方法可以输出匹配的范围，结果是 <code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>
                  <p>通过上面的例子，我们基本了解了如何在 Python 中使用正则表达式来匹配一段文字。</p>
                  <h3 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h3>
                  <p>刚才我们用 <code>match</code> 方法得到匹配到的字符串内容，但是如果想从字符串中提取一部分内容，该怎么办呢？就像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。</p>
                  <p>这里可以使用括号 <code>()</code> 将想提取的子字符串括起来。<code>()</code> 实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用 <code>group</code> 方法传入分组的索引即可获取提取的结果。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^Hello\s(\d+)\sWorld'</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.span())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们想把字符串中的 <code>1234567</code> 提取出来，此时可以将数字部分的正则表达式用 <code>()</code> 括起来，然后调用了 <code>group(1)</code> 获取匹配结果。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">19</span>), match=<span class="string">'Hello 1234567 World'</span>&gt;</span><br><span class="line">Hello <span class="number">1234567</span> World</span><br><span class="line"><span class="number">1234567</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">19</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，我们成功得到了 <code>1234567</code>。这里用的是 <code>group(1)</code>，它与 <code>group()</code> 有所不同，后者会输出完整的匹配结果，而前者会输出第一个被 <code>()</code> 包围的匹配结果。假如正则表达式后面还有 <code>()</code> 包括的内容，那么可以依次用 <code>group(2)</code>、<code>group(3)</code> 等来获取。</p>
                  <h3 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h3>
                  <p>刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写 <code>\s</code> 匹配，出现数字我们就用 <code>\d</code> 匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是 <code>.*</code>。其中 <code>.</code> 可以匹配任意字符（除换行符），<code>*</code> 代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符匹配了。</p>
                  <p>接着上面的例子，我们可以改写一下正则表达式：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^Hello.*Demo$'</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.span())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们将中间部分直接省略，全部用 <code>.*</code> 来代替，最后加一个结尾字符串就好了。运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">(<span class="number">0</span>, <span class="number">41</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，<code>group</code> 方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容；<code>span</code> 方法输出 <code>(0, 41)</code>，这是整个字符串的长度。</p>
                  <p>因此，我们可以使用 <code>.*</code> 简化正则表达式的书写。</p>
                  <h3 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h3>
                  <p>使用上面的通用匹配 <code>.*</code> 时，可能有时候匹配到的并不是我们想要的结果。看下面的例子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^He.*(\d+).*Demo$'</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们依然想获取中间的数字，所以中间依然写的是 <code>(\d+)</code>。而数字两侧由于内容比较杂乱，所以想省略来写，都写成 <code>.*</code>。最后，组成 <code>^He.*(\d+).*Demo$</code>，看样子并没有什么问题。我们看下运行结果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">40</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">7</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>奇怪的事情发生了，我们只得到了 7 这个数字，这是怎么回事呢？</p>
                  <p>这里就涉及贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。正则表达式中 <code>.*</code> 后面是 <code>\d+</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code> 就尽可能匹配多的字符，这里就把 <code>123456</code> 匹配了，给 <code>\d+</code> 留下一个可满足条件的数字 7，最后得到的内容就只有数字 7 了。</p>
                  <p>但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是 <code>.*?</code>，多了一个 <code>?</code>，那么它可以达到怎样的效果？我们再用实例看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*Demo$'</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们只是将第一个<code>.*</code> 改成了 <code>.*?</code>，转变为非贪婪匹配。结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">40</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">1234567</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此时就可以成功获取 <code>1234567</code> 了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当 <code>.*?</code> 匹配到 <code>Hello</code> 后面的空白字符时，再往后的字符就是数字了，而 <code>\d+</code> 恰好可以匹配，那么这里 <code>.*?</code> 就不再进行匹配，交给 <code>\d+</code> 去匹配后面的数字。所以这样 <code>.*?</code> 匹配了尽可能少的字符，<code>\d+</code> 的结果就是 <code>1234567</code> 了。</p>
                  <p>所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 来代替 <code>.*</code>，以免出现匹配结果缺失的情况。</p>
                  <p>但这里需要注意，如果匹配的结果在字符串结尾，<code>.*?</code> 就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'http://weibo.com/comment/kEraCN'</span></span><br><span class="line">result1 = re.match(<span class="string">'http.*?comment/(.*?)'</span>, content)</span><br><span class="line">result2 = re.match(<span class="string">'http.*?comment/(.*)'</span>, content)</span><br><span class="line">print(<span class="string">'result1'</span>, result1.group(<span class="number">1</span>))</span><br><span class="line">print(<span class="string">'result2'</span>, result2.group(<span class="number">1</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result1</span><br><span class="line">result2 kEraCN</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以观察到，<code>.*?</code> 没有匹配到任何结果，而 <code>.*</code> 则尽量匹配多的内容，成功得到了匹配结果。</p>
                  <h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3>
                  <p>正则表达式可以包含一些可选标志修饰符来控制匹配模式。修饰符被指定为一个可选的标志。我们用实例来看一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*?Demo$'</span>, content)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>和上面的例子相仿，我们在字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">AttributeError Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-18</span>-c7d232b39645&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">      <span class="number">5</span> <span class="string">'''</span></span><br><span class="line"><span class="string">      6 result = re.match('^He.*?(\d+).*?Demo$', content)</span></span><br><span class="line"><span class="string">----&gt; 7 print(result.group(1))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AttributeError: 'NoneType' object has no attribute 'group'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为 <code>None</code>，而我们又调用了 <code>group</code> 方法导致 <code>AttributeError</code>。</p>
                  <p>那么，为什么加了一个换行符，就匹配不到了呢？这是因为。匹配的是除换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致匹配失败。这里只需加一个修饰符 <code>re.S</code>，即可修正这个错误：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*?Demo$'</span>, content, re.S)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个修饰符的作用是使。匹配包括换行符在内的所有字符。此时运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">1234567</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个 <code>re.S</code> 在网页匹配中经常用到。因为 HTML 节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p>
                  <p>另外，还有一些修饰符，在必要的情况下也可以使用，如表 2- 所示。</p>
                  <p>表 2- 修饰符及其描述</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">修饰符</th>
                          <th style="text-align:left">描　　述</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>re.I</code></td>
                          <td style="text-align:left">使匹配对大小写不敏感</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>re.L</code></td>
                          <td style="text-align:left">做本地化识别（locale-aware）匹配</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>re.M</code></td>
                          <td style="text-align:left">多行匹配，影响 <code>^</code> 和 <code>$</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>re.S</code></td>
                          <td style="text-align:left">使。匹配包括换行符在内的所有字符</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>re.U</code></td>
                          <td style="text-align:left">根据 Unicode 字符集解析字符。这个标志影响 <code>\w</code>、<code>\W</code>、<code>\b</code> 和 <code>\B</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>re.X</code></td>
                          <td style="text-align:left">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>在网页匹配中，较为常用的有 <code>re.S</code> 和 <code>re.I</code>。</p>
                  <h3 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h3>
                  <p>我们知道正则表达式定义了许多匹配模式，如 <code>.</code> 匹配除换行符以外的任意字符，但是如果目标字符串里面就包含 <code>.</code>，那该怎么办呢？</p>
                  <p>这里就需要用到转义匹配了，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'(百度) www.baidu.com'</span></span><br><span class="line">result = re.match(<span class="string">'\(百度 \) www\.baidu\.com'</span>, content)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如可以用 <code>\.</code> 来匹配 <code>.</code>，运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">17</span>), match=<span class="string">'(百度) www.baidu.com'</span>&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里成功匹配到了原字符串。</p>
                  <p>这些是写正则表达式常用的几个知识点，熟练掌握它们对后面写正则表达式非常有帮助。</p>
                  <h2 id="3-search"><a href="#3-search" class="headerlink" title="3. search"></a>3. <code>search</code></h2>
                  <p>前面提到过，<code>match</code> 方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了。我们看下面的例子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'</span></span><br><span class="line">result = re.match(<span class="string">'Hello.*?(\d+).*?Demo'</span>, content)</span><br><span class="line">print(result)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里的字符串以 <code>Extra</code> 开头，但是正则表达式以 <code>Hello</code> 开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="literal">None</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>因为 <code>match</code> 方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p>
                  <p>这里就有另外一个方法 <code>search</code>，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时，<code>search</code> 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回 <code>None</code>。</p>
                  <p>我们把上面代码中的 <code>match</code> 方法修改成 <code>search</code>，再看一下运行结果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">13</span>, <span class="number">53</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">1234567</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时就得到了匹配结果。</p>
                  <p>因此，为了匹配方便，我们可以尽量使用 <code>search</code> 方法。</p>
                  <p>下面再用几个实例来看看 <code>search</code> 方法的用法。</p>
                  <p>首先，这里有一段待匹配的 HTML 文本，接下来写几个正则表达式实例来实现相应信息的提取：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">html = '''</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"songs-list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>经典老歌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"introduction"</span>&gt;</span>经典老歌列表<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"2"</span>&gt;</span>一路上有你<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/2.mp3"</span> <span class="attr">singer</span>=<span class="string">"任贤齐"</span>&gt;</span>沧海一声笑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"4"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/3.mp3"</span> <span class="attr">singer</span>=<span class="string">"齐秦"</span>&gt;</span>往事随风<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"6"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/4.mp3"</span> <span class="attr">singer</span>=<span class="string">"beyond"</span>&gt;</span>光辉岁月<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/5.mp3"</span> <span class="attr">singer</span>=<span class="string">"陈慧琳"</span>&gt;</span>记事本<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-view</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/6.mp3"</span> <span class="attr">singer</span>=<span class="string">"邓丽君"</span>&gt;</span>但愿人长久<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">'''</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以观察到，<code>ul</code> 节点里有许多 <code>li</code> 节点，其中 <code>li</code> 节点中有的包含 <code>a</code> 节点，有的不包含 <code>a</code> 节点，<code>a</code> 节点还有一些相应的属性 —— 超链接和歌手名。</p>
                  <p>首先，我们尝试提取 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名，此时需要提取第三个 <code>li</code> 节点下 <code>a</code> 节点的 <code>singer</code> 属性和文本。</p>
                  <p>此时正则表达式可以以 <code>li</code> 开头，然后寻找一个标志符 <code>active</code>，中间的部分可以用 <code>.*?</code> 来匹配。接下来，要提取 <code>singer</code> 这个属性值，所以还需要写入 <code>singer=&quot;(.*?)&quot;</code>，这里需要提取的部分用小括号括起来，以便用 <code>group</code> 方法提取出来，它的两侧边界是双引号。然后还需要匹配 <code>a</code> 节点的文本，其中它的左边界是 <code>&gt;</code>，右边界是 <code>&lt;/a&gt;</code>。然后目标内容依然用 <code>(.*?)</code> 来匹配，所以最后的正则表达式就变成了：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;li.*?active.*?singer&#x3D;&quot;(.*?)&quot;&gt;(.*?)&lt;&#x2F;a&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后再调用 <code>search</code> 方法，它会搜索整个 HTML 文本，找到符合正则表达式的第一个内容返回。</p>
                  <p>另外，由于代码有换行，所以这里第三个参数需要传入 <code>re.S</code>。整个匹配代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = re.search(<span class="string">'&lt;li.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    print(result.group(<span class="number">1</span>), result.group(<span class="number">2</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于需要获取的歌手和歌名都已经用小括号包围，所以可以用 <code>group</code> 方法获取。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">齐秦 往事随风</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这正是 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名。</p>
                  <p>如果正则表达式不加 <code>active</code>（也就是匹配不带 <code>class</code> 为 <code>active</code> 的节点内容），那会怎样呢？我们将正则表达式中的 <code>active</code> 去掉，代码改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = re.search(<span class="string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    print(result.group(<span class="number">1</span>), result.group(<span class="number">2</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于 <code>search</code> 方法会返回第一个符合条件的匹配目标，这里结果就变了：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">任贤齐 沧海一声笑</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>把 <code>active</code> 标签去掉后，从字符串开头开始搜索，此时符合条件的节点就变成了第二个 <code>li</code> 节点，后面的就不再匹配，所以运行结果就变成第二个 <code>li</code> 节点中的内容了。</p>
                  <p>注意，在上面的两次匹配中，<code>search</code> 方法的第三个参数都加了 <code>re.S</code>，这使得 <code>.*?</code> 可以匹配换行，所以含有换行符的 <code>li</code> 节点被匹配到了。如果我们将其去掉，结果会是什么？代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">result = re.search(<span class="string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html)</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">    print(result.group(<span class="number">1</span>), result.group(<span class="number">2</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">beyond 光辉岁月</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，结果变成了第四个 <code>li</code> 节点的内容。这是因为第二个和第三个 <code>li</code> 节点都包含了换行符，去掉 <code>re.S</code> 之后，<code>.*?</code> 已经不能匹配换行符，所以正则表达式不会匹配到第二个和第三个 <code>li</code> 节点，而第四个 <code>li</code> 节点中不包含换行符，所以成功匹配。</p>
                  <p>由于绝大部分的 HTML 文本都包含了换行符，所以尽量都需要加上 <code>re.S</code> 修饰符，以免出现匹配不到的问题。</p>
                  <h2 id="4-findall"><a href="#4-findall" class="headerlink" title="4. findall"></a>4. <code>findall</code></h2>
                  <p>前面我们介绍了 <code>search</code> 方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助 <code>findall</code> 方法了。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p>
                  <p>还是上面的 HTML 文本，如果想获取所有 <code>a</code> 节点的超链接、歌手和歌名，就可以将 <code>search</code> 方法换成 <code>findall</code> 方法。如果有返回结果的话，就是列表类型，所以需要遍历一下来依次获取每组内容。代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = re.findall(<span class="string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)</span><br><span class="line">print(results)</span><br><span class="line">print(type(results))</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(result)</span><br><span class="line">    print(result[<span class="number">0</span>], result[<span class="number">1</span>], result[<span class="number">2</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">[(&#39;&#x2F;2.mp3&#39;, &#39; 任贤齐 &#39;, &#39; 沧海一声笑 &#39;), (&#39;&#x2F;3.mp3&#39;, &#39; 齐秦 &#39;, &#39; 往事随风 &#39;), (&#39;&#x2F;4.mp3&#39;, &#39;beyond&#39;, &#39; 光辉岁月 &#39;), (&#39;&#x2F;5.mp3&#39;, &#39; 陈慧琳 &#39;, &#39; 记事本 &#39;), (&#39;&#x2F;6.mp3&#39;, &#39; 邓丽君 &#39;, &#39; 但愿人长久 &#39;)]</span><br><span class="line">&lt;class &#39;list&#39;&gt;</span><br><span class="line">(&#39;&#x2F;2.mp3&#39;, &#39; 任贤齐 &#39;, &#39; 沧海一声笑 &#39;)</span><br><span class="line">&#x2F;2.mp3 任贤齐 沧海一声笑</span><br><span class="line">(&#39;&#x2F;3.mp3&#39;, &#39; 齐秦 &#39;, &#39; 往事随风 &#39;)</span><br><span class="line">&#x2F;3.mp3 齐秦 往事随风</span><br><span class="line">(&#39;&#x2F;4.mp3&#39;, &#39;beyond&#39;, &#39; 光辉岁月 &#39;)</span><br><span class="line">&#x2F;4.mp3 beyond 光辉岁月</span><br><span class="line">(&#39;&#x2F;5.mp3&#39;, &#39; 陈慧琳 &#39;, &#39; 记事本 &#39;)</span><br><span class="line">&#x2F;5.mp3 陈慧琳 记事本</span><br><span class="line">(&#39;&#x2F;6.mp3&#39;, &#39; 邓丽君 &#39;, &#39; 但愿人长久 &#39;)</span><br><span class="line">&#x2F;6.mp3 邓丽君 但愿人长久</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。</p>
                  <p>如果只是获取第一个内容，可以用 <code>search</code> 方法。当需要提取多个内容时，可以用 <code>findall</code> 方法。</p>
                  <h2 id="5-sub"><a href="#5-sub" class="headerlink" title="5. sub"></a>5. <code>sub</code></h2>
                  <p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的 <code>replace</code> 方法，那就太烦琐了，这时可以借助 <code>sub</code> 方法。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'54aK54yr5oiR54ix5L2g'</span></span><br><span class="line">content = re.sub(<span class="string">'\d+'</span>, <span class="string">''</span>, content)</span><br><span class="line">print(content)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">aKyroiRixLg</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里只需要给第一个参数传入 <code>\d+</code> 来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串。</p>
                  <p>在上面的 HTML 文本中，如果想获取所有 <code>li</code> 节点的歌名，直接用正则表达式来提取可能比较烦琐。比如，可以写成这样子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">results = re.findall(<span class="string">'&lt;li.*?&gt;\s*?(&lt;a.*?&gt;)?(\w+)(&lt;/a&gt;)?\s*?&lt;/li&gt;'</span>, html, re.S)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(result[<span class="number">1</span>])</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">一路上有你</span><br><span class="line">沧海一声笑</span><br><span class="line">往事随风</span><br><span class="line">光辉岁月</span><br><span class="line">记事本</span><br><span class="line">但愿人长久</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>此时借助 <code>sub</code> 方法就比较简单了。可以先用 <code>sub</code> 方法将 <code>a</code> 节点去掉，只留下文本，然后再利用 <code>findall</code> 提取就好了：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">html = re.sub(<span class="string">'&lt;a.*?&gt;|&lt;/a&gt;'</span>, <span class="string">''</span>, html)</span><br><span class="line">print(html)</span><br><span class="line">results = re.findall(<span class="string">'&lt;li.*?&gt;(.*?)&lt;/li&gt;'</span>, html, re.S)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    print(result.strip())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;div id=<span class="string">"songs-list"</span>&gt;</span><br><span class="line">    &lt;h2 class="title"&gt; 经典老歌 &lt;/h2&gt;</span><br><span class="line">    &lt;p class="introduction"&gt;</span><br><span class="line">        经典老歌列表</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;ul id="list" class="list-group"&gt;</span><br><span class="line">        &lt;li data-view="2"&gt; 一路上有你 &lt;/li&gt;</span><br><span class="line">        &lt;li data-view=<span class="string">"7"</span>&gt;</span><br><span class="line">            沧海一声笑</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li data-view="4" class="active"&gt;</span><br><span class="line">            往事随风</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li data-view="6"&gt; 光辉岁月 &lt;/li&gt;</span><br><span class="line">        &lt;li data-view="5"&gt; 记事本 &lt;/li&gt;</span><br><span class="line">        &lt;li data-view=<span class="string">"5"</span>&gt;</span><br><span class="line">            但愿人长久</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">一路上有你</span><br><span class="line">沧海一声笑</span><br><span class="line">往事随风</span><br><span class="line">光辉岁月</span><br><span class="line">记事本</span><br><span class="line">但愿人长久</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，<code>a</code> 节点经过 <code>sub</code> 方法处理后就没有了，然后再通过 <code>findall</code> 方法直接提取即可。可以看到，在适当的时候，借助 <code>sub</code> 方法可以起到事半功倍的效果。</p>
                  <h2 id="6-compile"><a href="#6-compile" class="headerlink" title="6. compile"></a>6. <code>compile</code></h2>
                  <p>前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 <code>compile</code> 方法，这个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">'2019-12-15 12:00'</span></span><br><span class="line">content2 = <span class="string">'2019-12-17 12:55'</span></span><br><span class="line">content3 = <span class="string">'2019-12-22 13:21'</span></span><br><span class="line">pattern = re.compile(<span class="string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)</span><br><span class="line">result1 = re.sub(pattern, <span class="string">''</span>, content1)</span><br><span class="line">result2 = re.sub(pattern, <span class="string">''</span>, content2)</span><br><span class="line">result3 = re.sub(pattern, <span class="string">''</span>, content3)</span><br><span class="line">print(result1, result2, result3)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>例如，这里有 3 个日期，我们想分别将 3 个日期中的时间去掉，这时可以借助 <code>sub</code> 方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写 3 个同样的正则表达式，此时可以借助 <code>compile</code> 方法将正则表达式编译成一个正则表达式对象，以便复用。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-15</span>  <span class="number">2019</span><span class="number">-12</span><span class="number">-17</span>  <span class="number">2019</span><span class="number">-12</span><span class="number">-22</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外，<code>compile</code> 还可以传入修饰符，例如 <code>re.S</code> 等修饰符，这样在 <code>search</code>、<code>findall</code> 等方法中就不需要额外传了。所以，<code>compile</code> 方法可以说是给正则表达式做了一层封装，以便我们更好地复用。</p>
                  <h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2>
                  <p>到此为止，正则表达式的基本用法就介绍完了，后面会通过具体的实例来讲解正则表达式的用法。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/RegexTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/RegexTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-13 07:44:31" itemprop="dateCreated datePublished" datetime="2022-02-13T07:44:31+08:00">2022-02-13</time>
                </span>
                <span id="/202223.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 强大灵活的正则表达式" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>13k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>12 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202215.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202215.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 1.5 代理的基本原理</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>我们在做爬虫的过程中经常会遇到这样的情况，最初爬虫正常运行，正常抓取数据，一切看起来都是那么美好，然而一杯茶的功夫可能就会出现错误，比如 403 Forbidden，这时打开网页一看，可能会看到 “您的 IP 访问频率太高” 这样的提示。出现这种现象的原因是网站采取了一些反爬虫措施。比如，服务器会检测某个 IP 在单位时间内的请求次数，如果超过了这个阈值，就会直接拒绝服务，返回一些错误信息，这种情况可以称为封 IP。</p>
                  <p>既然服务器检测的是某个 IP 单位时间的请求次数，那么借助某种方式来伪装我们的 IP，让服务器识别不出是由我们本机发起的请求，不就可以成功防止封 IP 了吗？</p>
                  <p>一种有效的方式就是使用代理，后面会详细说明代理的用法。在这之前，需要先了解下代理的基本原理，它是怎样实现伪装 IP 的呢？</p>
                  <h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2>
                  <p>代理实际上指的就是代理服务器，英文叫作 Proxy Server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给 Web 服务器，Web 服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向 Web 服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给 Web 服务器，接着由代理服务器再把 Web 服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中 Web 服务器识别出的真实 IP 就不再是我们本机的 IP 了，就成功实现了 IP 伪装，这就是代理的基本原理。</p>
                  <h2 id="2-代理的作用"><a href="#2-代理的作用" class="headerlink" title="2. 代理的作用"></a>2. 代理的作用</h2>
                  <p>那么，代理有什么作用呢？我们可以简单列举如下。</p>
                  <ul>
                    <li>突破自身 IP 访问限制，访问一些平时不能访问的站点。</li>
                    <li>访问一些单位或团体内部资源。比如，使用教育网内地址段的免费代理服务器，就可以下载和上传对教育网开放的各类 FTP，以及查询、共享各类资料等。</li>
                    <li>提高访问速度。通常，代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，会同时将其保存到缓冲区中，而当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
                    <li>隐藏真实 IP。上网者也可以通过这种方法隐藏自己的 IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身的 IP，防止自身的 IP 被封锁。</li>
                  </ul>
                  <h2 id="3-爬虫代理"><a href="#3-爬虫代理" class="headerlink" title="3. 爬虫代理"></a>3. 爬虫代理</h2>
                  <p>对于爬虫来说，由于爬虫爬取速度过快，在爬取过程中可能遇到同一个 IP 访问过于频繁的问题，此时网站就会让我们输入验证码登录或者直接封锁 IP，这样会给爬取带来极大的不便。</p>
                  <p>使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求自己。这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。</p>
                  <h2 id="4-代理分类"><a href="#4-代理分类" class="headerlink" title="4. 代理分类"></a>4. 代理分类</h2>
                  <p>对代理进行分类时，既可以根据协议区分，也可以根据其匿名程度区分，下面总结如下。</p>
                  <h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3>
                  <p>根据代理的协议，代理可以分为如下类别。</p>
                  <ul>
                    <li><strong>FTP 代理服务器</strong>。主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121 等。</li>
                    <li><strong>HTTP 代理服务器</strong>。主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128 等。</li>
                    <li><strong>SSL/TLS 代理</strong>。主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位加密强度），端口一般为 443。</li>
                    <li><strong>RTSP 代理</strong>。主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554。</li>
                    <li><strong>Telnet 代理</strong>。主要用于 Telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23。</li>
                    <li><strong>POP3/SMTP 代理</strong>。主要用于 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25。</li>
                    <li><strong>SOCKS 代理</strong>。只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 协议只支持 TCP，而 SOCKS5 协议支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等。简单来说，SOCKS4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的 SOCKS4 不一定能做到。</li>
                  </ul>
                  <h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3>
                  <p>根据代理的匿名程度，代理可以分为如下类别。</p>
                  <ul>
                    <li><strong>高度匿名代理</strong>：高度匿名代理会将数据包原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的 IP 是代理服务器的 IP。</li>
                    <li><strong>普通匿名代理</strong>：普通匿名代理会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 IP。代理服务器通常会加入的 HTTP 头有 <code>HTTP_VIA</code> 和 <code>HTTP_X_FORWARDED_FOR</code>。</li>
                    <li><strong>透明代理</strong>：透明代理不但改动了数据包，还会告诉服务器客户端的真实 IP。这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li>
                    <li><strong>间谍代理</strong>：间谍代理指组织或个人创建的，用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。</li>
                  </ul>
                  <h2 id="5-常见代理设置"><a href="#5-常见代理设置" class="headerlink" title="5. 常见代理设置"></a>5. 常见代理设置</h2>
                  <p>常见的代理设置如下：</p>
                  <ul>
                    <li>使用网上的免费代理，最好使用高匿代理，使用前抓取下来并筛选一下可用代理，也可以进一步维护一个代理池。</li>
                    <li>使用付费代理服务，互联网上存在许多代理商，可以付费使用，其质量比免费代理好很多。</li>
                    <li>ADSL 拨号，拨一次号换一次 IP，稳定性高，也是一种比较有效的解决方案。</li>
                    <li>蜂窝代理，即用 4G 或 5G 网卡等制作的代理。由于蜂窝网络用作代理的情形较少，因此整体被封锁的几率会较低，但搭建蜂窝代理的成本较高。</li>
                  </ul>
                  <p>在后面，我们会详细介绍一些代理的使用方式。</p>
                  <h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2>
                  <p>本文介绍了代理的相关知识，这对后文我们进行一些反爬绕过的实现有很大的帮助，同时也为后文的一些抓包操作打下基础，需要好好理解。</p>
                  <p>本节由于涉及一些专业名词，本节的部分内容参考来源如下：</p>
                  <ul>
                    <li>文档 - 代理服务器 - 维基百科：<a href="https://github.com/Germey/Python3WebSpider2/tree/3dc0dc1092305e1040f86c4e72a40f627b095897/[https:/zh.wikipedia.org/wiki/%20代理服务器/README.md" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ 代理服务器</a></li>
                    <li>文档 - 代理 - 百度百科：<a href="https://baike.baidu.com/item/%20代理%20/%203242667" target="_blank" rel="noopener">https://baike.baidu.com/item/代理/3242667</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-12 12:42:44" itemprop="dateCreated datePublished" datetime="2022-02-12T12:42:44+08:00">2022-02-12</time>
                </span>
                <span id="/202215.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 1.5 代理的基本原理" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202244.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202244.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 关系型数据库 MySQL 存储</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>关系型数据库是基于关系模型的数据库，而关系模型是通过二维表来保存的，所以它的存储方式就是行列组成的表，每一列是一个字段，每一行是一条记录。表可以看作某个实体的集合，而实体之间存在联系，这就需要表与表之间的关联关系来体现，如主键外键的关联关系。多个表组成一个数据库，也就是关系型数据库。</p>
                  <p>关系型数据库有多种，如 SQLite、MySQL、Oracle、SQL Server、DB2 等，本节我们主要来了解下 MySQL 数据库的存储操作。</p>
                  <p>在 Python 2 中，连接 MySQL 的库大多是使用 MySQLdb，但是此库的官方并不支持 Python 3，所以这里推荐使用的库是 PyMySQL。本节中，我们就来讲解使用 PyMySQL 操作 MySQL 数据库的方法。</p>
                  <h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2>
                  <p>在开始之前，请确保已经安装好了 MySQL 数据库并保证它能正常运行，安装方式可以参考：<a href="https://setup.scrape.center/mysql。" target="_blank" rel="noopener">https://setup.scrape.center/mysql。</a></p>
                  <p>除了安装好 MySQL 数据外，还需要安装好 PyMySQL 库，如尚未安装 PyMySQL，可以使用 pip3 来安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> pymysql</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更详细的安装方式可以参考：<a href="https://setup.scrape.center/pymysql" target="_blank" rel="noopener">https://setup.scrape.center/pymysql</a></p>
                  <p>二者都安装好了之后，我们就可以开始本节的学习了。</p>
                  <h2 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2. 连接数据库"></a>2. 连接数据库</h2>
                  <p>这里首先尝试连接一下数据库。假设当前的 MySQL 运行在本地，用户名为 root，密码为 123456，运行端口为 3306。这里利用 PyMySQL 先连接 MySQL，然后创建一个新的数据库，名字叫作 spiders，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>,user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">'SELECT VERSION()'</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">'Database version:'</span>, data)</span><br><span class="line">cursor.execute(<span class="string">"CREATE DATABASE spiders DEFAULT CHARACTER SET utf8mb4"</span>)</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Database version: (<span class="string">'8.0.19'</span>,)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里通过 PyMySQL 的 <code>connect</code> 方法声明一个 MySQL 连接对象 <code>db</code>，此时需要传入 MySQL 运行的 <code>host</code>（即 IP）。由于 MySQL 在本地运行，所以传入的是 <code>localhost</code>。如果 MySQL 在远程运行，则传入其公网 IP 地址。后续的参数 <code>user</code> 即用户名，<code>password</code> 即密码，<code>port</code> 即端口（默认为 3306）。</p>
                  <p>连接成功后，需要再调用 <code>cursor</code> 方法获得 MySQL 的操作游标，利用游标来执行 SQL 语句。这里我们执行了两句 SQL，直接用 <code>execute</code> 方法执行即可。第一句 SQL 用于获得 MySQL 的当前版本，然后调用 <code>fetchone</code> 方法获得第一条数据，也就得到了版本号。第二句 SQL 执行创建数据库的操作，数据库名叫作 spiders，默认编码为 UTF-8。由于该语句不是查询语句，所以直接执行后就成功创建了数据库 spiders。接着，再利用这个数据库进行后续的操作。</p>
                  <h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2>
                  <p>一般来说，创建数据库的操作只需要执行一次就好了。当然，我们也可以手动创建数据库。以后，我们的操作都在 spiders 数据库上执行。</p>
                  <p>创建数据库后，在连接时需要额外指定一个参数 <code>db</code>。</p>
                  <p>接下来，新创建一个数据表 students，此时执行创建表的 SQL 语句即可。这里指定 3 个字段，结构如表 4- 所示。</p>
                  <p>表 4- 数据表 students</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">字　段　名</th>
                          <th style="text-align:left">含　　义</th>
                          <th style="text-align:left">类　　型</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>id</code></td>
                          <td style="text-align:left">学号</td>
                          <td style="text-align:left"><code>varchar</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>name</code></td>
                          <td style="text-align:left">姓名</td>
                          <td style="text-align:left"><code>varchar</code></td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>age</code></td>
                          <td style="text-align:left">年龄</td>
                          <td style="text-align:left"><code>int</code></td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>创建该表的示例代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>, db=<span class="string">'spiders'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">'CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))'</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行之后，我们便创建了一个名为 students 的数据表。</p>
                  <p>当然，为了演示，这里只指定了最简单的几个字段。实际上，在爬虫过程中，我们会根据爬取结果设计特定的字段。</p>
                  <h2 id="4-插入数据"><a href="#4-插入数据" class="headerlink" title="4. 插入数据"></a>4. 插入数据</h2>
                  <p>下一步就是向数据库中插入数据了。例如，这里爬取了一个学生信息，学号为 20120001，名字为 Bob，年龄为 20，那么如何将该条数据插入数据库呢？示例代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">id = <span class="string">'20120001'</span></span><br><span class="line">user = <span class="string">'Bob'</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>, db=<span class="string">'spiders'</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">'INSERT INTO students(id, name, age) values(%s, %s, %s)'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (id, user, age))</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里首先构造了一个 SQL 语句，其值没有用字符串拼接的方式来构造，如：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sql = <span class="string">'INSERT INTO students(id, name, age) values('</span> + id + <span class="string">', '</span> + name + <span class="string">', '</span> + age + <span class="string">')'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样的写法烦琐而且不直观，所以我们选择直接用格式化符 <code>%s</code> 来实现。有几个 <code>value</code> 写几个 <code>%s</code>，我们只需要在 <code>execute</code> 方法的第一个参数传入该 SQL 语句，<code>value</code> 值用统一的元组传过来就好了。这样的写法既可以避免字符串拼接的麻烦，又可以避免引号冲突的问题。</p>
                  <p>之后值得注意的是，需要执行 <code>db</code> 对象的 <code>commit</code> 方法才可以实现数据插入，这个方法才是真正将语句提交到数据库执行的方法。对于数据插入、更新、删除操作，都需要调用该方法才能生效。</p>
                  <p>接下来，我们加了一层异常处理。如果执行失败，则调用 <code>rollback</code> 执行数据回滚，相当于什么都没有发生过。</p>
                  <p>这里涉及事务的问题。事务机制可以确保数据的一致性，也就是这件事要么发生了，要么没有发生。比如插入一条数据，不会存在插入一半的情况，要么全部插入，要么都不插入，这就是事务的原子性。另外，事务还有 3 个属性 —— 一致性、隔离性和持久性。这 4 个属性通常称为 ACID 特性，具体如表 4- 所示。</p>
                  <p>表 4- 事务的 4 个属性</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">属　　性</th>
                          <th style="text-align:left">解　　释</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left">原子性（atomicity）</td>
                          <td style="text-align:left">事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">一致性（consistency）</td>
                          <td style="text-align:left">事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">隔离性（isolation）</td>
                          <td style="text-align:left">一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">持久性（durability）</td>
                          <td style="text-align:left">持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>插入、更新和删除操作都是对数据库进行更改的操作，而更改操作都必须为一个事务，所以这些操作的标准写法就是：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样便可以保证数据的一致性。这里的 <code>commit</code> 和 <code>rollback</code> 方法就为事务的实现提供了支持。</p>
                  <p>上面数据插入的操作是通过构造 SQL 语句实现的，但是很明显，这有一个极其不方便的地方，比如突然增加了性别字段 <code>gender</code>，此时 SQL 语句就需要改成：</p>
                  <figure class="highlight sql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students(<span class="keyword">id</span>, <span class="keyword">name</span>, age, gender) <span class="keyword">values</span>(%s, %s, %s, %s)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>相应的元组参数则需要改成：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">(id, name, age, gender)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这显然不是我们想要的。在很多情况下，我们要达到的效果是插入方法无须改动，做成一个通用方法，只需要传入一个动态变化的字典就好了。比如，构造这样一个字典：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20120001'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Bob'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后 SQL 语句会根据字典动态构造，元组也动态构造，这样才能实现通用的插入方法。所以，这里我们需要改写一下插入方法：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20120001'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Bob'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">'students'</span></span><br><span class="line">keys = <span class="string">', '</span>.join(data.keys())</span><br><span class="line">values = <span class="string">', '</span>.join([<span class="string">'%s'</span>] * len(data))</span><br><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)'</span>.format(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="keyword">if</span> cursor.execute(sql, tuple(data.values())):</span><br><span class="line">       print(<span class="string">'Successful'</span>)</span><br><span class="line">       db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们传入的数据是字典，并将其定义为 <code>data</code> 变量。表名也定义成变量 <code>table</code>。接下来，就需要构造一个动态的 SQL 语句了。</p>
                  <p>首先，需要构造插入的字段 <code>id</code>、<code>name</code> 和 <code>age</code>。这里只需要将 <code>data</code> 的键名拿过来，然后用逗号分隔即可。所以 <code>&#39;, &#39;.join(data.keys())</code> 的结果就是 <code>id, name, age</code>，然后需要构造多个 <code>%ss</code> 当作占位符，有几个字段构造几个即可。比如，这里有三个字段，就需要构造 <code>%s, %s, %s</code>。这里首先定义了长度为 1 的数组 <code>[&#39;%s&#39;]</code>，然后用乘法将其扩充为 <code>[&#39;%s&#39;, &#39;%s&#39;, &#39;%s&#39;]</code>，再调用 <code>join</code> 方法，最终变成 <code>%s, %s, %s</code>。最后，我们再利用字符串的 <code>format</code> 方法将表名、字段名和占位符构造出来。最终的 SQL 语句就被动态构造成了：</p>
                  <figure class="highlight sql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students(<span class="keyword">id</span>, <span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (%s, %s, %s)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>最后，为 <code>execute</code> 方法的第一个参数传入 <code>sql</code> 变量，第二个参数传入 <code>data</code> 的键值构造的元组，就可以成功插入数据了。</p>
                  <p>如此以来，我们便实现了传入一个字典来插入数据的方法，不需要再去修改 SQL 语句和插入操作了。</p>
                  <h2 id="5-更新数据"><a href="#5-更新数据" class="headerlink" title="5. 更新数据"></a>5. 更新数据</h2>
                  <p>数据更新操作实际上也是执行 SQL 语句，最简单的方式就是构造一个 SQL 语句，然后执行：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sql = <span class="string">'UPDATE students SET age = %ss WHERE name = %s'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   cursor.execute(sql, (<span class="number">25</span>, <span class="string">'Bob'</span>))</span><br><span class="line">   db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">   db.rollback()</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里同样用占位符的方式构造 SQL，然后执行 <code>execute</code> 方法，传入元组形式的参数，同样执行 <code>commit</code> 方法执行操作。如果要做简单的数据更新的话，完全可以使用此方法。</p>
                  <p>但是在实际的数据抓取过程中，大部分情况下需要插入数据，但是我们关心的是会不会出现重复数据，如果出现了，我们希望更新数据而不是重复保存一次。另外，就像前面所说的动态构造 SQL 的问题，所以这里可以再实现一种去重的方法，如果数据存在，则更新数据；如果数据不存在，则插入数据。另外，这种做法支持灵活的字典传值。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20120001'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Bob'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table = <span class="string">'students'</span></span><br><span class="line">keys = <span class="string">', '</span>.join(data.keys())</span><br><span class="line">values = <span class="string">', '</span>.join([<span class="string">'%s'</span>] * len(data))</span><br><span class="line"></span><br><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;) ON DUPLICATE KEY UPDATE '</span>.format(table=table, keys=keys, values=values)</span><br><span class="line">update = <span class="string">','</span>.join([<span class="string">"&#123;key&#125; = %s"</span>.format(key=key) <span class="keyword">for</span> key <span class="keyword">in</span> data])</span><br><span class="line">sql += update</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, tuple(data.values())*<span class="number">2</span>):</span><br><span class="line">        print(<span class="string">'Successful'</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里构造的 SQL 语句其实是插入语句，但是我们在后面加了 <code>ON DUPLICATE KEY UPDATE</code>。这行代码的意思是如果主键已经存在，就执行更新操作。比如，我们传入的数据 <code>id</code> 仍然为 20120001，但是年龄有所变化，由 20 变成了 21，此时这条数据不会被插入，而是直接更新 id 为 20120001 的数据。完整的 SQL 构造出来是这样的：</p>
                  <figure class="highlight sql">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students(<span class="keyword">id</span>, <span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (%s, %s, %s) <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">id</span> = %s, <span class="keyword">name</span> = %s, age = %s</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里就变成了 6 个 <code>%ss</code>。所以在后面的 <code>execute</code> 方法的第二个参数元组就需要乘以 2 变成原来的 2 倍。</p>
                  <p>如此一来，我们就可以实现主键不存在便插入数据，存在则更新数据的功能了。</p>
                  <h2 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6. 删除数据"></a>6. 删除数据</h2>
                  <p>删除操作相对简单，直接使用 <code>DELETE</code> 语句即可，只是需要指定要删除的目标表名和删除条件，而且仍然需要使用 <code>db</code> 的 <code>commit</code> 方法才能生效。示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">table = <span class="string">'students'</span></span><br><span class="line">condition = <span class="string">'age &gt; 20'</span></span><br><span class="line"></span><br><span class="line">sql = <span class="string">'DELETE FROM  &#123;table&#125; WHERE &#123;condition&#125;'</span>.format(table=table, condition=condition)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>因为删除条件多种多样，运算符有大于、小于、等于、<code>LIKE</code> 等，条件连接符有 <code>AND</code>、<code>OR</code> 等，所以不再继续构造复杂的判断条件。这里直接将条件当作字符串来传递，以实现删除操作。</p>
                  <h2 id="7-查询数据"><a href="#7-查询数据" class="headerlink" title="7. 查询数据"></a>7. 查询数据</h2>
                  <p>说完插入、修改和删除等操作，还剩下非常重要的一个操作，那就是查询。查询会用到 <code>SELECT</code> 语句，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    print(<span class="string">'Count:'</span>, cursor.rowcount)</span><br><span class="line">    one = cursor.fetchone()</span><br><span class="line">    print(<span class="string">'One:'</span>, one)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    print(<span class="string">'Results:'</span>, results)</span><br><span class="line">    print(<span class="string">'Results Type:'</span>, type(results))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        print(row)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Count: <span class="number">4</span></span><br><span class="line">One: (<span class="string">'20120001'</span>, <span class="string">'Bob'</span>, <span class="number">25</span>)</span><br><span class="line">Results: ((<span class="string">'20120011'</span>, <span class="string">'Mary'</span>, <span class="number">21</span>), (<span class="string">'20120012'</span>, <span class="string">'Mike'</span>, <span class="number">20</span>), (<span class="string">'20120013'</span>, <span class="string">'James'</span>, <span class="number">22</span>))</span><br><span class="line">Results Type: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'20120011'</span>, <span class="string">'Mary'</span>, <span class="number">21</span>)</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'20120012'</span>, <span class="string">'Mike'</span>, <span class="number">20</span>)</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'20120013'</span>, <span class="string">'James'</span>, <span class="number">22</span>)</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们构造了一条 SQL 语句，将年龄 20 岁及以上的学生查询出来，然后将其传给 <code>execute</code> 方法。注意，这里不再需要 <code>db</code> 的 <code>commit</code> 方法。接着，调用 <code>cursor</code> 的 <code>rowcount</code> 属性获取查询结果的条数，当前示例中是 4 条。</p>
                  <p>然后我们调用了 <code>fetchone</code> 方法，这个方法可以获取结果的第一条数据，返回结果是元组形式，元组的元素顺序跟字段一一对应，即第一个元素就是第一个字段 <code>id</code>，第二个元素就是第二个字段 <code>name</code>，以此类推。随后，我们又调用了 <code>fetchall</code> 方法，它可以得到结果的所有数据。然后将其结果和类型打印出来，它是二重元组，每个元素都是一条记录，我们将其遍历输出出来。</p>
                  <p>但是这里需要注意一个问题，这里显示的是 3 条数据而不是 4 条，<code>fetchall</code> 方法不是获取所有数据吗？这是因为它的内部实现有一个偏移指针用来指向查询结果，最开始偏移指针指向第一条数据，取一次之后，指针偏移到下一条数据，这样再取的话，就会取到下一条数据了。我们最初调用了一次 <code>fetchone</code> 方法，这样结果的偏移指针就指向下一条数据，<code>fetchall</code> 方法返回的是偏移指针指向的数据一直到结束的所有数据，所以该方法获取的结果就只剩 3 个了。</p>
                  <p>此外，我们还可以用 <code>while</code> 循环加 <code>fetchone</code> 方法来获取所有数据，而不是用 <code>fetchall</code> 全部一起获取出来。<code>fetchall</code> 会将结果以元组形式全部返回，如果数据量很大，那么占用的开销会非常高。因此，推荐使用如下方法来逐条取数据：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    print(<span class="string">'Count:'</span>, cursor.rowcount)</span><br><span class="line">    row = cursor.fetchone()</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(<span class="string">'Row:'</span>, row)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样每循环一次，指针就会偏移一条数据，随用随取，简单高效。</p>
                  <h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2>
                  <p>本节我们了解了如何使用 PyMySQL 操作 MySQL 数据库以及一些 SQL 语句的构造方法，后面我们会在实战案例中应用这些操作来存储数据。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/MySQLTest" target="_blank" rel="noopener">https://github.com/Python3WebSpider/MySQLTest</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-12 12:42:44" itemprop="dateCreated datePublished" datetime="2022-02-12T12:42:44+08:00">2022-02-12</time>
                </span>
                <span id="/202244.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 关系型数据库 MySQL 存储" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>7.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>7 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202245.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202245.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 当爬虫遇见 RabbitMQ 消息队列</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>在数据爬取过程中，我们可能需要进行一些任务间通信机制的实现。比如说：</p>
                  <ul>
                    <li>一个进程负责构造爬取请求，另一个进程负责执行爬取请求。</li>
                    <li>某个爬取任务进程完成了，通知另外一个进程进行数据处理。</li>
                    <li>某个进程新建了一个爬取任务，就通知另外一个进程开始数据爬取。</li>
                  </ul>
                  <p>所以，为了降低这些进程的耦合度，就需要一个类似消息队列的中间件来存储和分发这些消息实现进程间的通信。</p>
                  <p>有了消息队列中间件之后，以上的两个任务就可以独立运行，通过消息队列来通信即可：</p>
                  <ul>
                    <li>
                      <p>一个进程将需要爬取的任务构造请求对象放入队列，另一个进程从队列中取出请求对象并执行爬取。</p>
                    </li>
                    <li>
                      <p>某个爬取任务进程完成了，完成时就向消息队列发一个消息，另一个进程监听到这类消息，那就开始数据处理。</p>
                    </li>
                    <li>某个进程新建了一个爬取任务，那就向消息队列发一个消息，另一个负责爬取的进程监听到这类消息，那就开始数据爬取。</li>
                  </ul>
                  <p>那这个消息队列用什么来实现呢？业界比较流行的有 RabbitMQ、RocketMQ、Kafka 等等，RabbitMQ 作为一个开源、可靠、灵活的消息队列中间件倍受青睐，本节我们就来了解下 RabbitMQ 的用法。</p>
                  <blockquote>
                    <p>注意：前面我们了解了一些数据存储库的用法，基本都用于持久化存储一些数据。但本节介绍的是一个消息队列组件，虽然其主要应用于数据消息通信，但由于其也有存储信息的能力，所以将其归类于本章进行介绍。</p>
                  </blockquote>
                  <h2 id="1-RabbitMQ-介绍"><a href="#1-RabbitMQ-介绍" class="headerlink" title="1. RabbitMQ 介绍"></a>1. RabbitMQ 介绍</h2>
                  <p>RabbitMQ 是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议实现。AMQP 的全称是 Advanced Message Queue，即高级消息队列协议，它的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
                  <p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
                  <ul>
                    <li>可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
                    <li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li>
                    <li>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
                    <li>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
                    <li>多种协议支持（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
                    <li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
                    <li>管理界面（Management UI）：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li>
                    <li>跟踪机制（Tracing）：如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
                    <li>插件机制（Plugin System）：RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
                  </ul>
                  <h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2>
                  <p>在本节开始之前，请确保已经正确安装好了 RabbitMQ，安装方式可以参考：<a href="https://setup.scrape.center/rabbitmq，确保其可以在本地正常运行。" target="_blank" rel="noopener">https://setup.scrape.center/rabbitmq，确保其可以在本地正常运行。</a></p>
                  <p>除了安装 RabbitMQ 之外，我们还需要安装一个操作 RabbitMQ 的 Python 库，叫做 pika，使用 pip3 安装即可：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> pika</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>更详细的安装说明可以参考：<a href="https://setup.scrape.center/pika。" target="_blank" rel="noopener">https://setup.scrape.center/pika。</a></p>
                  <p>以上二者都安装好之后，我们就可以开始本节的学习了。</p>
                  <h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h2>
                  <p>首先，RabbitMQ 提供的是队列的功能，我们要实现进程间通信，其本质上就是实现一个生产者-消费者模型，即一个进程作为生产者放入消息，另外一个进程作为消费者监听并处理消息，实现过程主要有 3 个关键点：</p>
                  <ul>
                    <li>声明队列：通过指定队列的一些参数，将队列创建出来。</li>
                    <li>生产内容：生产者根据队列的连接信息连接队列，向队列中放入对应的内容。</li>
                    <li>消费内容：消费者根据队列的连接信息连接队列，从队列中取出对应的内容。</li>
                  </ul>
                  <p>下面我们先来声明一个队列，相关代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于 RabbitMQ 运行在本地，所以这里直接使用 <code>localhost</code> 即可连接 RabbitMQ 服务，得到一个连接对象 <code>connection</code>。接下来我们需要声明一个频道，即 <code>channel</code>，利用它我们可以操作队列内容的生产和消费，接着我们调用 <code>channel</code> 方法的 <code>queue_declare</code> 来声明一个队列，队列名称叫作 <code>scrape</code>。</p>
                  <p>接着我们尝试向队列中添加一个内容：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                      routing_key=QUEUE_NAME,</span><br><span class="line">                      body=<span class="string">'Hello World!'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用了 <code>channel</code> 的 <code>basic_publish</code> 方法，向队列发布了一个内容，其中 <code>routing_key</code> 就是指队列的名称，<code>body</code> 就是真实的内容。</p>
                  <p>以上代码可以写入一个文件，取名为 producer.py，即生产者。</p>
                  <p>现在前两步——声明队列、生产内容其实已经完成了，接下来就是消费者从队列中获取内容了。</p>
                  <p>其实也很简单。消费者用同样的方式连接到队列，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后从队列中获取数据，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">f"Get <span class="subst">&#123;body&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=<span class="string">'scrape'</span>,</span><br><span class="line">                      auto_ack=<span class="literal">True</span>,</span><br><span class="line">                      on_message_callback=callback)</span><br><span class="line">channel.start_consuming()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用了 <code>channel</code> 的 <code>basic_consume</code> 进行消费，同时指定了回调方法 <code>on_message_callback</code> 的名称为 <code>callback</code>，另外还指定了 <code>auto_ack</code> 为 <code>True</code>，这代表消费者获取信息之后会自动通知消息队列，表示这个消息已经被处理了，当前消息可以从队列中移除。</p>
                  <p>最后将以上代码保存为 consumer.py 并运行，它会监听 <code>scrape</code> 这个队列的变动，如果有消息进入，就会获取并进行消费，回调 <code>callback</code> 方法，打印输出结果。</p>
                  <p>然后运行一下 producer.py，运行之后会连接刚才的队列，同时在该队列中加入一条消息，内容为 <code>Hello World!</code>。</p>
                  <p>这时候我们再返回 <code>consumer</code>，可以发现输出如下：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="builtin-name">Get</span> Hello World!</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就说明消费者成功收到了生产者发送的消息，消息成功被生产者放入消息队列，然后被消费者捕获并输出。</p>
                  <p>另外我们再次运行 producer.py，每运行一次，生产者都会向其中放入一个消息，消费者便会收到该消息并输出。</p>
                  <p>以上便是最基本的 RabbitMQ 的用法。</p>
                  <h2 id="4-随用随取"><a href="#4-随用随取" class="headerlink" title="4. 随用随取"></a>4. 随用随取</h2>
                  <p>接下来我们来尝试实现一个简单的爬取队列，即一个进程负责构造爬取请求并将请求放入队列，另一个进程从队列中取出请求并执行爬取。</p>
                  <p>刚才我们仅仅是完成了基于 RabbitMQ 的最简单的生产者和消费者的通信，但是这种实现如果用在爬虫上是不太现实的，因为这里我们把消费者实现为了“订阅”的模式，也就是说，消费者会一直监听队列的变化，一旦队列中有了消息，消费者便要立马进行处理，消费者是无法主动控制它取用消息的时机的。</p>
                  <p>但实际上，假如我们要基于 RabbitMQ 实现一个爬虫的爬取队列的话，RabbitMQ 存的会是待执行/爬取的请求对象，生产者往里面放置请求对象，消费者获取到请求对象之后就执行这个请求，发起 HTTP 请求到服务器获取响应。但发起到获取响应的过程所消耗的时间是消费者无法控制的，这取决于服务器返回时间的长短。因此，消费者并不一定能够很快地将消息处理完，所以，消费者应该也有权利来控制取用的频率，这就是随用随取。</p>
                  <p>所以，这里我们可以稍微对前面的代码进行改写，生产者可以自行控制向消息队列中放入请求对象的频率，消费者也根据自己的处理能力控制自己从队列中取出请求对象的频率。如果生产者放置速度比消费者取用速度更快，那队列中就会缓存一些请求对象，反之队列则有时候会处于闲置状态。</p>
                  <p>但总的来说，消息队列充当了缓冲的作用，使得生产者和消费者可以按照自己的节奏来工作。</p>
                  <p>好，我们先实现下刚才所述的随用随取机制，队列中的消息暂且先用字符串来表示，后面我们可以再将其更换为请求对象。</p>
                  <p>这里我们可以将生产者实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = input()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=QUEUE_NAME,</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f'Put <span class="subst">&#123;data&#125;</span>'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里生产者的数据我们还是使用 input 方法来获取，输入的内容就是字符串，输入之后该内容会直接被放置到队列中，然后打印输出到控制台。</p>
                  <p>先运行下生产者，然后回车输入几个内容：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">foo</span></span><br><span class="line"><span class="symbol">Put</span> foo</span><br><span class="line"><span class="keyword">bar</span></span><br><span class="line"><span class="keyword">Put </span><span class="keyword">bar</span></span><br><span class="line"><span class="keyword">baz</span></span><br><span class="line"><span class="keyword">Put </span><span class="keyword">baz</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们输入了 foo、bar、baz 三个内容，然后控制台也有对应的输出结果。</p>
                  <p>然后消费者实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    input()</span><br><span class="line">    method_frame, header, body = channel.basic_get(</span><br><span class="line">        queue=QUEUE_NAME, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        print(<span class="string">f'Get <span class="subst">&#123;body&#125;</span>'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>消费者也是一样的，我们这里也是可以通过 input 方法控制何时取用下一个，获取的方法就是 basic_get ，返回一个元组，其中 body 就是真正的数据。</p>
                  <p>运行消费者，回车几下，就可以看到每次回车都可以看到从消息队列中获取了一个新的数据：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="builtin-name">Get</span> b<span class="string">'foo'</span></span><br><span class="line"><span class="builtin-name">Get</span> b<span class="string">'bar'</span></span><br><span class="line"><span class="builtin-name">Get</span> b<span class="string">'baz'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以实现消费者的随用随取了。</p>
                  <h2 id="5-优先级队列"><a href="#5-优先级队列" class="headerlink" title="5. 优先级队列"></a>5. 优先级队列</h2>
                  <p>刚才我们仅仅是了解了最基本的队列的用法，RabbitMQ 还有一些高级功能。比如说，如果我们要想生产者发送的消息有优先级的区分，希望高优先级的队列被优先接收到，这个怎么实现呢？</p>
                  <p>其实很简单，我们只需要在声明队列的时候增加一个属性即可：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, arguments=&#123;</span><br><span class="line">    <span class="string">'x-max-priority'</span>: MAX_PRIORITY</span><br><span class="line">&#125;)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里在声明队列的时候，我们增加了一个参数，叫做 x-max-priority，指定一个最大优先级，这样整个队列就支持优先级了。</p>
                  <p>这里改写下生产者，在发送消息的时候指定一个 properties 参数为 BasicProperties 对象，BasicProperties 对象里面通过 priority 参数指定了对应消息的优先级，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, arguments=&#123;</span><br><span class="line">    <span class="string">'x-max-priority'</span>: MAX_PRIORITY</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, priority = input().split()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(</span><br><span class="line">                              priority=int(priority),</span><br><span class="line">                          ),</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f'Put <span class="subst">&#123;data&#125;</span>'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里优先级我们也可以手动输入，输入的内容我们需要分为两部分，用空格隔开，运行结果如下：</p>
                  <figure class="highlight properties">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attr">foo</span> <span class="string">40</span></span><br><span class="line"><span class="attr">Put</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">bar</span> <span class="string">20</span></span><br><span class="line"><span class="attr">Put</span> <span class="string">bar</span></span><br><span class="line"><span class="attr">baz</span> <span class="string">50</span></span><br><span class="line"><span class="attr">Put</span> <span class="string">baz</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们输入了三次内容，比如第一次输入的就是 <code>foo 40</code>，代表 foo 这个消息的优先级是 40，然后输入 bar 这个消息，优先级是 20，最后输入 baz 这个消息，优先级是 50。</p>
                  <p>然后重新运行消费者，按几次回车，可以看到如下输出结果：</p>
                  <figure class="highlight routeros">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="builtin-name">Get</span> b<span class="string">'baz'</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">Get</span> b<span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">Get</span> b<span class="string">'bar'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们可以看到结果就按照优先级取出来了，baz 这个优先级是最高的，所以就被最先取出来。bar 这个优先级是最低的，所以被最后取出来。</p>
                  <h2 id="6-队列持久化"><a href="#6-队列持久化" class="headerlink" title="6. 队列持久化"></a>6. 队列持久化</h2>
                  <p>除了设置优先级，我们还可以队列的持久化存储，如果不设置持久化存储，RabbitMQ 重启之后数据就没有了。</p>
                  <p>如果要开启持久化存储，可以在声明队列时指定 durable 为 True，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">channel.queue_declare(queue=QUEUE_NAME, arguments=&#123;</span><br><span class="line">    <span class="string">'x-max-priority'</span>: MAX_PRIORITY</span><br><span class="line">&#125;, durable=<span class="literal">True</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>同时在添加消息的时候需要指定 BasicProperties 对象的 delivery_mode 为 2，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">properties=pika.BasicProperties(priority=int(priority), delivery_mode=<span class="number">2</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>所以，这时候生产者的写法就改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape'</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, arguments=&#123;</span><br><span class="line">    <span class="string">'x-max-priority'</span>: MAX_PRIORITY</span><br><span class="line">&#125;, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, priority = input().split()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(</span><br><span class="line">                              priority=int(priority),</span><br><span class="line">                              delivery_mode=<span class="number">2</span>,</span><br><span class="line">                          ),</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f'Put <span class="subst">&#123;data&#125;</span>'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以实现队列的持久化存储了。</p>
                  <h2 id="7-实战"><a href="#7-实战" class="headerlink" title="7. 实战"></a>7. 实战</h2>
                  <p>最后，我们将消息改写成前面所描述的请求对象，这里我们借助于 requests 库中的 Request 类来表示一个请求对象。</p>
                  <p>构造请求对象时，我们传入请求方法、请求 URL 即可，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">request = requests.Request(<span class="string">'GET'</span>, url)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就构造了一个 GET 请求，然后可以通过 pickle 进行序列化然后发送到 RabbitMQ 中。</p>
                  <p>生产者实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">TOTAL = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape_queue'</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, TOTAL + <span class="number">1</span>):</span><br><span class="line">    url = <span class="string">f'https://ssr1.scrape.center/detail/<span class="subst">&#123;i&#125;</span>'</span></span><br><span class="line">    request = requests.Request(<span class="string">'GET'</span>, url)</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(</span><br><span class="line">                              delivery_mode=<span class="number">2</span>,</span><br><span class="line">                          ),</span><br><span class="line">                          body=pickle.dumps(request))</span><br><span class="line">    print(<span class="string">f'Put request of <span class="subst">&#123;url&#125;</span>'</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们运行下生产者，就构造了 100 个请求对象并发送到 RabbitMQ 中了。</p>
                  <p>对于消费者来说，可以设置一个循环，一直不断地从队列中取出这些请求对象，取出一个就执行一次爬取，实现如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">'scrape_queue'</span></span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = session.send(request.prepare())</span><br><span class="line">        print(<span class="string">f'success scraped <span class="subst">&#123;response.url&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        print(<span class="string">f'error occurred when scraping <span class="subst">&#123;request.url&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    method_frame, header, body = channel.basic_get(</span><br><span class="line">        queue=QUEUE_NAME, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        request = pickle.loads(body)</span><br><span class="line">        print(<span class="string">f'Get <span class="subst">&#123;request&#125;</span>'</span>)</span><br><span class="line">        scrape(request)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里消费者调用 basic_get 方法获取了消息，然后通过 pickle 反序列化还原成一个请求对象，然后使用 session 的 send 方法执行了该请求，进行了数据爬取，爬取成功就打印爬取成功的消息。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Get &lt;Request [GET]&gt;</span><br><span class="line">success scraped https://ssr1.scrape.center/detail/<span class="number">1</span></span><br><span class="line">Get &lt;Request [GET]&gt;</span><br><span class="line">success scraped https://ssr1.scrape.center/detail/<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">Get  &lt;Request [GET]&gt;</span><br><span class="line">success scraped https://ssr1.scrape.center/detail/<span class="number">100</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，消费者依次取出了爬取对象，然后成功完成了一个个爬取任务。</p>
                  <h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2>
                  <p>本节介绍了 RabbitMQ 的基本使用方法，有了它，爬虫任务间的消息通信就变得非常简单了，另外后文我们还会基于 RabbitMQ 实现分布式的爬取实战，所以本节的内容需要好好掌握。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/RabbitMQTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/RabbitMQTest。</a></p>
                  <p>本节部分内容参考来源：</p>
                  <ul>
                    <li>文档 - RabbitMQ：<a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">https://www.rabbitmq.com/documentation.html</a></li>
                    <li>文档 - Pika：<a href="https://pika.readthedocs.io/" target="_blank" rel="noopener">https://pika.readthedocs.io/</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-12 12:42:44" itemprop="dateCreated datePublished" datetime="2022-02-12T12:42:44+08:00">2022-02-12</time>
                </span>
                <span id="/202245.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 当爬虫遇见 RabbitMQ 消息队列" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>9.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>8 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202214.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202214.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - Session 和 Cookie</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>在浏览网站的过程中，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。还有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是为什么？其实这里面涉及 Session 和 Cookie 的相关知识，本节就来揭开它们的神秘面纱。</p>
                  <h2 id="1-静态网页和动态网页"><a href="#1-静态网页和动态网页" class="headerlink" title="1. 静态网页和动态网页"></a>1. 静态网页和动态网页</h2>
                  <p>在开始之前，我们需要先了解一下静态网页和动态网页的概念。这里还是前面的示例代码，内容如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这是最基本的 HTML 代码，我们将其保存为一个 test.html 文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx 等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p>
                  <p>这种网页的内容是 HTML 代码编写的，文字、图片等内容均通过写好的 HTML 代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL 灵活多变地显示内容等。例如，我们想要给这个网页的 URL 传入一个 <code>name</code> 参数，让其在网页中显示出来，是无法做到的。</p>
                  <p>因此，动态网页应运而生，它可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python 等语言编写的，其功能比静态网页强大、丰富太多了。此外，动态网站还可以实现用户登录和注册的功能。</p>
                  <p>再回到开头提到的问题，很多页面是需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，我们才能保持登录状态，访问登录之后才能看到的页面。</p>
                  <p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session 和 Cookie 共同产生的结果，下面我们来一探究竟。</p>
                  <h2 id="2-无状态-HTTP"><a href="#2-无状态-HTTP" class="headerlink" title="2. 无状态 HTTP"></a>2. 无状态 HTTP</h2>
                  <p>在了解 Session 和 Cookie 之前，我们还需要了解 HTTP 的一个特点，叫作无状态。</p>
                  <p>HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。这意味着如果后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p>
                  <p>这时两个用于保持 HTTP 连接状态的技术就出现了，它们分别是 Session 和 Cookie。Session 在服务端，也就是网站的服务器，用来保存用户的 Session 信息；Cookie 在客户端，也可以理解为浏览器端，有了 Cookie，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookie 并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</p>
                  <p>我们可以理解为 Cookie 里面保存了登录的凭证，有了它，只需要在下次请求携带 Cookie 发送请求而不必重新输入用户名、密码等信息重新登录了。</p>
                  <p>因此，在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的 Cookie 放在请求头里面直接请求，而不必重新模拟登录。</p>
                  <p>好了，了解 Session 和 Cookie 的概念之后，我们在来详细剖析它们的原理。</p>
                  <h2 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h2>
                  <p>Session，中文称为会话，其本来的含义是指有始有终的一系列动作 / 消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 Session。</p>
                  <p>而在 Web 中，Session 对象用来存储特定用户 Session 所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户 Session 中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session 对象。当 Session 过期或被放弃后，服务器将终止该 Session。</p>
                  <h2 id="4-Cookie"><a href="#4-Cookie" class="headerlink" title="4. Cookie"></a>4. Cookie</h2>
                  <p>Cookie，也常用其复数形式 Cookies，Cookie 指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据。</p>
                  <h4 id="Session-维持"><a href="#Session-维持" class="headerlink" title="Session 维持"></a>Session 维持</h4>
                  <p>那么，我们怎样利用 Cookies 保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。当浏览器下一次再请求该网站时，浏览器会把此 Cookies 放到请求头一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session 是什么，然后再判断 Session 来辨认用户状态。</p>
                  <p>在成功登录某个网站时，服务器会告诉客户端设置哪些 Cookies 信息。在后续访问页面时，客户端会把 Cookies 发送给服务器，服务器再找到对应的 Session 加以判断。如果 Session 中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p>
                  <p>反之，如果传给服务器的 Cookies 是无效的，或者 Session 已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。</p>
                  <p>所以，Cookies 和 Session 需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session 控制。</p>
                  <h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4>
                  <p>接下来，我们来看看 Cookies 都有哪些内容。这里以知乎为例，在浏览器开发者工具中打开 Application 选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/5yb6e.jpg" alt=""></p>
                  <p>Cookies 列表</p>
                  <p>可以看到，这里有很多条目，其中每个条目可以称为 Cookie。它有如下几个属性。</p>
                  <ul>
                    <li>Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改。</li>
                    <li>Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li>
                    <li>Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com 结尾的域名都可以访问该 Cookie。</li>
                    <li>Path，即该 Cookie 的使用路径。如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。如果设置为 /，则本域名下的所有页面都可以访问该 Cookie。</li>
                    <li>Max-Age，即该 Cookie 失效的时间，单位为秒，常和 Expires 一起使用，通过它可以计算出其有效时间。Max-Age 如果为正数，则该 Cookie 在 Max-Age 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</li>
                    <li>Size 字段，即此 Cookie 的大小。</li>
                    <li>HTTP 字段，即 Cookie 的 <code>httponly</code> 属性。若此属性为 <code>true</code>，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 <code>document.cookie</code> 来访问此 Cookie。</li>
                    <li>Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议有 HTTPS 和 SSL 等，在网络上传输数据之前先将数据加密。其默认值为 <code>false</code>。</li>
                  </ul>
                  <h4 id="会话-Cookie-和持久-Cookie"><a href="#会话-Cookie-和持久-Cookie" class="headerlink" title="会话 Cookie 和持久 Cookie"></a>会话 Cookie 和持久 Cookie</h4>
                  <p>从表面意思来说，会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效；持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p>
                  <p>其实严格来说，没有会话 Cookie 和持久 Cookie 之分，只是由 Cookie 的 Max-Age 或 Expires 字段决定了过期的时间。</p>
                  <p>因此，一些持久化登录的网站其实就是把 Cookie 的有效时间和 Session 有效期设置得比较长，下次我们再访问页面时仍然携带之前的 Cookie，就可以直接保持登录状态。</p>
                  <h2 id="5-常见误区"><a href="#5-常见误区" class="headerlink" title="5. 常见误区"></a>5. 常见误区</h2>
                  <p>在谈论 Session 机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，Session 就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对 Session 来说，也一样，除非程序通知服务器删除一个 Session，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除 Session。</p>
                  <p>但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session 了。如果服务器设置的 Cookies 保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器，仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。</p>
                  <p>而且恰恰是由于关闭浏览器不会导致 Session 被删除，这就需要服务器为 Session 设置一个失效时间，当距离客户端上一次使用 Session 的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把 Session 删除以节省存储空间。</p>
                  <h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2>
                  <p>本节介绍了 Session 和 Cookie 的基本概念，这对后文进行网络爬虫的开发有很大的帮助，需要好好掌握。</p>
                  <p>由于涉及一些专业名词知识，本节部分内容的参考来源如下：</p>
                  <ul>
                    <li>文档 - Session - 百度百科：<a href="https://baike.baidu.com/item/session/479100" target="_blank" rel="noopener">https://baike.baidu.com/item/session/479100</a></li>
                    <li>文档 - Cookie - 百度百科：<a href="https://baike.baidu.com/item/cookie/1119" target="_blank" rel="noopener">https://baike.baidu.com/item/cookie/1119</a></li>
                    <li>文档 - HTTP Cookie 维基百科：<a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTTP_cookie</a></li>
                    <li>博客 - Session 和几种状态保持方案理解：<a href="http://www.mamicode.com/info-detail-46545.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-46545.html</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-12 09:38:31" itemprop="dateCreated datePublished" datetime="2022-02-12T09:38:31+08:00">2022-02-12</time>
                </span>
                <span id="/202214.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - Session 和 Cookie" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>4.8k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>4 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202211.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202211.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - 爬虫是什么？</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>简而言之，爬虫可以帮助我们快速把网站上的信息快速提取并保存下来。</p>
                  <p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，就能把网页上的信息提取出来。我们可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>
                  <h2 id="1-爬虫有什么用？"><a href="#1-爬虫有什么用？" class="headerlink" title="1. 爬虫有什么用？"></a>1. 爬虫有什么用？</h2>
                  <p>通过上面的话，你可能已经初步知道了爬虫是做了什么事情，但一般要学一个东西，我们得知道学来干什么用吧？</p>
                  <p>其实，爬虫的用处可大了去了。</p>
                  <ul>
                    <li>比如，我们想要研究最近各大网站头条都有什么热点，那我们就可以用爬虫把这些网站的热门新闻用爬虫爬下来，这样我们就可以分析其中的标题、内容等知道热点关键词了。</li>
                    <li>比如，我们想要对一些天气、金融、体育、公司等各种信息进行整理和分析，但这些内容都分布在各种不同的网站上，那我们就可以用爬虫把这些网站上的数据爬取下来，整理成我们想要的数据保存下来，就可以对其进行分析了。</li>
                    <li>比如，我们在网上看到了很多美图，比如风景、美食、美女，或者一些资料、文章，想保存到电脑上，但一次次右键保存、复制粘贴显然非常费时费力，那我们就可以利用爬虫将这些图片或资源快速爬取下来，极大地节省时间和精力。</li>
                  </ul>
                  <p>另外还有很多其他的，比如黄牛抢票、自助抢课、网站排名等等各种技术也都和爬虫分不开，爬虫的用处可谓是非常大，可以说人人都应该会点爬虫。</p>
                  <p>另外学爬虫还可以帮助我们顺便学好 Python。学爬虫，个人首推的就是 Python 语言，如果你对 Python 还不太熟，没关系，爬虫就非常适合作为入门 Python 的方向来学习，一边学爬虫，一边学 Python，最后一举两得。</p>
                  <p>不仅如此，爬虫技术和其他领域的几乎都有交集，比如前后端 Web 开发、数据库、数据分析、人工智能、运维、安全等等领域都和爬虫有所沾边，所以学好了爬虫，就相当于为其他的领域也铺好了一个台阶，以后想进军其他领域都可以更轻松地衔接。Python 爬虫可谓是学习计算机的一个很好的入门方向之一。</p>
                  <h2 id="2-爬虫的流程"><a href="#2-爬虫的流程" class="headerlink" title="2. 爬虫的流程"></a>2. 爬虫的流程</h2>
                  <p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，下面概要介绍一下。</p>
                  <h3 id="1-获取网页"><a href="#1-获取网页" class="headerlink" title="(1) 获取网页"></a>(1) 获取网页</h3>
                  <p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p>
                  <p>我们用浏览器浏览网页时，其实浏览器就帮我们模拟了这个过程，浏览器向服务器发送了一个个请求，返回的响应体便是网页源代码，然后浏览器将其解析并呈现出来。所以，我们要做的爬虫其实就和浏览器类似，将网页源代码获取下来之后将内容解析出来就好了，只不过我们用的不是浏览器，而是 Python。</p>
                  <p>刚才说，最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样用 Python 实现呢？</p>
                  <p>Python 提供了许多库来帮助我们实现这个操作，如 urllib、requests 等。我们可以用这些库来实现 HTTP 请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的 <code>body</code> 部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。</p>
                  <h3 id="2-提取信息"><a href="#2-提取信息" class="headerlink" title="(2) 提取信息"></a>(2) 提取信息</h3>
                  <p>获取网页的源代码后，接下来就是分析网页的源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p>
                  <p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS 选择器或 XPath 来提取网页信息的库，如 Beautiful Soup、pyquery、lxml 等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p>
                  <p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理、清晰，以便我们后续处理和分析数据。</p>
                  <h3 id="3-保存数据"><a href="#3-保存数据" class="headerlink" title="(3) 保存数据"></a>(3) 保存数据</h3>
                  <p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为 TXT 文本或 JSON 文本，也可以保存到数据库，如 MySQL 和 MongoDB 等，还可保存至远程服务器，如借助 SFTP 进行操作等。</p>
                  <h3 id="4-自动化程序"><a href="#4-自动化程序" class="headerlink" title="(4) 自动化程序"></a>(4) 自动化程序</h3>
                  <p>说到自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>
                  <h2 id="3-能爬怎样的数据？"><a href="#3-能爬怎样的数据？" class="headerlink" title="3. 能爬怎样的数据？"></a>3. 能爬怎样的数据？</h2>
                  <p>在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML 代码，而最常抓取的便是 HTML 源代码。</p>
                  <p>另外，可能有些网页返回的不是 HTML 代码，而是一个 JSON 字符串（其中 API 接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p>
                  <p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p>
                  <p>另外，还可以看到各种扩展名的文件，如 CSS、JavaScript 和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p>
                  <p>上述内容其实都对应各自的 URL，是基于 HTTP 或 HTTPS 协议的，只要是这种数据，爬虫都可以抓取。</p>
                  <h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2>
                  <p>本节结束，我们已经对爬虫有了基本的了解，接下来让我们一起接着迈入爬虫学习的世界吧！</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-12 08:38:31" itemprop="dateCreated datePublished" datetime="2022-02-12T08:38:31+08:00">2022-02-12</time>
                </span>
                <span id="/202211.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - 爬虫是什么？" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202213.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202213.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - Web网页基础</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>爬虫系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>用浏览器访问网站时，页面各不相同，你有没有想过它为何会呈现这个样子呢？本节中，我们就来了解一下网页的组成、结构和节点等内容。</p>
                  <h2 id="1-网页的组成"><a href="#1-网页的组成" class="headerlink" title="1. 网页的组成"></a>1. 网页的组成</h2>
                  <p>网页可以分为三大部分 —— HTML、CSS 和 JavaScript。如果把网页比作一个人的话，HTML 相当于骨架，JavaScript 相当于肌肉，CSS 相当于皮肤，三者结合起来才能形成一个完善的网页。下面我们分别来介绍一下这三部分的功能。</p>
                  <h3 id="（1）HTML"><a href="#（1）HTML" class="headerlink" title="（1）HTML"></a>（1）HTML</h3>
                  <p>HTML，其英文叫做 HyperText Markup Language，中文翻译叫做超文本标记语言，但我们通常不会用中文翻译来称呼它，一般就叫 HTML。</p>
                  <p>HTML 是用来描述网页的一种语言，网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是 HTML。不同类型的元素通过不同类型的标签来表示，如图片用 <code>img</code> 标签表示，视频用 <code>video</code> 标签表示，段落用 <code>p</code> 标签表示，它们之间的布局又常通过布局标签 <code>div</code> 嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p>
                  <p>那 HTML 长什么样子呢？我们可以随意打开一个网站，比如淘宝 <a href="https://www.taobao.com，然后右键菜单点击“检查元素”或者按" target="_blank" rel="noopener">https://www.taobao.com，然后右键菜单点击“检查元素”或者按</a> F12 快捷键，即可打开浏览器开发者工具，切换到 Elements 面板，这时候就可以看到这里呈现的就是淘宝网对应的 HTML，它包含了一系列标签，浏览器解析这些标签后，便会在网页中渲染成一个个的节点，这便形成了我们平常看到的网页。比如这里可以看到一个输入框就对应一个 input 标签，可以用于输入文字。</p>
                  <p><img src="https://cdn.cuiqingcai.com/jq4ak.png" alt=""></p>
                  <p>不同的标签对应着不同的功能，这些标签定义的节点相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p>
                  <h3 id="（2）CSS"><a href="#（2）CSS" class="headerlink" title="（2）CSS"></a>（2）CSS</h3>
                  <p>HTML 定义了网页的结构，但是只有 HTML 页面的布局并不美观，可能只是简单的节点元素的排列。为了让网页看起来更好看一些，这里借助了 CSS。</p>
                  <p>CSS，全称叫作 Cascading Style Sheets，即层叠样式表。“层叠” 是指当在 HTML 中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式” 指网页中文字大小、颜色、元素间距、排列等格式。CSS 是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p>
                  <p>在上图中，Styles 面板呈现的就是一系列 CSS 样式，比如摘抄一段 CSS，内容如下：</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-id">#head_wrapper</span><span class="selector-class">.s-ps-islite</span> <span class="selector-class">.s-p-top</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">181px</span>;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是一个 CSS 样式。大括号前面是一个 CSS 选择器。此选择器的意思是首先选中 <code>id</code> 为 <code>head_wrapper</code> 且 <code>class</code> 为 <code>s-ps-islite</code> 的节点，然后再选中其内部的 <code>class</code> 为 <code>s-p-top</code> 的节点。大括号内部写的就是一条条样式规则，例如 <code>position</code> 指定了这个节点的布局方式为绝对布局，<code>bottom</code> 指定节点的下边距为 40 像素，<code>width</code> 指定了宽度为 100%，表示占满父节点，height 则指定了节点的高度。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上 CSS 选择器，这就代表这个样式对 CSS 选择器选中的节点生效，节点就会根据此样式来展示了。</p>
                  <p>在网页中，一般会统一定义整个网页的样式规则，并写入 CSS 文件中（其后缀为 css）。在 HTML 中，只需要用 <code>link</code> 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观、优雅。</p>
                  <h3 id="（3）JavaScript"><a href="#（3）JavaScript" class="headerlink" title="（3）JavaScript"></a>（3）JavaScript</h3>
                  <p>JavaScript，简称 JS，是一种脚本语言。HTML 和 CSS 配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是 JavaScript 的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。</p>
                  <p>JavaScript 通常也是以单独的文件形式加载的，后缀为 js，在 HTML 中通过 <code>script</code> 标签即可引入，例如：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&lt;script src&#x3D;&quot;jquery-2.1.0.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>综上所述，HTML 定义了网页的内容和结构，CSS 描述了网页的样式，JavaScript 定义了网页的行为。</p>
                  <h2 id="2-网页的结构"><a href="#2-网页的结构" class="headerlink" title="2. 网页的结构"></a>2. 网页的结构</h2>
                  <p>我们首先用例子来感受一下 HTML 的基本结构。新建一个文本文件，名称叫做 test.html，内容如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是一个最简单的 HTML 实例。开头用 <code>DOCTYPE</code> 定义了文档类型，其次最外层是 <code>html</code> 标签，最后还有对应的结束标签来表示闭合，其内部是 <code>head</code> 标签和 <code>body</code> 标签，分别代表网页头和网页体，它们也需要结束标签。<code>head</code> 标签内定义了一些页面的配置和引用，如：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>它指定了网页的编码为 UTF-8。</p>
                  <p><code>title</code> 标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。<code>body</code> 标签内则是在网页正文中显示的内容。<code>div</code> 标签定义了网页中的区块，它的 <code>id</code> 是 <code>container</code>，这是一个非常常用的属性，且 <code>id</code> 的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个 <code>div</code> 标签，它的 <code>class</code> 为 <code>wrapper</code>，这也是一个非常常用的属性，经常与 CSS 配合使用来设定样式。然后此区块内部又有一个 <code>h2</code> 标签，这代表一个二级标题。另外，还有一个 <code>p</code> 标签，这代表一个段落。在这两者中直接写入相应的内容即可在网页中呈现出来，它们也有各自的 <code>class</code> 属性。</p>
                  <p>将代码保存后，双击该文件在浏览器中打开，可以看到如图所示的内容。</p>
                  <p><img src="https://cdn.cuiqingcai.com/wi3k2.png" alt="运行结果"></p>
                  <p>可以看到，选项卡上显示了 This is a Demo 字样，这是我们在 <code>head</code> 中的 <code>title</code> 里定义的文字。而网页正文是 <code>body</code> 标签内部定义的各个元素生成的，可以看到这里显示了二级标题和段落。</p>
                  <p>这个实例便是网页的一般结构。一个网页的标准形式是 <code>html</code> 标签内嵌套 <code>head</code> 和 <code>body</code> 标签，<code>head</code> 内定义网页的配置和引用，<code>body</code> 内定义网页的正文。</p>
                  <h2 id="3-节点树及节点间的关系"><a href="#3-节点树及节点间的关系" class="headerlink" title="3 节点树及节点间的关系"></a>3 节点树及节点间的关系</h2>
                  <p>在 HTML 中，所有标签定义的内容都是节点，它们构成了一个 HTML 节点树，也称之为 HTML DOM 树。</p>
                  <p>我们先看下什么是 DOM。DOM 是 W3C（万维网联盟）的标准，其英文全称 Document Object Model，即文档对象模型。它定义了访问 HTML 和 XML 文档的标准。根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点。</p>
                  <ul>
                    <li>整个网站文档是一个文档节点。</li>
                    <li>每个 html 标签对应一个根元素节点，即上例中的 html 标签，这属于一个跟元素节点。</li>
                    <li>节点内的文本是文本节点，比如 a 节点代表一个超链接，它内部的文本也被认为是一个文本节点。</li>
                    <li>每个节点的属性是属性节点，比如 a 节点有一个 href 属性，它就是一个属性节点。</li>
                    <li>注释是注释节点，在 HTML 中有特殊的语法会被解析为注释，但其也会对应一个节点。</li>
                  </ul>
                  <p>所以，HTML DOM 将 HTML 文档视作树结构，这种结构被称为节点树，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/5fe0q.jpg" alt="节点树"></p>
                  <p>通过 HTML DOM，树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可以被创建或删除。</p>
                  <p>节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。</p>
                  <p>在节点树中，顶端节点称为根（root）。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。图展示了节点树以及节点之间的关系。</p>
                  <p><img src="https://cdn.cuiqingcai.com/muz4m.jpg" alt="节点树及节点间的关系"></p>
                  <h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4. 选择器"></a>4. 选择器</h2>
                  <p>我们知道网页由一个个节点组成，CSS 选择器会根据不同的节点设置不同的样式规则，那么怎样来定位节点呢？</p>
                  <p>在 CSS 中，我们使用 CSS 选择器来定位节点。例如，上例中 <code>div</code> 节点的 <code>id</code> 为 <code>container</code>，那么就可以表示为 <code>#container</code>，其中 <code>#</code> 开头代表选择 <code>id</code>，其后紧跟 <code>id</code> 的名称。另外，如果我们想选择 <code>class</code> 为 <code>wrapper</code> 的节点，便可以使用<code>.wrapper</code>，这里以点（.）开头代表选择 <code>class</code>，其后紧跟 <code>class</code> 的名称。另外，还有一种选择方式，那就是根据标签名筛选，例如想选择二级标题，直接用 <code>h2</code> 即可。这是最常用的 3 种表示，分别是根据 <code>id</code>、<code>class</code>、标签名筛选，请牢记它们的写法。</p>
                  <p>另外，CSS 选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如 <code>#container .wrapper p</code> 则代表先选择 <code>id</code> 为 <code>container</code> 的节点，然后选中其内部的 <code>class</code> 为 <code>wrapper</code> 的节点，然后再进一步选中其内部的 <code>p</code> 节点。另外，如果不加空格，则代表并列关系，如 <code>div#container .wrapper p.text</code> 代表先选择 <code>id</code> 为 <code>container</code> 的 <code>div</code> 节点，然后选中其内部的 <code>class</code> 为 <code>wrapper</code> 的节点，再进一步选中其内部的 <code>class</code> 为 <code>text</code> 的 <code>p</code> 节点。这就是 CSS 选择器，其筛选功能还是非常强大的。</p>
                  <p>我们可以在浏览器中测试 CSS 选择器的效果，依然还是打开浏览器的开发者工具，然后按快捷键 Ctrl + F（如果你用的是 Mac，则是 Command + F），这时候在左下角便会出现一个搜索框，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/x3taf.png" alt=""></p>
                  <p>这时候我们输入 <code>.title</code> 就是选中了 class 为 title 的节点，这时候该节点就会被选中并在网页中高亮显示，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/ww6nn.png" alt=""></p>
                  <p>输入 <code>div#container .wrapper p.text</code> 就逐层选中了 id 为 container 中 class 为 wrapper 节点中的 p 节点，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/3g8jg.png" alt=""></p>
                  <p>另外，CSS 选择器还有一些其他语法规则，具体如下表所示。</p>
                  <p>CSS 选择器的其他语法规则</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">选　择　器</th>
                          <th style="text-align:left">例　　子</th>
                          <th style="text-align:left">例子描述</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left"><code>.class</code></td>
                          <td style="text-align:left"><code>.intro</code></td>
                          <td style="text-align:left">选择 <code>class=&quot;intro&quot;</code> 的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>#id</code></td>
                          <td style="text-align:left"><code>#firstname</code></td>
                          <td style="text-align:left">选择 <code>id=&quot;firstname&quot;</code> 的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>*</code></td>
                          <td style="text-align:left"><code>*</code></td>
                          <td style="text-align:left">选择所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element</code></td>
                          <td style="text-align:left"><code>p</code></td>
                          <td style="text-align:left">选择所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element,element</code></td>
                          <td style="text-align:left"><code>div,p</code></td>
                          <td style="text-align:left">选择所有 <code>div</code> 节点和所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element element</code></td>
                          <td style="text-align:left"><code>div p</code></td>
                          <td style="text-align:left">选择 <code>div</code> 节点内部的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element&gt;element</code></td>
                          <td style="text-align:left"><code>div&gt;p</code></td>
                          <td style="text-align:left">选择父节点为 <code>div</code> 节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element+element</code></td>
                          <td style="text-align:left"><code>div+p</code></td>
                          <td style="text-align:left">选择紧接在 <code>div</code> 节点之后的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute]</code></td>
                          <td style="text-align:left"><code>[target]</code></td>
                          <td style="text-align:left">选择带有 <code>target</code> 属性的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute=value]</code></td>
                          <td style="text-align:left"><code>[target=blank]</code></td>
                          <td style="text-align:left">选择 <code>target=&quot;blank&quot;</code> 的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute~=value]</code></td>
                          <td style="text-align:left"><code>[title~=flower]</code></td>
                          <td style="text-align:left">选择 <code>title</code> 属性包含单词 <code>flower</code> 的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:link</code></td>
                          <td style="text-align:left"><code>a:link</code></td>
                          <td style="text-align:left">选择所有未被访问的链接</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:visited</code></td>
                          <td style="text-align:left"><code>a:visited</code></td>
                          <td style="text-align:left">选择所有已被访问的链接</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:active</code></td>
                          <td style="text-align:left"><code>a:active</code></td>
                          <td style="text-align:left">选择活动链接</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:hover</code></td>
                          <td style="text-align:left"><code>a:hover</code></td>
                          <td style="text-align:left">选择鼠标指针位于其上的链接</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:focus</code></td>
                          <td style="text-align:left"><code>input:focus</code></td>
                          <td style="text-align:left">选择获得焦点的 <code>input</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:first-letter</code></td>
                          <td style="text-align:left"><code>p:first-letter</code></td>
                          <td style="text-align:left">选择每个 <code>p</code> 节点的首字母</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:first-line</code></td>
                          <td style="text-align:left"><code>p:first-line</code></td>
                          <td style="text-align:left">选择每个 <code>p</code> 节点的首行</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:first-child</code></td>
                          <td style="text-align:left"><code>p:first-child</code></td>
                          <td style="text-align:left">选择属于父节点的第一个子节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:before</code></td>
                          <td style="text-align:left"><code>p:before</code></td>
                          <td style="text-align:left">在每个 <code>p</code> 节点的内容之前插入内容</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:after</code></td>
                          <td style="text-align:left"><code>p:after</code></td>
                          <td style="text-align:left">在每个 <code>p</code> 节点的内容之后插入内容</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:lang(language)</code></td>
                          <td style="text-align:left"><code>p:lang</code></td>
                          <td style="text-align:left">选择带有以 <code>it</code> 开头的 <code>lang</code> 属性值的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>element1~element2</code></td>
                          <td style="text-align:left"><code>p~ul</code></td>
                          <td style="text-align:left">选择前面有 <code>p</code> 节点的所有 <code>ul</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute^=value]</code></td>
                          <td style="text-align:left"><code>a[src^=&quot;https&quot;]</code></td>
                          <td style="text-align:left">选择其 <code>src</code> 属性值以 <code>https</code> 开头的所有 <code>a</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute$=value]</code></td>
                          <td style="text-align:left"><code>a[src$=&quot;.pdf&quot;]</code></td>
                          <td style="text-align:left">选择其 <code>src</code> 属性以 .pdf 结尾的所有 <code>a</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>[attribute*=value]</code></td>
                          <td style="text-align:left"><code>a[src*=&quot;abc&quot;]</code></td>
                          <td style="text-align:left">选择其 <code>src</code> 属性中包含 <code>abc</code> 子串的所有 <code>a</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:first-of-type</code></td>
                          <td style="text-align:left"><code>p:first-of-type</code></td>
                          <td style="text-align:left">选择属于其父节点的首个 <code>p</code> 节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:last-of-type</code></td>
                          <td style="text-align:left"><code>p:last-of-type</code></td>
                          <td style="text-align:left">选择属于其父节点的最后一个 <code>p</code> 节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:only-of-type</code></td>
                          <td style="text-align:left"><code>p:only-of-type</code></td>
                          <td style="text-align:left">选择属于其父节点唯一的 <code>p</code> 节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:only-child</code></td>
                          <td style="text-align:left"><code>p:only-child</code></td>
                          <td style="text-align:left">选择属于其父节点的唯一子节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:nth-child(n)</code></td>
                          <td style="text-align:left"><code>p:nth-child</code></td>
                          <td style="text-align:left">选择属于其父节点的第二个子节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:nth-last-child(n)</code></td>
                          <td style="text-align:left"><code>p:nth-last-child</code></td>
                          <td style="text-align:left">同上，从最后一个子节点开始计数</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:nth-of-type(n)</code></td>
                          <td style="text-align:left"><code>p:nth-of-type</code></td>
                          <td style="text-align:left">选择属于其父节点第二个 <code>p</code> 节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:nth-last-of-type(n)</code></td>
                          <td style="text-align:left"><code>p:nth-last-of-type</code></td>
                          <td style="text-align:left">同上，但是从最后一个子节点开始计数</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:last-child</code></td>
                          <td style="text-align:left"><code>p:last-child</code></td>
                          <td style="text-align:left">选择属于其父节点最后一个子节点的所有 <code>p</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:root</code></td>
                          <td style="text-align:left"><code>:root</code></td>
                          <td style="text-align:left">选择文档的根节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:empty</code></td>
                          <td style="text-align:left"><code>p:empty</code></td>
                          <td style="text-align:left">选择没有子节点的所有 <code>p</code> 节点（包括文本节点）</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:target</code></td>
                          <td style="text-align:left"><code>#news:target</code></td>
                          <td style="text-align:left">选择当前活动的 <code>#news</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:enabled</code></td>
                          <td style="text-align:left"><code>input:enabled</code></td>
                          <td style="text-align:left">选择每个启用的 <code>input</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:disabled</code></td>
                          <td style="text-align:left"><code>input:disabled</code></td>
                          <td style="text-align:left">选择每个禁用的 <code>input</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:checked</code></td>
                          <td style="text-align:left"><code>input:checked</code></td>
                          <td style="text-align:left">选择每个被选中的 <code>input</code> 节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>:not(selector)</code></td>
                          <td style="text-align:left"><code>:not</code></td>
                          <td style="text-align:left">选择非 <code>p</code> 节点的所有节点</td>
                        </tr>
                        <tr>
                          <td style="text-align:left"><code>::selection</code></td>
                          <td style="text-align:left"><code>::selection</code></td>
                          <td style="text-align:left">选择被用户选取的节点部分</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>另外，还有一种比较常用的选择器 XPath，这种选择方式后面会详细介绍。</p>
                  <h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2>
                  <p>本节介绍了网页的结构和节点间的关系，了解了这些内容，我们才有更加清晰的思路去解析和提取网页内容。</p>
                  <p>本节参考来源：</p>
                  <ul>
                    <li>文档 - HTML - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML</a></li>
                    <li>文档 - JavaScript - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li>
                    <li>文档 - HTML DOM 节点 - W3School：<a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/htmldom/dom_nodes.asp</a></li>
                    <li>文档 - HTML - 维基百科：<a href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTML</a></li>
                    <li>文档 - CSS Selector - W3School：<a href="https://www.w3schools.com/cssref/css_selectors.asp" target="_blank" rel="noopener">https://www.w3schools.com/cssref/css_selectors.asp</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-11 02:38:31" itemprop="dateCreated datePublished" datetime="2022-02-11T02:38:31+08:00">2022-02-11</time>
                </span>
                <span id="/202213.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - Web网页基础" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>6.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>6 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/202212.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/202212.html" class="post-title-link" itemprop="url">【2022 年】Python3 爬虫教程 - HTTP 基本原理</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <blockquote>
                    <p>系列文章总目录：<a href="https://cuiqingcai.com/17777.html">【2022 年】Python3 爬虫学习教程</a>，本教程内容多数来自于《Python3 网络爬虫开发实战（第二版）》一书，目前截止 2022 年，可以将爬虫基本技术进行系统讲解，同时将最新前沿爬虫技术如异步、JavaScript 逆向、AST、安卓逆向、Hook、智能解析、群控技术、WebAssembly、大规模分布式、Docker、Kubernetes 等，市面上目前就仅有<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">《Python3 网络爬虫开发实战（第二版）》</a>一书了，<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">点击了解详情</a>。</p>
                  </blockquote>
                  <p>在正式学习网络爬虫之前，我们需要详细了解 HTTP 的基本原理，了解在浏览器中敲入 URL 到获取网页内容之间发生了什么。了解这些内容，有助于我们进一步了解爬虫的基本原理。</p>
                  <h1 id="1-1-HTTP-基本原理"><a href="#1-1-HTTP-基本原理" class="headerlink" title="1.1 HTTP 基本原理"></a>1.1 HTTP 基本原理</h1>
                  <p>在本节中，我们会详细了解 HTTP 的基本原理，了解在浏览器中敲入 URL 到获取网页内容之间发生了什么。了解这些内容，有助于我们进一步了解爬虫的基本原理。</p>
                  <h2 id="1-URI-和-URL"><a href="#1-URI-和-URL" class="headerlink" title="1. URI 和 URL"></a>1. URI 和 URL</h2>
                  <p>这里我们先了解一下 URI 和 URL。URI 的全称为 Uniform Resource Identifier，即统一资源标志符；而 URL 的全称为 Universal Resource Locator，即统一资源定位符。举例来说，<a href="https://github.com/favicon.ico" target="_blank" rel="noopener">https://github.com/favicon.ico</a> 是一个 URL，也是一个 URI。即有这样一个图标资源，我们用 URL/URI 来唯一指定了它的访问方式，这其中包括了访问协议 https、访问路径（即根目录）和资源名称 favicon.ico。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是 URL/URI。</p>
                  <p>URL 是 URI 的子集，也就是说每个 URL 都是 URI，但不是每个 URI 都是 URL。那么，怎样的 URI 不是 URL 呢？URI 还包括一个子类，叫作 URN，它的全称为 Universal Resource Name，即统一资源名称。URN 只命名资源而不指定如何定位资源，比如 urn:isbn:0451450523 指定了一本书的 ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书，这就是 URN。URL、URN 和 URI 的关系可以用图 1-1 表示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/l7600.jpg" alt="URL、URN 和 URI 关系图"></p>
                  <p>但是在目前的互联网，URN 使用得非常少，几乎所有的 URI 都是 URL，所以对于一般的网页链接，我们既可以称之为 URL，也可以称之为 URI，我个人习惯称之为 URL。</p>
                  <p>但 URL 也不是随便写的，它也是需要遵循一定的格式规范的，基本的组成格式如下：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scheme://[<span class="string">username:password@</span>]hostname[<span class="string">:port</span>][<span class="symbol">/path</span>][<span class="string">;parameters</span>][<span class="symbol">?query</span>][<span class="string">#fragment</span>]</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中这里中括号包括的内容代表非必要部分，比如 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 这个 URL，这里就只包含了 scheme 和 host 两部分，其他的 port、path、parameters、query、fragment 都没有。</p>
                  <p>这里我们分别介绍下几部分代表的含义和作用：</p>
                  <ul>
                    <li>scheme：协议。比如常用的协议有 http、https、ftp 等等，另外 scheme 也被常称作 protocol，都代表协议的意思。</li>
                    <li>username、password：用户名和密码。在某些情况下 URL 需要提供用户名和密码才能访问，这时候可以把用户名密码放在 host 前面。比如 <a href="https://ssr3.scrape.center" target="_blank" rel="noopener">https://ssr3.scrape.center</a> 这个 URL 需要用户名密码才能访问，那么可以直接写为 <a href="https://admin:admin@ssr3.scrape.center" target="_blank" rel="noopener">https://admin:admin@ssr3.scrape.center</a> 则可以直接访问。</li>
                    <li>hostname：主机地址。可以是域名或 IP 地址，比如 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 这个 URL 中的 hostname 就是 www.baidu.com，这就是百度的二级域名。比如 <a href="https://8.8.8.8" target="_blank" rel="noopener">https://8.8.8.8</a> 这个 URL 中 hostname 就是 8.8.8.8，它是一个 IP 地址。</li>
                    <li>port：端口。这是服务器设定的服务端口，比如 <a href="https://8.8.8.8:12345" target="_blank" rel="noopener">https://8.8.8.8:12345</a> 这个 URL 中的端口就是 12345。但是有些 URL 中没有端口信息，这是使用了默认的端口，http 协议的默认端口是 80，https 协议的默认端口是 443。所以 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 其实相当于 <a href="https://www.baidu.com:443，而">https://www.baidu.com:443，而</a> <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 其实相当于 <a href="http://www.baidu.com:80。">http://www.baidu.com:80。</a></li>
                    <li>path：路径。指的是网络资源在服务器中的指定地址，比如 <a href="https://github.com/favicon.ico" target="_blank" rel="noopener">https://github.com/favicon.ico</a> 这里 path 就是 favicon.ico，指的就是访问 GitHub 上的根目录下的 favicon.ico 这个资源。</li>
                    <li>parameters：参数。用来制定访问某个资源的时候的附加信息，比如 <a href="https://8.8.8.8:12345/hello;user" target="_blank" rel="noopener">https://8.8.8.8:12345/hello;user</a> 这里的 user 就是 parameters。但是 parameters 现在用得很少，所以目前很多人会把该参数后面的 query 部分称为参数，甚至把 parameters 和 query 混用。严格意义上来说，parameters 是分号 ; 后面的内容。</li>
                    <li>query：查询。用来查询某类资源，如果有多个查询，则用 &amp; 隔开。query 其实非常常见，比如 <a href="https://www.baidu.com/s?wd=nba&amp;ie=utf-8，这里的" target="_blank" rel="noopener">https://www.baidu.com/s?wd=nba&amp;ie=utf-8，这里的</a> query 部分就是 wd=nba&amp;ie=utf-8，这里指定了 wd 是 nba，ie 是 utf-8。由于 query 比刚才所说的 parameters 使用频率高太多，所以平时我们见到的参数、GET 请求参数、parameters、params 等称呼多数情况指代的也是 query。严格意义上来说，其实应该用 query 来表示。</li>
                    <li>fragment：片段。它是对资源描述的部分补充，可以理解为资源内部的书签。目前它有两个主要应用，一个是用作单页面路由，比如 现代前端框架 Vue、React 都可以借助它来做路由管理；另外一个应用是用作 HTML 锚点，用它可以控制一个页面打开时自动下滑滚动到某个特定的位置。</li>
                  </ul>
                  <p>以上我们就简单了解了 URL 的基本概念和构成，后文我们会结合多个实战案例练习来帮助加深其理解。</p>
                  <h2 id="2-HTTP-和-HTTPS"><a href="#2-HTTP-和-HTTPS" class="headerlink" title="2. HTTP 和 HTTPS"></a>2. HTTP 和 HTTPS</h2>
                  <p>刚才我们了解了 URL 的基本构成，其支持的协议有很多，比如 http、https、ftp、sftp、smb 等等。</p>
                  <p>在爬虫中，我们抓取的页面通常基于 http 或 https 协议，这里首先我们先来了解一下这两个协议的含义。</p>
                  <p>HTTP 的全称是 Hyper Text Transfer Protocol，中文名叫作超文本传输协议。HTTP 协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP 由万维网协会（World Wide Web Consortium）和 Internet 工作小组 IETF（Internet Engineering Task Force）共同合作制定的规范，目前广泛使用的是 HTTP 1.1 版本，当然 HTTP 2.0 现在不少网站也增加了支持。</p>
                  <p>其发展历史见下表：</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th>版本</th>
                          <th>产生时间</th>
                          <th>主要特点</th>
                          <th>发展现状</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td>HTTP/0.9</td>
                          <td>1991 年</td>
                          <td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能 GET 请求</td>
                          <td>没有作为正式的标准</td>
                        </tr>
                        <tr>
                          <td>HTTP/1.0</td>
                          <td>1996 年</td>
                          <td>传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令</td>
                          <td>正式作为标准</td>
                        </tr>
                        <tr>
                          <td>HTTP/1.1</td>
                          <td>1997 年</td>
                          <td>持久连接(长连接)、节约带宽、HOST 域、管道机制、分块传输编码</td>
                          <td>正式作为标准并广泛使用</td>
                        </tr>
                        <tr>
                          <td>HTTP/2.0</td>
                          <td>2015 年</td>
                          <td>多路复用、服务器推送、头信息压缩、二进制协议等</td>
                          <td>逐渐覆盖市场</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即在 HTTP 下加入 SSL 层，简称为 HTTPS。</p>
                  <p>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用分为以下两种。</p>
                  <ul>
                    <li>建立一个信息安全通道，保证数据传输的安全性。</li>
                    <li>确认网站的真实性。凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。</li>
                  </ul>
                  <p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展，举例如下。</p>
                  <ul>
                    <li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li>
                    <li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li>
                    <li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li>
                  </ul>
                  <p>因此，HTTPS 已经是大势所趋。</p>
                  <blockquote>
                    <p>注：HTTP 和 HTTPS 协议都属于计算机网络中的应用层协议，其下层是基于 TCP 协议实现的，TCP 协议属于计算机网络中的传输层协议，包括建立连接时的三次握手和断开时的四次挥手等过程。但本书主要讲的是网络爬虫相关，主要爬取的是 HTTP/HTTPS 协议相关的内容，所以这里就不再展开深入讲解 TCP、IP 等相关知识了，感兴趣的读者可以搜索相关资料了解下，如《计算机网络》、《图解 HTTP》等书籍。</p>
                  </blockquote>
                  <h2 id="3-HTTP-请求过程"><a href="#3-HTTP-请求过程" class="headerlink" title="3. HTTP 请求过程"></a>3. HTTP 请求过程</h2>
                  <p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。</p>
                  <p>实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</p>
                  <p>由于响应里包含页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，流程如图 1-3 所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/aod7o.jpg" alt="模型图"></p>
                  <p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p>
                  <p>为了更直观地说明这个过程，这里用 Chrome 浏览器开发者模式下的 Network 监听组件来做下演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。</p>
                  <p>打开 Chrome 浏览器，访问百度 <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>，这时候鼠标右键并选择“检查”菜单（或直接按快捷键 F12），即可打开浏览器的开发者工具，如下图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/rc3jq.png" alt="打开浏览器的开发者工具"></p>
                  <p>我们切换到 Network 面板，然后重新刷新网页，这时候就可以看到在 Network 面板下方出现了很多个条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/lwt4l.png" alt="请求和接收响应的过程"></p>
                  <p>我们先观察第一个网络请求，即 www.baidu.com，其中各列的含义如下。</p>
                  <ul>
                    <li>第一列 Name：请求的名称，一般会将 URL 的最后一部分内容当作名称。</li>
                    <li>第二列 Status：响应的状态码，这里显示为 200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。</li>
                    <li>第三列 Protocol：请求的协议类型，这里 http/1.1 代表是 HTTP 1.1 版本，h2 代表 HTTP 2.0 版本。</li>
                    <li>第四列 Type：请求的文档类型。这里为 document，代表我们这次请求的是一个 HTML 文档，内容就是一些 HTML 代码。</li>
                    <li>第五列 Initiator：请求源。用来标记请求是由哪个对象或进程发起的。</li>
                    <li>第六列 Size：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 from cache。</li>
                    <li>第七列 Time：发起请求到获取响应所用的总时间。</li>
                    <li>第八列 Waterfall：网络请求的可视化瀑布流。</li>
                  </ul>
                  <p>我们点击这个条目，即可看到其更详细的信息，如图所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/0utz7.png" alt="更详细的信息"></p>
                  <p>首先是 General 部分，其中 Request URL 为请求的 URL，Request Method 为请求的方法，Status Code 为响应状态码，Remote Address 为远程服务器的地址和端口，Referrer Policy 为 Referrer 判别策略。</p>
                  <p>再继续往下可以看到，有 Response Headers 和 Request Headers，它们分别代表响应头和请求头。请求头里带有许多请求信息，例如浏览器标识、Cookie、Host 等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图 1-5 中看到的 Response Headers 就是响应的一部分，其中包含了服务器的类型、文档类型、日期等信息，浏览器接收到响应后，会解析响应内容，进而呈现网页内容。</p>
                  <p>下面我们分别来介绍一下请求和响应都包含哪些内容。</p>
                  <h2 id="4-请求（Request）"><a href="#4-请求（Request）" class="headerlink" title="4. 请求（Request）"></a>4. 请求（Request）</h2>
                  <p>请求，英文为 Request，由客户端向服务器发出，可以分为 4 部分内容：请求方法（Request Method）、请求的网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。</p>
                  <p>下面我们分别予以介绍。</p>
                  <h3 id="请求方法（Request-Method）"><a href="#请求方法（Request-Method）" class="headerlink" title="请求方法（Request Method）"></a>请求方法（Request Method）</h3>
                  <p>请求方法，英文为 Request Method，用于标识请求客户端请求服务端的方式，常见的请求方法有两种：GET 和 POST。</p>
                  <p>在浏览器中直接输入 URL 并回车，这便发起了一个 GET 请求，请求的参数会直接包含到 URL 里。例如，在百度中搜索 Python，这就是一个 GET 请求，链接为 <a href="https://www.baidu.com/s?wd=Python" target="_blank" rel="noopener">https://www.baidu.com/s?wd=Python</a>，其中 URL 中包含了请求的 query 信息，这里的参数 wd 表示要搜寻的关键字。POST 请求大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击 “登录” 按钮，这通常会发起一个 POST 请求，其数据通常以表单的形式传输，而不会体现在 URL 中。</p>
                  <p>GET 和 POST 请求方法有如下区别：</p>
                  <ul>
                    <li>GET 请求中的参数包含在 URL 里面，数据可以在 URL 中看到；而 POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li>
                    <li>GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。</li>
                  </ul>
                  <p>一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用 GET 方式请求的话，密码就会暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方式发送。上传文件时，由于文件内容比较大，也会选用 POST 方式。</p>
                  <p>我们平常遇到的绝大部分请求都是 GET 或 POST 请求。另外，还有一些请求方法，如 GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE 等，我们简单将其总结为下表。</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">方　　法</th>
                          <th style="text-align:left">描　　述</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left">GET</td>
                          <td style="text-align:left">请求页面，并返回页面内容</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">HEAD</td>
                          <td style="text-align:left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">POST</td>
                          <td style="text-align:left">大多用于提交表单或上传文件，数据包含在请求体中</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">PUT</td>
                          <td style="text-align:left">从客户端向服务器传送的数据取代指定文档中的内容</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">DELETE</td>
                          <td style="text-align:left">请求服务器删除指定的页面</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">CONNECT</td>
                          <td style="text-align:left">把服务器当作跳板，让服务器代替客户端访问其他网页</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">OPTIONS</td>
                          <td style="text-align:left">允许客户端查看服务器的性能</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">TRACE</td>
                          <td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>本表参考：<a href="http://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-methods.html</a>。</p>
                  <h3 id="请求的网址（Request-URL）"><a href="#请求的网址（Request-URL）" class="headerlink" title="请求的网址（Request URL）"></a>请求的网址（Request URL）</h3>
                  <p>请求的网址，英文为 Reqeust URL，它可以唯一确定我们想请求的资源。关于 URL 的构成和各个部分的功能我们在前文已经提及到了，这里就不再赘述。</p>
                  <h3 id="请求头（Request-Headers）"><a href="#请求头（Request-Headers）" class="headerlink" title="请求头（Request Headers）"></a>请求头（Request Headers）</h3>
                  <p>请求头，英文为 Request Headers，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。</p>
                  <p>下面简要说明一些常用的头信息：</p>
                  <ul>
                    <li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。</li>
                    <li>Accept-Language：指定客户端可接受的语言类型。</li>
                    <li>Accept-Encoding：指定客户端可接受的内容编码。</li>
                    <li>Host：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li>
                    <li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookie 的功劳。Cookie 里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上 Cookie 并将其发送给服务器，服务器通过 Cookie 识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li>
                    <li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li>
                    <li>User-Agent：简称 UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别为爬虫。</li>
                    <li>Content-Type：也叫互联网媒体类型（Internet Media Type）或者 MIME 类型，在 HTTP 协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text/html 代表 HTML 格式，image/gif 代表 GIF 图片，application/json 代表 JSON 类型，更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a>。</li>
                  </ul>
                  <p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p>
                  <h3 id="请求体（Request-Body）"><a href="#请求体（Request-Body）" class="headerlink" title="请求体（Request Body）"></a>请求体（Request Body）</h3>
                  <p>请求体，即 Request Body 一般承载的内容是 POST 请求中的表单数据，而对于 GET 请求，请求体则为空。</p>
                  <p>例如，这里我登录 GitHub 时捕获到的请求和响应如图 1-6 所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/4tinn.jpg" alt="请求和响应"></p>
                  <p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意 Request Headers 中指定 Content-Type 为 application/x-www-form-urlencoded。只有设置 Content-Type 为 application/x-www-form-urlencoded，才会以表单数据的形式提交。另外，我们也可以将 Content-Type 设置为 application/json 来提交 JSON 数据，或者设置为 multipart/form-data 来上传文件。</p>
                  <p>如下表是 Content-Type 和 POST 提交数据方式的关系</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">Content-Type</th>
                          <th style="text-align:left">提交数据的方式</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left">application/x-www-form-urlencoded</td>
                          <td style="text-align:left">表单数据</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">multipart/form-data</td>
                          <td style="text-align:left">表单文件上传</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">application/json</td>
                          <td style="text-align:left">序列化 JSON 数据</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">text/xml</td>
                          <td style="text-align:left">XML 数据</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <p>在爬虫中，如果要构造 POST 请求，需要使用正确的 Content-Type，并了解各种请求库的各个参数设置时使用的是哪种 Content-Type，不然可能会导致 POST 提交后无法正常响应。</p>
                  <h2 id="5-响应（Response）"><a href="#5-响应（Response）" class="headerlink" title="5. 响应（Response）"></a>5. 响应（Response）</h2>
                  <p>响应，即 Response，由服务器返回给客户端，可以分为三部分：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p>
                  <h3 id="响应状态码（Response-Status-Code）"><a href="#响应状态码（Response-Status-Code）" class="headerlink" title="响应状态码（Response Status Code）"></a>响应状态码（Response Status Code）</h3>
                  <p>响应状态码，即 Response Status Code，表示服务器的响应状态，如 200 代表服务器正常响应，404 代表页面未找到，500 代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为 200，则证明成功返回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p>
                  <p>常见的错误代码及错误原因</p>
                  <div class="table-container">
                    <table>
                      <thead>
                        <tr>
                          <th style="text-align:left">状态码</th>
                          <th style="text-align:left">说　　明</th>
                          <th style="text-align:left">详　　情</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td style="text-align:left">100</td>
                          <td style="text-align:left">继续</td>
                          <td style="text-align:left">请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">101</td>
                          <td style="text-align:left">切换协议</td>
                          <td style="text-align:left">请求者已要求服务器切换协议，服务器已确认并准备切换</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">200</td>
                          <td style="text-align:left">成功</td>
                          <td style="text-align:left">服务器已成功处理了请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">201</td>
                          <td style="text-align:left">已创建</td>
                          <td style="text-align:left">请求成功并且服务器创建了新的资源</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">202</td>
                          <td style="text-align:left">已接受</td>
                          <td style="text-align:left">服务器已接受请求，但尚未处理</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">203</td>
                          <td style="text-align:left">非授权信息</td>
                          <td style="text-align:left">服务器已成功处理了请求，但返回的信息可能来自另一个源</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">204</td>
                          <td style="text-align:left">无内容</td>
                          <td style="text-align:left">服务器成功处理了请求，但没有返回任何内容</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">205</td>
                          <td style="text-align:left">重置内容</td>
                          <td style="text-align:left">服务器成功处理了请求，内容被重置</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">206</td>
                          <td style="text-align:left">部分内容</td>
                          <td style="text-align:left">服务器成功处理了部分请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">300</td>
                          <td style="text-align:left">多种选择</td>
                          <td style="text-align:left">针对请求，服务器可执行多种操作</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">301</td>
                          <td style="text-align:left">永久移动</td>
                          <td style="text-align:left">请求的网页已永久移动到新位置，即永久重定向</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">302</td>
                          <td style="text-align:left">临时移动</td>
                          <td style="text-align:left">请求的网页暂时跳转到其他页面，即暂时重定向</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">303</td>
                          <td style="text-align:left">查看其他位置</td>
                          <td style="text-align:left">如果原来的请求是 POST，重定向目标文档应该通过 GET 提取</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">304</td>
                          <td style="text-align:left">未修改</td>
                          <td style="text-align:left">此次请求返回的网页未修改，继续使用上次的资源</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">305</td>
                          <td style="text-align:left">使用代理</td>
                          <td style="text-align:left">请求者应该使用代理访问该网页</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">307</td>
                          <td style="text-align:left">临时重定向</td>
                          <td style="text-align:left">请求的资源临时从其他位置响应</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">400</td>
                          <td style="text-align:left">错误请求</td>
                          <td style="text-align:left">服务器无法解析该请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">401</td>
                          <td style="text-align:left">未授权</td>
                          <td style="text-align:left">请求没有进行身份验证或验证未通过</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">403</td>
                          <td style="text-align:left">禁止访问</td>
                          <td style="text-align:left">服务器拒绝此请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">404</td>
                          <td style="text-align:left">未找到</td>
                          <td style="text-align:left">服务器找不到请求的网页</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">405</td>
                          <td style="text-align:left">方法禁用</td>
                          <td style="text-align:left">服务器禁用了请求中指定的方法</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">406</td>
                          <td style="text-align:left">不接受</td>
                          <td style="text-align:left">无法使用请求的内容响应请求的网页</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">407</td>
                          <td style="text-align:left">需要代理授权</td>
                          <td style="text-align:left">请求者需要使用代理授权</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">408</td>
                          <td style="text-align:left">请求超时</td>
                          <td style="text-align:left">服务器请求超时</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">409</td>
                          <td style="text-align:left">冲突</td>
                          <td style="text-align:left">服务器在完成请求时发生冲突</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">410</td>
                          <td style="text-align:left">已删除</td>
                          <td style="text-align:left">请求的资源已永久删除</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">411</td>
                          <td style="text-align:left">需要有效长度</td>
                          <td style="text-align:left">服务器不接受不含有效内容长度标头字段的请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">412</td>
                          <td style="text-align:left">未满足前提条件</td>
                          <td style="text-align:left">服务器未满足请求者在请求中设置的其中一个前提条件</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">413</td>
                          <td style="text-align:left">请求实体过大</td>
                          <td style="text-align:left">请求实体过大，超出服务器的处理能力</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">414</td>
                          <td style="text-align:left">请求 URI 过长</td>
                          <td style="text-align:left">请求网址过长，服务器无法处理</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">415</td>
                          <td style="text-align:left">不支持类型</td>
                          <td style="text-align:left">请求格式不被请求页面支持</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">416</td>
                          <td style="text-align:left">请求范围不符</td>
                          <td style="text-align:left">页面无法提供请求的范围</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">417</td>
                          <td style="text-align:left">未满足期望值</td>
                          <td style="text-align:left">服务器未满足期望请求标头字段的要求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">500</td>
                          <td style="text-align:left">服务器内部错误</td>
                          <td style="text-align:left">服务器遇到错误，无法完成请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">501</td>
                          <td style="text-align:left">未实现</td>
                          <td style="text-align:left">服务器不具备完成请求的功能</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">502</td>
                          <td style="text-align:left">错误网关</td>
                          <td style="text-align:left">服务器作为网关或代理，从上游服务器收到无效响应</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">503</td>
                          <td style="text-align:left">服务不可用</td>
                          <td style="text-align:left">服务器目前无法使用</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">504</td>
                          <td style="text-align:left">网关超时</td>
                          <td style="text-align:left">服务器作为网关或代理，但是没有及时从上游服务器收到请求</td>
                        </tr>
                        <tr>
                          <td style="text-align:left">505</td>
                          <td style="text-align:left">HTTP 版本不支持</td>
                          <td style="text-align:left">服务器不支持请求中所用的 HTTP 协议版本</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                  <h3 id="响应头（Response-Headers）"><a href="#响应头（Response-Headers）" class="headerlink" title="响应头（Response Headers）"></a>响应头（Response Headers）</h3>
                  <p>响应头，即 Response Headers，包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。下面简要说明一些常用的头信息。</p>
                  <ul>
                    <li>Date：标识响应产生的时间。</li>
                    <li>Last-Modified：指定资源的最后修改时间。</li>
                    <li>Content-Encoding：指定响应内容的编码。</li>
                    <li>Server：包含服务器的信息，比如名称、版本号等。</li>
                    <li>Content-Type：文档类型，指定返回的数据类型是什么，如 text/html 代表返回 HTML 文档，application/x-javascript 则代表返回 JavaScript 文件，image/jpeg 则代表返回图片。</li>
                    <li>Set-Cookie：设置 Cookie。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookie 中，下次请求携带 Cookie 请求。</li>
                    <li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>
                  </ul>
                  <h3 id="响应体（Response-Body）"><a href="#响应体（Response-Body）" class="headerlink" title="响应体（Response Body）"></a>响应体（Response Body）</h3>
                  <p>响应体，即 Response Body，这可以说是最关键的部分了，响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的 HTML 代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图 1-7 所示。</p>
                  <p><img src="https://cdn.cuiqingcai.com/6sq5o.jpg" alt="响应体"></p>
                  <p>在浏览器开发者工具中点击 Preview，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p>
                  <p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON 数据等，然后从中做相应内容的提取。</p>
                  <p>本节中，我们了解了 HTTP 的基本原理，大概了解了访问网页时背后的请求和响应过程。本节涉及的知识点需要好好掌握，后面分析网页请求时会经常用到。</p>
                  <h2 id="6-HTTP-2-0"><a href="#6-HTTP-2-0" class="headerlink" title="6. HTTP/2.0"></a>6. HTTP/2.0</h2>
                  <p>前面我们也提到了 HTTP 协议从 2015 年起发布了 2.0 版本，相比 HTTP/1.1 来说，HTTP/2.0 变得更快、更简单、更稳定，HTTP/2.0 在传输层做了很多优化，HTTP/2.0 的主要目标是通过支持完整的请求与响应复用来减少延迟，并通过有效压缩 HTTP 请求头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持，这些优化一笔勾销了 HTTP/1.1 为做传输优化想出的一系列“歪招”。</p>
                  <p>有读者这时候可能会问，为什么不叫 HTTP/1.2 而叫 HTTP/2.0 呢？因为 HTTP/2.0 在内部实现上新的二进制分帧层，这是没法与之前的 HTTP/1.x 的服务器和客户端实现向后兼容的，所以直接修改了主版本号为 2.0。</p>
                  <p>下面我们就来了解下 HTTP/2.0 相比 HTTP/1.1 来说做了哪些优化吧。</p>
                  <h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3>
                  <p>HTTP/2.0 所有性能增强的核心就在于这个新的二进制分帧层。在 HTTP/1.x 中，不管是请求（Request）还是响应（Response），它们都是用文本格式传输的，其头部（Headers）、实体（Body）之间也是用文本换行符分隔开的。HTTP/2.0 对其做了优化，将文本格式修改为了二进制格式，使得解析起来更加高效。同时将请求和响应数据分割为更小的帧，并采用二进制编码。</p>
                  <p>所以这里就引入了几个新的概念：</p>
                  <ul>
                    <li>帧：只存在于 HTTP/2.0 中的概念，是数据通信的最小单位，比如一个请求被分为了请求头帧（Request Headers frame）和请求体/数据帧（Request Data frame）。</li>
                    <li>数据流：一个虚拟通道，可以承载双向的消息，每个流都有一个唯一的整数 ID 来标识。</li>
                    <li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li>
                  </ul>
                  <p>在 HTTP/2.0 中，同域名下的所有通信都可以在单个连接上完成，该连接可以承载任意数量的双向数据流，数据流是用于承载双向消息的，每条消息都是一条逻辑 HTTP 消息（例如请求或响应），它可以包含一个或多个帧。</p>
                  <p>简而言之，HTTP/2.0 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息，所有这些都在一个 TCP 连接内复用，这是 HTTP/2.0 协议所有其他功能和性能优化的基础。</p>
                  <h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3>
                  <p>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接，而且浏览器位了控制资源，还会对单个域名有 6-8 个 TCP 连接请求的限制。但在 HTTP/2.0 中，由于又了二进制分帧技术的加持，HTTP/2.0 不用再以来 TCP 连接去实现多路并行了，客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来，让我们可以:</p>
                  <ul>
                    <li>并行交错地发送多个请求，请求之间互不影响。</li>
                    <li>并行交错地发送多个响应，响应之间互不干扰。</li>
                    <li>使用一个连接并行发送多个请求和响应。</li>
                    <li>不必再为绕过 HTTP/1.x 限制而做很多工作。</li>
                    <li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li>
                  </ul>
                  <p>这样以来，整个数据传输使性能就有了极大提升：</p>
                  <ul>
                    <li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
                    <li>并行交错地发送多个请求和详情，而且之间互不影响。</li>
                    <li>在 HTTP/2.0 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li>
                  </ul>
                  <h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3>
                  <p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。可以理解为，接收方已经太繁忙了，来不及处理收到的消息了，但是发送方还在一直大量发送消息，这样就会出现一些问题。</p>
                  <p>比如说，客户端可能请求了一个具有较高优先级的大型视频流，但是用户已经暂停视频，客户端现在希望暂停或限制从服务器的传输，以免提取和缓冲不必要的数据。 再比如，一个代理服务器可能具有较快的下游连接和较慢的上游连接，并且也希望调节下游连接传输数据的速度以匹配上游连接的速度来控制其资源利用率等等。</p>
                  <p>由于 HTTP 是基于 TCP 实现的，虽然 TCP 原生有流量控制机制，但是由于 HTTP/2.0 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。</p>
                  <p>为了解决这一问题，HTTP/2.0 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制:</p>
                  <ul>
                    <li>流控制具有方向性。 每个接收方都可以根据自身需要选择为每个数据流和整个连接设置任意的窗口大小。</li>
                    <li>流控制基于信用。 每个接收方都可以公布其初始连接和数据流流控制窗口（以字节为单位），每当发送方发出 <code>DATA</code> 帧时都会减小，在接收方发出 <code>WINDOW_UPDATE</code> 帧时增大。</li>
                    <li>流控制无法停用。 建立 HTTP/2.0 连接后，客户端将与服务器交换 <code>SETTINGS</code> 帧，这会在两个方向上设置流控制窗口。 流控制窗口的默认值设为 65535 字节，但是接收方可以设置一个较大的最大窗口大小（<code>2^31-1</code> 字节），并在接收到任意数据时通过发送 <code>WINDOW_UPDATE</code> 帧来维持这一大小。</li>
                    <li>流控制为逐跃点控制，而非端到端控制。 即，可信中介可以使用它来控制资源使用，以及基于自身条件和启发式算法实现资源分配机制。</li>
                  </ul>
                  <p>由此可见，HTTP/2.0 提供了简单的构建块实现了自定义策略来调节资源使用和分配，以及实现新传输能力，同时提升了网页应用的实际性能和感知性能。</p>
                  <h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3>
                  <p>HTTP/2.0 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p>
                  <p>如果某些资源客户端是一定会请求的，这时就可以采取服务端推送的技术，在客户端发起一次请求后，额外提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。例如，服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p>
                  <p><img src="https://cdn.cuiqingcai.com/y0vea.png" alt="服务端推送"></p>
                  <p>服务端可以主动推送，当然客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。</p>
                  <p>另外主动推送也遵守同源策略，即服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行，这样也能保证一定的安全性。</p>
                  <h3 id="HTTP-2-0-发展现状"><a href="#HTTP-2-0-发展现状" class="headerlink" title="HTTP/2.0 发展现状"></a>HTTP/2.0 发展现状</h3>
                  <p>HTTP/2.0 的普及是一件任重而道远的事情，一些主流的网站现在已经支持了 HTTP/2.0，主流浏览器现在都已经实现了 HTTP/2.0 的支持，但总的来看，目前大部分网站依然还是以 HTTP/1.1 为主。</p>
                  <p>另外一些编程语言的库还没有完全支持 HTTP/2.0，比如对于 Python 来说，hyper、httpx 等库已经支持了 HTTP/2.0，但广泛使用的 requests 库依然还是只支持 HTTP/1.1。</p>
                  <h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2>
                  <p>本节介绍了关于 HTTP 的一些基础知识，内容不少，需要好好掌握，这些知识对于后面我们编写和理解网络爬虫具有非常大的帮助。</p>
                  <p>由于本节的内容多数为概念介绍，内容参考了很多书籍、文档、博客，来源如下：</p>
                  <ul>
                    <li>书籍 - 《HTTP 权威指南》- 作者 David Gourley / Brian Totty</li>
                    <li>文档 - HTTP - 维基百科：<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li>
                    <li>文档 - HTTP - 百度百科：<a href="https://baike.baidu.com/item/HTTP/243074" target="_blank" rel="noopener">https://baike.baidu.com/item/HTTP/243074</a></li>
                    <li>文档 - HTTP - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP</a></li>
                    <li>文档 - HTTP/2 简介 - Google 开发文档：<a href="https://developers.google.com/web/fundamentals/performance/http2" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2</a></li>
                    <li>博客 - 一文读懂 HTTP/2 及 HTTP/3 特性：<a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/</a></li>
                    <li>博客 - 一文读懂 HTTP/2 特性：<a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26559480</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-02-11 00:38:31" itemprop="dateCreated datePublished" datetime="2022-02-11T00:38:31+08:00">2022-02-11</time>
                </span>
                <span id="/202212.html" class="post-meta-item leancloud_visitors" data-flag-title="【2022 年】Python3 爬虫教程 - HTTP 基本原理" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>13k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>12 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36051.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Markdown <i class="label-arrow"></i>
                  </a>
                  <a href="/36051.html" class="post-title-link" itemprop="url">用 Markdown 做 PPT，就是这么简单！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>相信绝大多数朋友做 PPT（幻灯片 / Slides / Deck 等各种称呼了）都是用的 PowerPoint 或者 KeyNote 吧？功能是比较强大，但你有没有遇到过这样的痛点：</p>
                  <ul>
                    <li>各种标题、段落的格式不统一，比如字体大小、行间距等等各个页面不太一样，然后得用格式刷来挨个刷一下。</li>
                    <li>想给 PPT 做版本控制，然后就保存了各种复制版本，比如“一版”、“二版”、“终版”、“最终版”、“最终不改版”、“最终稳定不改版”等等，想必大家都见过类似这样的场景吧。</li>
                    <li>想插入代码，但是插入之后发现格式全乱了或者高亮全没了，然后不得不截图插入进去。</li>
                    <li>想插入个公式，然后发现 PPT、Keynote 对 Latex 兼容不太好或者配置稍微麻烦，就只能自己重新敲一遍或者贴截图。</li>
                    <li>想插入一个酷炫的交互组件，比如嵌入一个微博的网页页面实时访问、插入一个可以交互的组件、插入一个音乐播放器组件，原生的 PPT 功能几乎都不支持，这全得依赖于 PowerPoint 或者 KeyNote 来支持才行。</li>
                  </ul>
                  <p>如果你遇到这些痛点，那请你一定要看下去。如果你没有遇到，那也请你看下去吧（拜托。</p>
                  <p>好，说回正题，我列举了那么多痛点，那这些痛点咋解决呢？</p>
                  <p>能！甚至解决方案更加轻量级，那就是用 Markdown 来做 PPT！</p>
                  <p>你试过用 Markdown 写 PPT 吗？没有吧，试试吧，试过之后你就发现上面的功能简直易如反掌。</p>
                  <p>具体怎么实现呢？</p>
                  <p>接下来，就有请今天的主角登场了！它就是 Slidev。</p>
                  <h2 id="什么是-Slidev？"><a href="#什么是-Slidev？" class="headerlink" title="什么是 Slidev？"></a>什么是 Slidev？</h2>
                  <p>简而言之，Slidev 就是可以让我们用 Markdown 写 PPT 的工具库，基于 Node.js、Vue.js 开发。</p>
                  <p>利用它我们可以简单地把 Markdown 转化成 PPT，而且它可以支持各种好看的主题、代码高亮、公式、流程图、自定义的网页交互组件，还可以方便地导出成 pdf 或者直接部署成一个网页使用。</p>
                  <p>官方主页：<a href="https://sli.dev/" target="_blank" rel="noopener">https://sli.dev/</a></p>
                  <p>GitHub：<a href="https://github.com/slidevjs/slidev" target="_blank" rel="noopener">https://github.com/slidevjs/slidev</a></p>
                  <h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2>
                  <p>下面我们就来了解下它的基本使用啦。</p>
                  <p>首先我们需要先安装好 Node.js，推荐 14.x 及以上版本，安装方法见 <a href="https://setup.scrape.center/nodejs" target="_blank" rel="noopener">https://setup.scrape.center/nodejs</a>。</p>
                  <p>接着，我们就可以使用 npm 这个命令了。</p>
                  <p>然后我们可以初始化一个仓库，运行命令如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">npm init slidev@latest</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个命令就是初始化一个 Slidev 的仓库，运行之后它会让我们输入和选择一些选项，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/ct067.png" alt=""></p>
                  <p>比如上图就是先输入项目文件夹的名称，比如这里我取名叫做 slidevtest。</p>
                  <p>总之一些选项完成之后，Slidev 会在本地 3000 端口上启动，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/llmmz.png" alt=""></p>
                  <p>接着，我们就可以打开浏览器 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 来查看一个 HelloWorld 版本的 PPT 了，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/0qyem.png" alt=""></p>
                  <p>我们可以点击空格进行翻页，第二页展示了一张常规的 PPT 的样式，包括标题、正文、列表等，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/3jo6f.png" alt=""></p>
                  <p>那这一页的 Markdown 是什么样的呢？其实就是非常常规的 Markdown 文章的写法，内容如下：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section"># What is Slidev?</span></span><br><span class="line"></span><br><span class="line">Slidev is a slides maker and presenter designed for developers, consist of the following features</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>📝 <span class="strong">**Text-based**</span> - focus on the content with Markdown, and then style them later</span><br><span class="line"><span class="bullet">- </span>🎨 <span class="strong">**Themable**</span> - theme can be shared and used with npm packages</span><br><span class="line"><span class="bullet">- </span>🧑‍💻 <span class="strong">**Developer Friendly**</span> - code highlighting, live coding with autocompletion</span><br><span class="line"><span class="bullet">- </span>🤹 <span class="strong">**Interactive**</span> - embedding Vue components to enhance your expressions</span><br><span class="line"><span class="bullet">- </span>🎥 <span class="strong">**Recording**</span> - built-in recording and camera view</span><br><span class="line"><span class="bullet">- </span>📤 <span class="strong">**Portable**</span> - export into PDF, PNGs, or even a hostable SPA</span><br><span class="line"><span class="bullet">- </span>🛠 <span class="strong">**Hackable**</span> - anything possible on a webpage</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Read more about [<span class="string">Why Slidev?</span>](<span class="link">https://sli.dev/guide/why</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>是不是？我们只需要用同样格式的 Markdown 语法就可以轻松将其转化为 PPT 了。</p>
                  <h2 id="快捷键操作"><a href="#快捷键操作" class="headerlink" title="快捷键操作"></a>快捷键操作</h2>
                  <p>再下一页介绍了各种快捷键的操作，这个就很常规了，比如点击空格、上下左右键来进行页面切换，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/ipa66.png" alt=""></p>
                  <p>更多快捷键的操作可以看这里的说明：<a href="https://sli.dev/guide/navigation.html" target="_blank" rel="noopener">https://sli.dev/guide/navigation.html</a>，一些简单的快捷键列举如下：</p>
                  <ul>
                    <li>f：切换全屏</li>
                    <li>right / space：下一动画或幻灯片</li>
                    <li>left：上一动画或幻灯片</li>
                    <li>up：上一张幻灯片</li>
                    <li>down：下一张幻灯片</li>
                    <li>o：切换<a href="https://cn.sli.dev/guide/navigation.html#slides-overview" target="_blank" rel="noopener">幻灯片总览</a></li>
                    <li>d：切换暗黑模式</li>
                    <li>g：显示“前往…”</li>
                  </ul>
                  <h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2>
                  <p>接下来就是代码环节了，因为 Markdown 对代码编写非常友好，所以展示自然也不是问题了，比如代码高亮、代码对齐等都是常规操作，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/0kjgi.png" alt=""></p>
                  <p>那左边的代码定义就直接这么写就行了：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section"># Code</span></span><br><span class="line"></span><br><span class="line">Use code snippets and get the highlighting directly![^1]</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>ts &#123;all|2|1-6|9|all&#125;</span><br><span class="line">interface User &#123;</span><br><span class="line">  id: number</span><br><span class="line">  firstName: string</span><br><span class="line">  lastName: string</span><br><span class="line">  role: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateUser(id: number, update: User) &#123;</span><br><span class="line">  const user = getUser(id)</span><br><span class="line">  const newUser = &#123;...user, ...update&#125;</span><br><span class="line">  saveUser(id, newUser)</span><br><span class="line">&#125;</span><br><span class="line"><span class="code">```</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>由于是 Markdown，所以我们可以指定是什么语言，比如 TypeScript、Python 等等。</p>
                  <h2 id="网页组件"><a href="#网页组件" class="headerlink" title="网页组件"></a>网页组件</h2>
                  <p>接下来就是非常酷炫的环节了，我们还可以自定义一些网页组件，然后展示出来。</p>
                  <p>比如我们看下面的一张图。左边就呈现了一个数字计数器，点击左侧数字就会减 1，点击右侧数字就会加 1；另外图的右侧还嵌入了一个组件，这里显示了一个推特的消息，通过一个卡片的形式呈现了出来，不仅仅可以看内容，甚至我们还可以点击下方的喜欢、回复、复制等按钮来进行一些交互。</p>
                  <p>这些功能在网页里面并不稀奇，但是如果能做到 PPT 里面，那感觉就挺酷的。</p>
                  <p><img src="https://cdn.cuiqingcai.com/ixf94.png" alt=""></p>
                  <p>那这一页怎么做到的呢？这个其实是引入了一些基于 Vue.js 的组件，本节对应的 Markdown 代码如下：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="section"># Components</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">grid</span>=<span class="string">"~ cols-2 gap-4"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">You can use Vue components directly inside your slides.</span><br><span class="line"></span><br><span class="line">We have provided a few built-in components like <span class="code">`&lt;Tweet/&gt;`</span> and <span class="code">`&lt;Youtube/&gt;`</span> that you can use directly. And adding your custom components is also super easy.</span><br><span class="line"></span><br><span class="line"><span class="code">```html</span></span><br><span class="line"><span class="code">&lt;Counter :count="10" /&gt;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- ./components/Counter.vue --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Counter</span> <span class="attr">:count</span>=<span class="string">"10"</span> <span class="attr">m</span>=<span class="string">"t-4"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">Check out [<span class="string">the guides</span>](<span class="link">https://sli.dev/builtin/components.html</span>) for more.</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="code">```html</span></span><br><span class="line"><span class="code">&lt;Tweet id="1390115482657726468" /&gt;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Tweet</span> <span class="attr">id</span>=<span class="string">"1390115482657726468"</span> <span class="attr">scale</span>=<span class="string">"0.65"</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们可以看到，这里引入了 Counter、Tweet 组件，而这个 Counter 就是 Vue.js 的组件，代码如下：</p>
                  <figure class="highlight markdown">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span></span></span><br><span class="line">import &#123; ref &#125; from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  count: &#123;</span><br><span class="line"><span class="code">    default: 0,</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const counter = ref(props.count)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">flex</span>=<span class="string">"~"</span> <span class="attr">w</span>=<span class="string">"min"</span> <span class="attr">border</span>=<span class="string">"~ gray-400 opacity-50 rounded-md"</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;button</span></span><br><span class="line"><span class="code">      border="r gray-400 opacity-50"</span></span><br><span class="line"><span class="code">      p="2"</span></span><br><span class="line"><span class="code">      font="mono"</span></span><br><span class="line"><span class="code">      outline="!none"</span></span><br><span class="line"><span class="code">      hover:bg="gray-400 opacity-20"</span></span><br><span class="line"><span class="code">      @click="counter -= 1"</span></span><br><span class="line"><span class="code">    &gt;</span></span><br><span class="line"><span class="code">      -</span></span><br><span class="line"><span class="code">    &lt;/button&gt;</span></span><br><span class="line"><span class="code">    &lt;span m="auto" p="2"&gt;&#123;&#123; counter &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="code">    &lt;button</span></span><br><span class="line"><span class="code">      border="l gray-400 opacity-50"</span></span><br><span class="line"><span class="code">      p="2"</span></span><br><span class="line"><span class="code">      font="mono"</span></span><br><span class="line"><span class="code">      outline="!none"</span></span><br><span class="line"><span class="code">      hover:bg="gray-400 opacity-20"</span></span><br><span class="line"><span class="code">      @click="counter += 1"</span></span><br><span class="line"><span class="code">    &gt;</span></span><br><span class="line"><span class="code">      +</span></span><br><span class="line"><span class="code">    &lt;/button&gt;</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就是一个标准的基于 Vue.js 3.x 的组件，都是标准的 Vue.js 语法，所以如果我们要添加想要的组件，直接自己写就行了，什么都能实现，只要网页能支持的，统统都能写！</p>
                  <h2 id="主题定义"><a href="#主题定义" class="headerlink" title="主题定义"></a>主题定义</h2>
                  <p>当然，一些主题定制也是非常方便的，我们可以在 Markdown 文件直接更改一些配置就好了，比如就把 theme 换个名字，整个主题样式就变了，看如下的对比图：</p>
                  <p><img src="https://cdn.cuiqingcai.com/7p7ud.png" alt=""></p>
                  <p>上面就是一些内置主题，当然我们也可以去官方文档查看一些别人已经写好的主题，见：<a href="https://sli.dev/themes/gallery.html" target="_blank" rel="noopener">https://sli.dev/themes/gallery.html</a>。</p>
                  <p>另外我们自己写主题也是可以的，所有的主题样式都可以通过 CSS 等配置好，想要什么就可以有什么，见：<a href="https://sli.dev/themes/write-a-theme.html" target="_blank" rel="noopener">https://sli.dev/themes/write-a-theme.html。</a></p>
                  <h2 id="公式和图表"><a href="#公式和图表" class="headerlink" title="公式和图表"></a>公式和图表</h2>
                  <p>接下来就是一个非常强大实用的功能，公式和图表，支持 Latex、流程图，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/d1sju.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/vs2i9.png" alt=""></p>
                  <p>比如上面的 Latex 的源代码就是这样的：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Inline $\sqrt&#123;3x-1&#125;+(1+x)^2$</span><br><span class="line"></span><br><span class="line">Block</span><br><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line"></span><br><span class="line">\nabla \times \vec&#123;\mathbf&#123;B&#125;&#125; -\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;E&#125;&#125;&#125;&#123;\partial t&#125; &amp;</span><br><span class="line">&#x3D; \frac&#123;4\pi&#125;&#123;c&#125;\vec&#123;\mathbf&#123;j&#125;&#125;    \nabla \cdot \vec&#123;\mathbf&#123;E&#125;&#125; &amp; &#x3D; 4 \pi \rho \\</span><br><span class="line"></span><br><span class="line">\nabla \times \vec&#123;\mathbf&#123;E&#125;&#125;\, +\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;B&#125;&#125;&#125;&#123;\partial t&#125; &amp; &#x3D; \vec&#123;\mathbf&#123;0&#125;&#125; \\</span><br><span class="line"></span><br><span class="line">\nabla \cdot \vec&#123;\mathbf&#123;B&#125;&#125; &amp; &#x3D; 0</span><br><span class="line"></span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其语法也是和 Latex 一样的。</p>
                  <p>其背后是怎么实现的呢？其实是因为 Slidev 默认集成了 Katex 这个库，见：<a href="https://katex.org/" target="_blank" rel="noopener">https://katex.org/</a>，有了 Katex 的加持，所有公式的显示都不是事。</p>
                  <h2 id="页面分隔"><a href="#页面分隔" class="headerlink" title="页面分隔"></a>页面分隔</h2>
                  <p>有的朋友就好奇了，既然是用 Markdown 写 PPT，那么每一页之间是怎么分割的呢？</p>
                  <p>其实很简单，最常规的，用三条横线分割就好了，比如：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">---</span><br><span class="line">layout: cover</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 第 1 页</span><br><span class="line"></span><br><span class="line">This is the cover page.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 第 2 页</span><br><span class="line"></span><br><span class="line">The second page</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然，除了使用三横线，我们还可以使用更丰富的定义模式，可以给每一页制定一些具体信息，就是使用两层三横线。</p>
                  <p>比如这样：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">---</span><br><span class="line">theme: seriph</span><br><span class="line">layout: cover</span><br><span class="line">background: &#39;https:&#x2F;&#x2F;source.unsplash.com&#x2F;1600x900&#x2F;?nature,water&#39;</span><br><span class="line">---</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>上面这样的配置可以替代三横线，是另一种可以用作页面分隔的写法，借助这种写法我们可以定义更多页面的具体信息。</p>
                  <h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2>
                  <p>当然我们肯定也想给 PPT 添加备注，这个也非常简单，通过注释的形式写到 Markdown 源文件就好了：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">---</span><br><span class="line">layout: cover</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 第 1 页</span><br><span class="line"></span><br><span class="line">This is the cover page.</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是一条备注 --&gt;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里可以看到其实就是用了注释的特定语法。</p>
                  <h2 id="演讲者头像"><a href="#演讲者头像" class="headerlink" title="演讲者头像"></a>演讲者头像</h2>
                  <p>当然还有很多酷炫的功能，比如说，我们在讲 PPT 的时候，可能想同时自己也出镜，Slidev 也可以支持。</p>
                  <p>因为开的是网页，而网页又有捕捉摄像头的功能，所以最终效果可以是这样子：</p>
                  <p><img src="https://cdn.cuiqingcai.com/x3x75.png" alt=""></p>
                  <p>是的没错！右下角就是演讲者的个人头像，它被嵌入到了 PPT 中！是不是非常酷！</p>
                  <h2 id="演讲录制"><a href="#演讲录制" class="headerlink" title="演讲录制"></a>演讲录制</h2>
                  <p>当然，Slidev 还支持演讲录制功能，因为它背后集成了 WebRTC 和 RecordRTC 的 API，一些录制配置如下所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/v1y0a.png" alt=""></p>
                  <p>所以，演讲过程的录制完全不是问题。</p>
                  <p>具体的操作可以查看：<a href="https://sli.dev/guide/recording.html" target="_blank" rel="noopener">https://sli.dev/guide/recording.html</a>。</p>
                  <h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2>
                  <p>当然用 Slidev 写的 PPT 还可以支持部署，因为这毕竟就是一个网页。</p>
                  <p>而且部署非常简单和轻量级，因为这就是一些纯静态的 HTML、JavaScript 文件，我们可以轻松把它部署到 GitHub Pages、Netlify 等站点上。</p>
                  <p><strong>试想这么一个场景：别人在演讲之前还在各种拷贝 PPT，而你打开了一个浏览器直接输入了一个网址，PPT 就出来了，众人惊叹，就问你装不装逼？</strong></p>
                  <p>具体的部署操作可以查看：<a href="https://sli.dev/guide/hosting.html" target="_blank" rel="noopener">https://sli.dev/guide/hosting.html</a></p>
                  <p>让我们看几个别人已经部署好的 PPT，直接网页打开就行了：</p>
                  <ul>
                    <li><a href="https://demo.sli.dev/composable-vue/1" target="_blank" rel="noopener">https://demo.sli.dev/composable-vue</a></li>
                    <li><a href="https://masukin.link/talks/simply-publish-your-package-to-npm/#/1" target="_blank" rel="noopener">https://masukin.link/talks/simply-publish-your-package-to-npm</a></li>
                  </ul>
                  <p>就是这么简单方便。</p>
                  <h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2>
                  <p>什么？你想实现版本控制，那再简单不过了。</p>
                  <p>Markdown 嘛，配合下专业版本管理工具 Git，版本控制再也不是难题。</p>
                  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
                  <p>以上就是对 Slidev 的简单介绍，确实不得不说有些功能真的非常实用，而且我本身特别喜欢 Markdown 和网页开发，所以这个简直对我来说太方便了。</p>
                  <p>如果你感兴趣的话，不妨也来试试吧～</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-01-29 23:50:22" itemprop="dateCreated datePublished" datetime="2022-01-29T23:50:22+08:00">2022-01-29</time>
                </span>
                <span id="/36051.html" class="post-meta-item leancloud_visitors" data-flag-title="用 Markdown 做 PPT，就是这么简单！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>6.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>6 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36050.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/36050.html" class="post-title-link" itemprop="url">两行代码，给 Python 脚本生成命令行</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>有时候我们会有这样的一个需求：</p>
                  <p>我们定义了一个 Python 的方法，方法接收一些参数，但是调用的时候想将这些参数用命令行暴露出来。</p>
                  <p>比如说这里有个爬取方法：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span><span class="params">(url, timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    response = requests.get(url, timeout=timeout)</span><br><span class="line">    print(response.text)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里定义了一个 scrape 方法，第一个参数接收 url，即爬取的网址，第二个参数接收 timeout，即指定超时时间。</p>
                  <p>调用的时候我们可能这么调用：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">scrape(<span class="string">'https:///www.baidu.com'</span>, <span class="number">10</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果我们想改参数换 url，那就得改代码对吧。</p>
                  <p>所以有时候我们就想把这些参数用命令行暴露出来，这时候我们可能就用上了 argparse 等等的库，挨个声明各个参数是干嘛的，非常繁琐，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Scrape Function'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'url'</span>, type=str,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'timeout'</span>,  type=int,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    scrape(args.url, args.timeout)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们才能顺利地使用命令行来调用这个脚本：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 main.py https://www.baidu.com <span class="number">10</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>是不是感觉非常麻烦？argparse 写起来又臭又长，想想就费劲。</p>
                  <h2 id="Fire"><a href="#Fire" class="headerlink" title="Fire"></a>Fire</h2>
                  <p>但接下来我们要介绍一个库，用它我们只需要两行代码就可以做到如上操作。</p>
                  <p>这个库的名字叫做Fire，它可以快速为某个 Python 方法或者类添加命令行的参数支持。</p>
                  <p>先看看安装方法，使用 pip3 安装即可：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 install fire</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就安装好了。</p>
                  <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>
                  <p>下面我们来看几个例子。</p>
                  <h3 id="方法支持"><a href="#方法支持" class="headerlink" title="方法支持"></a>方法支持</h3>
                  <p>第一个代码示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">"World"</span>)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello %s!"</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(hello)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了一个 hello 方法，然后接收一个 name 参数，默认值是 World，接着输出了 Hello 加 name 这个字符串。</p>
                  <p>然后接着我们导入了 fire 这个库，调用它的 Fire 方法并传入 hello 这个方法声明，会发生什么事情呢？</p>
                  <p>我们把这段代码保存为 demo1.py，接着用 Python3 来运行一下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo1.py</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Hello World!</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>看起来并没有什么不同。</p>
                  <p>但我们这时候如果运行如下命令，就可以看到一些神奇的事情了：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo1.py --help</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">NAME</span><br><span class="line">    demo1.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    demo1.py &lt;flags&gt;</span><br><span class="line"></span><br><span class="line">FLAGS</span><br><span class="line">    --name=NAME</span><br><span class="line">        Default: <span class="string">'World'</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里它将 name 这个参数转化成了命令行的一个可选参数，我们可以通过 <code>—-name</code> 来替换 name 参数。</p>
                  <p>我们来试下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo1.py --name <span class="number">123</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们传入了一个 name 参数是 123，这时候我们就发现运行结果就变成了如下内容：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Hello <span class="number">123</span>!</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>是不是非常方便？我们没有借助 argparse 就轻松完成了命令行参数的支持和替换。</p>
                  <p>那如果我们将 name 这个参数的默认值取消呢？代码改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello %s!"</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(hello)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候重新运行：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo1.py --help</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>就可以看到结果变成了如下内容：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">NAME</span><br><span class="line">    demo1.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    demo1.py NAME</span><br><span class="line"></span><br><span class="line">POSITIONAL ARGUMENTS</span><br><span class="line">    NAME</span><br><span class="line"></span><br><span class="line">NOTES</span><br><span class="line">    You can also use flags syntax <span class="keyword">for</span> POSITIONAL ARGUMENTS</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候我们发现 name 这个参数就变成了必传参数，我们必须在命令行里指定这个参数内容，调用就会变成如下命令：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo1.py <span class="number">123</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果还是一样的。</p>
                  <h3 id="类支持"><a href="#类支持" class="headerlink" title="类支持"></a>类支持</h3>
                  <p>当然 fire 这个库不仅仅支持给方法添加命令行的支持，还支持给一个类添加命令行的支持。</p>
                  <p>下面我们再看一个例子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span><span class="params">(object)</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fire.Fire(Calculator)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们把这个代码保存为 demo2.py，然后运行：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo2.py</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">NAME</span><br><span class="line">    demo2.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    demo2.py COMMAND</span><br><span class="line"></span><br><span class="line">COMMANDS</span><br><span class="line">    COMMAND <span class="keyword">is</span> one of the following:</span><br><span class="line"></span><br><span class="line">     double</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里它将 Calculator 这个类中的方法识别出来了，COMMAND 之一就是 double，我们试着调用下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo2.py double</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ERROR: The function received no value <span class="keyword">for</span> the required argument: number</span><br><span class="line">Usage: demo2.py double NUMBER</span><br><span class="line"></span><br><span class="line">For detailed information on this command, run:</span><br><span class="line">  demo2.py double --help</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里就说了，这里必须要指定另外一个参数，叫做 NUMBER，同时这个参数还是必填参数，我们试着加下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 demo2.py double <span class="number">4</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="number">8</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候就可以达到正确结果了。</p>
                  <p>所以说，综合来看，fire 可以为一个类命令行，每个命令都对应一个方法的名称，同时在后面添加额外的可选或必选参数，加到命令行参数的后面。</p>
                  <h2 id="重新改写"><a href="#重新改写" class="headerlink" title="重新改写"></a>重新改写</h2>
                  <p>最后，让我们回过头来，给我们一开始定义的 scrape 方法添加命令行的参数支持：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span><span class="params">(url, timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    response = requests.get(url, timeout=timeout)</span><br><span class="line">    print(response.text)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fire.Fire(scrape)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以了！省去了冗长的 argparse 的代码，是不是非常方便？</p>
                  <p>调用就是如下形式：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">NAME</span><br><span class="line">    main.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    main.py URL &lt;flags&gt;</span><br><span class="line"></span><br><span class="line">POSITIONAL ARGUMENTS</span><br><span class="line">    URL</span><br><span class="line"></span><br><span class="line">FLAGS</span><br><span class="line">    --timeout=TIMEOUT</span><br><span class="line">        Default: <span class="number">10</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里说了，URL 是必传参数，timeout 是可选参数。</p>
                  <p>最后调用下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 main.py https://www.baidu.com</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们就可以轻松将 url 通过命令行传递过去了。</p>
                  <p>当然 timeout 还是可选值，我们可以通过 <code>—-timeout</code> 来指定 timeout 参数：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python3 main.py https://www.baidu.com --timeout <span class="number">5</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样两个参数就都能顺利赋值了，最后效果就是爬取百度，5 秒超时。</p>
                  <p>怎么样？是不是很方便？大家快用起来吧！</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-01-05 18:20:22" itemprop="dateCreated datePublished" datetime="2022-01-05T18:20:22+08:00">2022-01-05</time>
                </span>
                <span id="/36050.html" class="post-meta-item leancloud_visitors" data-flag-title="两行代码，给 Python 脚本生成命令行" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.2k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36049.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 个人随笔 <i class="label-arrow"></i>
                  </a>
                  <a href="/36049.html" class="post-title-link" itemprop="url">做事要有“笃定”的态度</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>之前跟一个朋友聊天，思考到一点，分享一下。</p>
                  <p>我这个朋友在创业，大家知道，创业都是非常艰难的，几乎是九死一生。</p>
                  <p>他创业一年多了，业务现在也挺好的，一直很有拼劲。</p>
                  <p>我就问他是什么让他一直保持这样持续向前向上的状态的。</p>
                  <p>我们聊了很多，但我发现其中有一个很重要的点就是那种笃定的态度，核心就在于两个字，笃定。</p>
                  <p>这个笃定分为两个方面，一个是做事上的笃定，一个是信念上的笃定。</p>
                  <p>分别说说。</p>
                  <ul>
                    <li>关于做事上的笃定。就是能认定了一件事之后，不会轻言放弃或更改，不能今天干了这一点，第二天就换去干另外一个了，也不能看到一点点困难就立即退缩不干了。他说他历经了一些困难的时刻，但经过反复复盘和思考，不断做到了螺旋式上升，现在经验越来越多，做得也越来越顺。所以在做事的时候，内心要有一种笃定的态度，认准了目标不断进发，虽然说努力了不一定成功，但成功几率一定比不努力或直接放弃大的多多多。</li>
                    <li>关于信念上的笃定。就是能够在心中有一种信念，认定做某件事是有意义的有价值的，不会轻易被动摇。现在很多人做事都是，听到别人说做什么做什么挺赚钱，那就跟风去做了。或者做一个产品，他觉得会有市场需求有用户去用，完全迎合用户，但到头来发现是众口难调。真正信念上的笃定是一个人觉得做这件事是真正有意义的，有价值的，那就够了，不会被轻易动摇，不会一味迎合他人。只要他认定的正确的事，那就去做，这就是信念上的笃定。</li>
                  </ul>
                  <p>当然可能有人会反驳了，这么笃定，都不听取别人的意见吗？一味向前冲不是死脑筋吗？这里要解释一下。这里说的笃定是一种广义上的笃定，这种态度信念是要有的，是一种大目标，总体的态度是要这样，但不代表不知变通或者死脑筋。在做具体的事情的时候，肯定还是反思、复盘，去思考什么才是达成大目标的方案，达成大目标的一步步小目标是怎样的，不断提升和完善的过程中慢慢地去接近笃定的大目标，这才是正确的。</p>
                  <p>与君共勉。</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-01-03 13:20:22" itemprop="dateCreated datePublished" datetime="2022-01-03T13:20:22+08:00">2022-01-03</time>
                </span>
                <span id="/36049.html" class="post-meta-item leancloud_visitors" data-flag-title="做事要有“笃定”的态度" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>803</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36048.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/36048.html" class="post-title-link" itemprop="url">在浏览器里面运行命令行，真香！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>上一篇我写过一篇《<a href="https://cuiqingcai.com/36047.html">万物皆可 API</a>》，这个项目就是把一些脚本的执行结果输出到了网页里面。</p>
                  <p>但是这个还是有很多改进空间，比如说 UI 能好看些，甚至能执行交互命令该多好，最后思来想去，它的究极形态不就是一个 Web 版的 Terminal （终端）吗？</p>
                  <p>然后本来我还想着对项目进行改造来着，但是想想，最终如果要改造成一个 Web 版的 Terminal，这个肯定已经有开源实现了。</p>
                  <p>于是我就开始搜，最后搜到几个还不错的。</p>
                  <h2 id="Web-Terminal"><a href="#Web-Terminal" class="headerlink" title="Web Terminal"></a>Web Terminal</h2>
                  <ul>
                    <li>ttyd：<a href="https://github.com/tsl0922/ttyd" target="_blank" rel="noopener">https://github.com/tsl0922/ttyd</a>，一款可以将命令行转到 Web 执行的工具，基于 C 编写的。</li>
                    <li>gotty：<a href="https://github.com/yudai/gotty" target="_blank" rel="noopener">https://github.com/yudai/gotty</a>，和 ttyd 一样，只不过是 Go 语言写的，但最新更新是在 2017 年了，估计失修了。</li>
                    <li>wetty：<a href="https://github.com/butlerx/wetty" target="_blank" rel="noopener">https://github.com/butlerx/wetty</a>，基于 Node.js 开发的，也可以将命令行转到 Web 执行，但是需要基于 SSH 登录，其实就是个 Web 版的 SSH 终端。</li>
                    <li>Secure Shell (Chrome App)：Google 浏览器插件，也可以提供网页版 SSH 终端。</li>
                    <li>tmate：<a href="https://tmate.io/" target="_blank" rel="noopener">https://tmate.io/</a>，从 tmux 修改而来，可以支持 Terminal 分享。</li>
                  </ul>
                  <p>经过一番试用，我个人首推的还是 ttyd，其他的几个要么是基于 SSH 的，要么不怎么好用或停止维护了。</p>
                  <p>下面我就来介绍下 ttyd 的简单用法。</p>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <p>安装其实非常简单，我用的是 Mac，所以用 HomeBrew 直接安装即可：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">brew install ttyd</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果你用的是 Windows、Linux，依然也可以支持，安装可以参考 <a href="https://github.com/tsl0922/ttyd#installation" target="_blank" rel="noopener">https://github.com/tsl0922/ttyd#installation</a> 章节。</p>
                  <h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>
                  <p>ttyd 支持不少功能配置，完整命令如下：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd is a tool <span class="keyword">for</span> sharing terminal over the web</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    ttyd [<span class="type">options</span>] &lt;command&gt; [&lt;<span class="type">arguments...</span>&gt;]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">    <span class="number">1.6</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">    <span class="literal">-p</span>, -<span class="literal">-port</span>              Port to listen (default: <span class="number">7681</span>, use `0` <span class="keyword">for</span> random port)</span><br><span class="line">    <span class="literal">-i</span>, -<span class="literal">-interface</span>         Network interface to bind (eg: eth0), or UNIX domain socket path (eg: /var/run/ttyd.sock)</span><br><span class="line">    <span class="literal">-c</span>, -<span class="literal">-credential</span>        Credential <span class="keyword">for</span> Basic Authentication (format: username:password)</span><br><span class="line">    <span class="literal">-u</span>, -<span class="literal">-uid</span>               User id to run with</span><br><span class="line">    <span class="literal">-g</span>, -<span class="literal">-gid</span>               Group id to run with</span><br><span class="line">    <span class="literal">-s</span>, -<span class="literal">-signal</span>            Signal to send to the command when <span class="keyword">exit</span> it (default: <span class="number">1</span>, SIGHUP)</span><br><span class="line">    <span class="literal">-a</span>, -<span class="literal">-url</span><span class="literal">-arg</span>           Allow client to send command line arguments <span class="keyword">in</span> URL (eg: http://localhost:<span class="number">7681</span>?arg=foo&amp;arg=bar)</span><br><span class="line">    <span class="literal">-R</span>, -<span class="literal">-readonly</span>          <span class="keyword">Do</span> not allow clients to write to the TTY</span><br><span class="line">    <span class="literal">-t</span>, -<span class="literal">-client</span><span class="literal">-option</span>     Send option to client (format: key=value), repeat to add more options</span><br><span class="line">    <span class="literal">-T</span>, -<span class="literal">-terminal</span><span class="literal">-type</span>     Terminal type to report, default: xterm<span class="literal">-256color</span></span><br><span class="line">    <span class="literal">-O</span>, -<span class="literal">-check</span><span class="literal">-origin</span>      <span class="keyword">Do</span> not allow websocket connection from different origin</span><br><span class="line">    <span class="literal">-m</span>, -<span class="literal">-max</span><span class="literal">-clients</span>       Maximum clients to support (default: <span class="number">0</span>, no limit)</span><br><span class="line">    <span class="literal">-o</span>, -<span class="literal">-once</span>              Accept only one client and <span class="keyword">exit</span> on disconnection</span><br><span class="line">    <span class="literal">-B</span>, -<span class="literal">-browser</span>           Open terminal with the default system browser</span><br><span class="line">    <span class="literal">-I</span>, -<span class="literal">-index</span>             Custom index.html path</span><br><span class="line">    <span class="literal">-b</span>, -<span class="literal">-base</span><span class="literal">-path</span>         Expected base path <span class="keyword">for</span> requests coming from a reverse proxy (eg: /mounted/here)</span><br><span class="line">    <span class="literal">-P</span>, -<span class="literal">-ping</span><span class="literal">-interval</span>     Websocket ping interval(sec) (default: <span class="number">300</span>)</span><br><span class="line">    <span class="literal">-6</span>, -<span class="literal">-ipv6</span>              Enable IPv6 support</span><br><span class="line">    <span class="literal">-S</span>, -<span class="literal">-ssl</span>               Enable SSL</span><br><span class="line">    <span class="literal">-C</span>, -<span class="literal">-ssl</span><span class="literal">-cert</span>          SSL certificate file path</span><br><span class="line">    <span class="literal">-K</span>, -<span class="literal">-ssl</span><span class="literal">-key</span>           SSL key file path</span><br><span class="line">    <span class="literal">-A</span>, -<span class="literal">-ssl</span><span class="literal">-ca</span>            SSL CA file path <span class="keyword">for</span> client certificate verification</span><br><span class="line">    <span class="literal">-d</span>, -<span class="literal">-debug</span>             Set log level (default: <span class="number">7</span>)</span><br><span class="line">    <span class="literal">-v</span>, -<span class="literal">-version</span>           Print the version and <span class="keyword">exit</span></span><br><span class="line">    <span class="literal">-h</span>, -<span class="literal">-help</span>              Print this text and <span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">Visit https://github.com/tsl0922/ttyd to get more information and report bugs.</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到，这里可以使用 -p 来指定运行端口，使用 -c 指定登录密码等等。</p>
                  <h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3>
                  <p>我们来试下，最基本的命令如下：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd bash</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就使用启动了一个 Web 版的 bash，运行结果如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/addfi.png" alt=""></p>
                  <p>这里显示是在 7681 上运行的，那我们就可以打开 <a href="http://localhost:7681/" target="_blank" rel="noopener">http://localhost:7681/</a>，就可以直接运行命令了：</p>
                  <p><img src="https://cdn.cuiqingcai.com/esx37.png" alt=""></p>
                  <p>非常丝滑。</p>
                  <p>看了下背后的传输协议是 WebSocket，所以稳定性还是有保障的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/54o5p.png" alt=""></p>
                  <p>当然，我们也可以不用 bash，用自己喜欢的 Shell，比如 zsh，命令如下：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd zsh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样的话浏览器里面的 Shell 就是 zsh 啦：</p>
                  <p><img src="https://cdn.cuiqingcai.com/b0f9k.png" alt=""></p>
                  <h3 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h3>
                  <p>当然我们也可以更换端口，比如 8000，则可以使用如下命令：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd <span class="literal">-p</span> <span class="number">8000</span> zsh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样 ttyd 就可以在 8000 端口运行 HTTP 服务，我们打开 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 就可以执行命令了。</p>
                  <h3 id="Basic-Auth"><a href="#Basic-Auth" class="headerlink" title="Basic Auth"></a>Basic Auth</h3>
                  <p>当然这么直接暴露出去似乎也不太安全，我们可以设置 Basic Auth，使用 -c 这个选项即可指定用户名密码，格式为 <code>username:password</code>，例如我们指定用户名和密码都是 admin，那命令就这么写：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd <span class="literal">-p</span> <span class="number">8000</span> <span class="literal">-c</span> admin:admin zsh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样打开 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 之后就需要输入用户名密码才可以登录了：</p>
                  <p><img src="https://cdn.cuiqingcai.com/6mu2o.png" alt=""></p>
                  <h3 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h3>
                  <p>我们还可以使用 -B 命令让它自动打开浏览器：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd <span class="literal">-p</span> <span class="number">8000</span> <span class="literal">-B</span> zsh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样运行之后，默认的浏览器就会自动打开 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a>，不用我们再去敲网址了，十分方便。</p>
                  <p>所以，上面这个命令甚至我们还可以做成一个 alias，比如：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">alias webcmd=<span class="string">"ttyd -p 8000 -B zsh"</span>;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样输入 <code>webcmd</code> 就可以轻松打开一个 Web 版命令行了。</p>
                  <h3 id="Docker-支持"><a href="#Docker-支持" class="headerlink" title="Docker 支持"></a>Docker 支持</h3>
                  <p>另外 ttyd 还提供了 Docker 镜像，如果你不想安装的话，可以直接启 Docker，比如这样的话就可以在 7681 上启动：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">docker run <span class="literal">-it</span> -<span class="literal">-rm</span> <span class="literal">-p</span> <span class="number">7681</span>:<span class="number">7681</span> tsl0922/ttyd</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>但这实际上是把容器内部的命令行暴露出来了，如果要暴露宿主机的命令行还需要 mount 下磁盘：</p>
                  <h3 id="SSH-终端"><a href="#SSH-终端" class="headerlink" title="SSH 终端"></a>SSH 终端</h3>
                  <p>ttyd 还支持 SSH 终端，命令如下：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ttyd login</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样的话，打开浏览器之后就需要 SSH 登录，输入正确的 SSH 用户名和密码后才能使用。</p>
                  <h3 id="SSL-支持"><a href="#SSL-支持" class="headerlink" title="SSL 支持"></a>SSL 支持</h3>
                  <p>如果你想配置 SSL 支持，即支持 HTTPS 的话，可以自己生成证书并添加对应的参数来启动 ttyd，参考链接是：<a href="https://github.com/tsl0922/ttyd/wiki/SSL-Usage" target="_blank" rel="noopener">https://github.com/tsl0922/ttyd/wiki/SSL-Usage</a>。</p>
                  <h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3>
                  <p>上面的用法基本能满足日常需要了，如果想要了解更多用法，可以参考其 Wiki，链接是：<a href="https://github.com/tsl0922/ttyd/wiki/Example-Usage" target="_blank" rel="noopener">https://github.com/tsl0922/ttyd/wiki/Example-Usage</a>。</p>
                  <h2 id="公网暴露"><a href="#公网暴露" class="headerlink" title="公网暴露"></a>公网暴露</h2>
                  <p>当然，我们如果想把它公网暴露出来，还可以配合 Ngrok，比如 ttyd 运行在 8000 端口上，我可以使用 Ngrok 将其暴露出来：</p>
                  <figure class="highlight powershell">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">ngrok http <span class="number">8000</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/pi1ri.png" alt=""></p>
                  <p>这样我就可以通过指定的 URL 访问这个终端了，比如这里我就可以使用 <a href="https://11b4-2404-f801-8050-3-bf-00-55.ngrok.io/" target="_blank" rel="noopener">https://11b4-2404-f801-8050-3-bf-00-55.ngrok.io/</a> 来访问我的终端了：</p>
                  <p><img src="https://cdn.cuiqingcai.com/sc0lx.png" alt=""></p>
                  <p>非常 Nice！</p>
                  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
                  <p>好了，以上就是 ttyd 的基本使用了，有了它，我们就可以轻松将某台机器上的终端转到 Web 上来执行了，还是非常方便有用的。</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-01-03 01:50:22" itemprop="dateCreated datePublished" datetime="2022-01-03T01:50:22+08:00">2022-01-03</time>
                </span>
                <span id="/36048.html" class="post-meta-item leancloud_visitors" data-flag-title="在浏览器里面运行命令行，真香！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36047.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/36047.html" class="post-title-link" itemprop="url">万物皆可 API</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>今天看到一个开源项目，叫做 Command2API，感觉挺有意思的，分享给大家。</p>
                  <h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2>
                  <p>关于这个项目为什么诞生，原 Repo 有这么一段：</p>
                  <blockquote>
                    <p>以近期 Log4j 的 RCE 举例，在内网的安全测试中，由于网络环境限制导致没有 DNSLog 平台可用，这时候做 Log4j 的漏洞验证就考虑直接查看 LDAP 服务是否有连接进来，但是现成的 JNDI 注入工具开启服务并没有 API 可以直接拉取对应服务的结果，这就导致需要人工去查看，很费时间，再加上已经写好 BurpSuite 被动插件进行扫描了，为了节省时间就简单写了这个脚本用于获取 JNDI 工具的执行结果并通过 API 的形式返回，便于插件拉取结果进行漏洞验证。</p>
                  </blockquote>
                  <p>反正大意就是说，有些命令的执行结果如果能够通过 HTTP 的 API 暴露出来，我们就能更方便地获取到命令的执行结果，在某些场景下会非常方便。</p>
                  <p>所以，这里作者写了这个项目。</p>
                  <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>
                  <p>这个原理其实非常简单，就是用一个 Python 线程开启 Web 服务，一个线程执行命令，通过全局变量与 Web 服务共享执行命令的结果。</p>
                  <h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2>
                  <p>这里我们来运行下看看效果吧。</p>
                  <p>首先需要下载下项目：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">git clone https://github.com/gh0stkey/Command2API.git</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>然后接着指定想运行的命令和 API 运行的端口就好了，样例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python Command2Api.py <span class="string">"执行的命令"</span> Web运行的端口</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <blockquote>
                    <p>注意，这里的 python 使用的 Python2，而不是 Python3，因为原项目引用了一个包叫 BaseHTTPServer，Python3 是没有的。</p>
                  </blockquote>
                  <p>这里我们执行一个 ping 命令来试试：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">python Command2Api.py <span class="string">"ping www.baidu.com"</span> <span class="number">8888</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/1sspx.png" alt=""></p>
                  <p>可以看到，这里首先输出了一个运行的地址：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">URL: http://HOST:<span class="number">8888</span>/c1IvlLF9</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候我们打开 <a href="http://localhost:8888/c1IvlLF9" target="_blank" rel="noopener">http://localhost:8888/c1IvlLF9</a> 看下。</p>
                  <p><img src="https://cdn.cuiqingcai.com/kcl2f.png" alt=""></p>
                  <p>可以看到控制台结果就呈现在网页里面了。</p>
                  <blockquote>
                    <p>但是这个页面没法自动刷新，需要点击刷新来获取最新的结果。</p>
                  </blockquote>
                  <p>介绍完了。</p>
                  <p>所以，这个项目在某些情况下还是挺有用的。</p>
                  <p>比如说：</p>
                  <ul>
                    <li>内网安全测试中，可以用于获取 JNDI 工具的执行结果并通过 API 的形式返回，可以更方便地观测执行结果。</li>
                    <li>我们想监控或实时获取某个命令行程序的输出结果，比如 Scrapy 爬虫、比如 Web Server 等等，可以将其暴露出来。</li>
                    <li>我们想快速分享某个程序的执行结果，则可以通过这个命令配合 Ngrok 生成一个网站分享出去。</li>
                  </ul>
                  <p>等等。</p>
                  <h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2>
                  <p>我们再来看看源码吧，其实非常简单，一共就这些代码：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> BaseHTTPServer</span><br><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line">uri = <span class="string">'/'</span> + <span class="string">''</span>.join(random.sample(string.ascii_letters+string.digits,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threadname, command)</span>:</span></span><br><span class="line">    threading.Thread.__init__(self, name=<span class="string">'Thread_'</span> + threadname)</span><br><span class="line">    self.threadname = int(threadname)</span><br><span class="line">    self.command = command</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> l</span><br><span class="line">    ret = subprocess.Popen(</span><br><span class="line">      self.command,</span><br><span class="line">      shell=<span class="literal">True</span>,</span><br><span class="line">      stdin=subprocess.PIPE,</span><br><span class="line">      stdout=subprocess.PIPE,</span><br><span class="line">      stderr=subprocess.PIPE</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iter(ret.stdout.readline, <span class="string">b""</span>):</span><br><span class="line">      res = i.decode().strip()</span><br><span class="line">      print(res)</span><br><span class="line">      l.append(res)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span><span class="params">(SimpleHTTPServer.SimpleHTTPRequestHandler)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> l</span><br><span class="line">    <span class="keyword">if</span> self.path == uri:</span><br><span class="line">      self.send_response(<span class="number">200</span>)</span><br><span class="line">      self.send_header(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)</span><br><span class="line">      self.end_headers()</span><br><span class="line">      self.wfile.write(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># New Thread: Get Command Result</span></span><br><span class="line">  t1 = thread(<span class="string">'1'</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line">  t1.start()</span><br><span class="line">  <span class="comment"># Webserver</span></span><br><span class="line">  port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">  print(<span class="string">"URL: http://HOST:&#123;0&#125;&#123;1&#125;"</span>.format(port, uri))</span><br><span class="line">  Handler = ServerHandler</span><br><span class="line">  httpd = BaseHTTPServer.HTTPServer((<span class="string">'0.0.0.0'</span>, port), Handler)</span><br><span class="line">  httpd.serve_forever()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到这个命令就是 Popen 执行的，然后通过 PIPE 将结果捕获出来赋值为变量，然后同时另外一个线程启动服务器，将这个结果写入到 Response 里面。</p>
                  <p>就是这么简单的代码，实现了如此便捷的功能。</p>
                  <h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2>
                  <p>不过我看这个项目还是有很多优化空间的，简单总结下：</p>
                  <ul>
                    <li>现在支持的是 Python2 而不是 Python3。</li>
                    <li>网页结果不能自动刷新。</li>
                    <li>网页结果是一个列表，和控制台的结果格式不太统一。</li>
                    <li>不能通过 pip 来安全这个工具包。</li>
                    <li>输出结果的 HOST 可以优化一下，直接复制出来不好访问。</li>
                    <li>可以配合 Ngrok 将结果进行公开暴露。</li>
                    <li>如果能通过网页来对命令进行交互控制就更好了。</li>
                  </ul>
                  <p>我看看如果有时间的话，我可以试着将这个项目改写下并实现如上的一些优化功能哈，到时候写完了发出来。</p>
                  <p>谢谢阅读～</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2022-01-02 19:50:22" itemprop="dateCreated datePublished" datetime="2022-01-02T19:50:22+08:00">2022-01-02</time>
                </span>
                <span id="/36047.html" class="post-meta-item leancloud_visitors" data-flag-title="万物皆可 API" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.6k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36044.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 深度学习 <i class="label-arrow"></i>
                  </a>
                  <a href="/36044.html" class="post-title-link" itemprop="url">深度学习识别滑动验证码</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>本节我们就来了解下使用深度学习识别滑动验证码的方法。</p>
                  <h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2>
                  <p>我们这次主要侧重于完成利用深度学习模型来识别验证码缺口的过程，所以不会侧重于讲解深度学习模型的算法，另外由于整个模型实现较为复杂，本节也不会从零开始编写代码，而是倾向于把代码提前下载下来进行实操练习。</p>
                  <p>所以在最后，请提前代码下载下来，仓库地址为：<a href="https://github.com/Python3WebSpider/DeepLearningSlideCaptcha2，利用" target="_blank" rel="noopener">https://github.com/Python3WebSpider/DeepLearningSlideCaptcha2，利用</a> Git 把它克隆下来：</p>
                  <figure class="highlight crmsh">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/Python3WebSpider/DeepLearningSlideCaptcha2.git</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行完毕之后，本地就会出现一个 DeepLearningImageCaptcha2 的文件夹，就证明克隆成功了。</p>
                  <p>克隆完毕之后，请切换到 DeepLearningImageCaptcha2 文件夹，安装必要的依赖库：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> -r requirements.txt</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行完毕之后，本项目运行所需要的依赖库就全部安装好了。</p>
                  <p>以上准备工作都完成之后，那就让我们就开始本节正式的学习吧。</p>
                  <h2 id="2-目标检测"><a href="#2-目标检测" class="headerlink" title="2. 目标检测"></a>2. 目标检测</h2>
                  <p>识别滑动验证码缺口的这个问题，其实可以归结为目标检测问题。那什么叫目标检测呢？在这里简单作下介绍。</p>
                  <p>目标检测，顾名思义，就是把我们想找的东西找出来。比如给一张「狗」的图片，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/4fre2.png" alt="image-20191107024841075"></p>
                  <p>我们想知道这只狗在哪，它的舌头在哪，找到了就把它们框选出来，这就是目标检测。</p>
                  <p>经过目标检测算法处理之后，我们期望得到的图片是这样的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/i867f.png" alt="image-20191107025008947"></p>
                  <p>可以看到这只狗和它的舌头就被框选出来了，这就完成了一个不错的目标检测。</p>
                  <p>现在比较流行的目标检测算法有 R-CNN、Fast R-CNN、Faster R-CNN、SSD、YOLO 等，感兴趣可以了解一下，当然不太了解对本节要完成的目标也没有什么影响。</p>
                  <p>当前做目标检测的算法主要有两种方法，有一阶段式和两阶段式，英文叫做 One stage 和 Two stage，简述如下：</p>
                  <ul>
                    <li>Two Stage：算法首先生成一系列目标所在位置的候选框，然后再对这些框选出来的结果进行样本分类，即先找出来在哪，然后再分出来是啥，俗话说叫「看两眼」，这种算法有 R-CNN、Fast R-CNN、Faster R-CNN 等，这些算法架构相对复杂，但准确率上有优势。</li>
                    <li>One Stage：不需要产生候选框，直接将目标定位和分类的问题转化为回归问题，俗话说叫「看一眼」，这种算法有 YOLO、SSD，这些算法虽然准确率上不及 Two stage，但架构相对简单，检测速度更快。</li>
                  </ul>
                  <p>所以这次我们选用 One Stage 的有代表性的目标检测算法 YOLO 来实现滑动验证码缺口的识别。</p>
                  <p>YOLO，英文全称叫做 You Only Look Once，取了它们的首字母就构成了算法名，</p>
                  <p>目前 YOLO 算法最新的版本是 V5 版本，应用比较广泛的是 V3 版本，这里算法的具体流程我们就不过多介绍了，感兴趣的可以搜一下相关资料了解下，另外也可以了解下 YOLO V1-V3 版本的不同和改进之处，这里列几个参考链接：</p>
                  <ul>
                    <li>YOLO V3 论文：<a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" target="_blank" rel="noopener">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a></li>
                    <li>YOLO V3 介绍：<a href="https://zhuanlan.zhihu.com/p/34997279" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34997279</a></li>
                    <li>YOLO V1-V3 对比介绍：<a href="https://www.cnblogs.com/makefile/p/yolov3.html" target="_blank" rel="noopener">https://www.cnblogs.com/makefile/p/yolov3.html</a></li>
                  </ul>
                  <h2 id="3-数据准备"><a href="#3-数据准备" class="headerlink" title="3. 数据准备"></a>3. 数据准备</h2>
                  <p>像上一节介绍的一样，要训练深度学习模型也需要准备训练数据，数据也是分为两部分，一部分是验证码图像，另一部分是数据标注，即缺口的位置。但和上一节不一样的是，这次标注不再是单纯的验证码文本了，因为这次我们需要表示的是缺口的位置，缺口对应的是一个矩形框，要表示一个矩形框，至少需要四个数据，如左上角点的横纵坐标 x、y，矩形的宽高 w、h，所以标注数据就变成了四个数字。</p>
                  <p>所以，接下来我们就需要准备一些验证码图片和对应的四位数字的标注了，比如下图的滑动验证码：</p>
                  <p><img src="https://cdn.cuiqingcai.com/9s7ms.png" alt=""></p>
                  <p>好，那接下来我们就完成这两步吧，第一步就是收集验证码图片，第二步就是标注缺口的位置并转为我们想要的四位数字。</p>
                  <p>在这里我们的示例网站是 <a href="https://captcha1.scrape.center/，打开之后点击登录按钮便会弹出一个滑动验证码，如图所示：" target="_blank" rel="noopener">https://captcha1.scrape.center/，打开之后点击登录按钮便会弹出一个滑动验证码，如图所示：</a></p>
                  <p><img src="https://cdn.cuiqingcai.com/b0tqg.png" alt="image-20210504182925384"></p>
                  <p>我们需要做的就是单独将滑动验证码的图像保存下来，也就是这个区域：</p>
                  <p><img src="https://cdn.cuiqingcai.com/3ihk2.png" alt="image-20210504183039997"></p>
                  <p>怎么做呢？靠手工截图肯定不太可靠，费时费力，而且不好准确定位边界，会导致存下来的图片有大有小。为了解决这个问题，我们可以简单写一个脚本来实现下自动化裁切和保存，就是仓库中的 collect.py 文件，代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line">COUNT = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, COUNT + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser = webdriver.Chrome()</span><br><span class="line">        wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">        browser.get(<span class="string">'https://captcha1.scrape.center/'</span>)</span><br><span class="line">        button = wait.until(EC.element_to_be_clickable(</span><br><span class="line">            (By.CSS_SELECTOR, <span class="string">'.el-button'</span>)))</span><br><span class="line">        button.click()</span><br><span class="line">        captcha = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.CSS_SELECTOR, <span class="string">'.geetest_slicebg.geetest_absolute'</span>)))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        captcha.screenshot(<span class="string">f'data/captcha/images/captcha_<span class="subst">&#123;i&#125;</span>.png'</span>)</span><br><span class="line">    <span class="keyword">except</span> WebDriverException <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f'webdriver error occurred <span class="subst">&#123;e.msg&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们先定义了一个循环，循环次数为 COUNT 次，每次循环都使用 Selenium 启动一个浏览器，然后打开目标网站，模拟点击登录按钮触发验证码弹出，然后截取验证码对应的节点，再用 screenshot 方法将其保存下来。</p>
                  <p>我们将其运行：</p>
                  <figure class="highlight vim">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">python3</span> collect.<span class="keyword">py</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行完了之后我们就可以在 <code>data/captcha/images/</code> 目录获得很多验证码图片了，样例如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/plwov.png" alt="image-20210504194022826"></p>
                  <p>获得验证码图片之后，我们就需要进行数据标注了，这里推荐的工具是 labelImg，GitHub 地址为 <a href="https://github.com/tzutalin/labelImg，使用" target="_blank" rel="noopener">https://github.com/tzutalin/labelImg，使用</a> pip3 安装即可：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> labelImg</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>安装完成之后可以直接命令行运行：</p>
                  <figure class="highlight ebnf">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">labelImg</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就成功启动了 labelImg：</p>
                  <p><img src="https://cdn.cuiqingcai.com/sagzl.png" alt="image-20210504194644729"></p>
                  <p>点击 <code>Open Dir</code> 打开 <code>data/captcha/images/</code> 目录，然后点击左下角的 <code>Create RectBox</code> 创建一个标注框，我们可以将缺口所在的矩形框框选出来，框选完毕之后 labelImg 就会提示保存一个名称，我们将其命名为 target，然后点击 OK，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/1eqpy.png" alt="image-20210504194608969"></p>
                  <p>这时候我们可以发现其保存了一个 xml 文件，内容如下：</p>
                  <figure class="highlight xml">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">folder</span>&gt;</span>images<span class="tag">&lt;/<span class="name">folder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filename</span>&gt;</span>captcha_0.png<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">path</span>&gt;</span>data/captcha/images/captcha_0.png<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">database</span>&gt;</span>Unknown<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">width</span>&gt;</span>520<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">height</span>&gt;</span>320<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">segmented</span>&gt;</span>0<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>target<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pose</span>&gt;</span>Unspecified<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmin</span>&gt;</span>321<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymin</span>&gt;</span>87<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmax</span>&gt;</span>407<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymax</span>&gt;</span>167<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>其中可以看到 size 节点里有三个节点，分别是 width、height、depth，分别代表原验证码图片的宽度、高度、通道数。另外 object 节点下的 bndbox 节点就包含了标注缺口的位置，通过观察对比可以知道 xmin、ymin 指的就是左上角的坐标，xmax、ymax 指的就是右下角的坐标。</p>
                  <p>我们可以用下面的方法简单进行下数据处理：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> xmltodict</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_xml</span><span class="params">(file)</span>:</span></span><br><span class="line">    xml_str = open(file, encoding=<span class="string">'utf-8'</span>).read()</span><br><span class="line">    data = xmltodict.parse(xml_str)</span><br><span class="line">    data = json.loads(json.dumps(data))</span><br><span class="line">    annoatation = data.get(<span class="string">'annotation'</span>)</span><br><span class="line">    width = int(annoatation.get(<span class="string">'size'</span>).get(<span class="string">'width'</span>))</span><br><span class="line">    height = int(annoatation.get(<span class="string">'size'</span>).get(<span class="string">'height'</span>))</span><br><span class="line">    bndbox = annoatation.get(<span class="string">'object'</span>).get(<span class="string">'bndbox'</span>)</span><br><span class="line">    box_xmin = int(bndbox.get(<span class="string">'xmin'</span>))</span><br><span class="line">    box_xmax = int(bndbox.get(<span class="string">'xmax'</span>))</span><br><span class="line">    box_ymin = int(bndbox.get(<span class="string">'ymin'</span>))</span><br><span class="line">    box_ymax = int(bndbox.get(<span class="string">'ymax'</span>))</span><br><span class="line">    box_width = (box_xmax - box_xmin) / width</span><br><span class="line">    box_height = (box_ymax - box_ymin) / height</span><br><span class="line">    <span class="keyword">return</span> box_xmin / width, box_ymin / height, box_width / width, box_height / height</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们定义了一个 parse_xml 方法，这个方法首先读取了 xml 文件，然后使用 xmltodict 库就可以将 XML 字符串转为 JSON，然后依次读取出验证码的宽高信息，缺口的位置信息，最后返回了想要的数据格式—— 缺口左上角的坐标和宽高相对值，以元组的形式返回。</p>
                  <p>都标注完成之后，对每个 xml 文件调用此方法便可以生成想要的标注结果了。</p>
                  <p>在这里，我已经将对应的标注结果都处理好了，可以直接使用，路径为 data/captcha/labels，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/j358p.png" alt="image-20210504200730482"></p>
                  <p>每个 txt 文件对应一张验证码图的标注结果，内容类似如下：</p>
                  <figure class="highlight basic">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">0 </span><span class="number">0.6153846153846154</span> <span class="number">0.275</span> <span class="number">0.16596774</span> <span class="number">0.24170968</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一位 0 代表标注目标的索引，由于我们只需要检测一个缺口，所以索引就是 0；第 2、3 位代表缺口的左上角的位置，比如 0.615 则代表缺口左上角的横坐标在相对验证码的 61.5% 处，乘以验证码的宽度 520，结果大约就是 320，即左上角偏移值是 320 像素；第 4、5 代表缺口的宽高相对验证码图片的占比，比如第 5 位 0.24 乘以验证码的高度 320，结果大约是 77，即缺口的高度大约为 77 像素。</p>
                  <p>好了，到此为止数据准备阶段就完成了。</p>
                  <h2 id="4-训练"><a href="#4-训练" class="headerlink" title="4. 训练"></a>4. 训练</h2>
                  <p>为了更好的训练效果，我们还需要下载一些预训练模型。预训练的意思就是已经有一个提前训练过的基础模型了，我们可以直接使用提前训练好的模型里面的权重文件，我们就不用从零开始训练了，只需要基于之前的模型进行微调就好了，这样既可以节省训练时间，又可以有比较好的效果。</p>
                  <p>YOLOV3 的训练要加载预训练模型才能有不错的训练效果，预训练模型下载命令如下：</p>
                  <figure class="highlight arduino">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">bash <span class="built_in">prepare</span>.sh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <blockquote>
                    <p>注意：在 Windows 下请使用 Bash 命令行工具如 Git Bash 来运行此命令。</p>
                  </blockquote>
                  <p>执行这个脚本，就能下载 YOLO V3 模型的一些权重文件，包括 yolov3 和 weights 还有 darknet 的 weights，在训练之前我们需要用这些权重文件初始化 YOLO V3 模型。</p>
                  <p>接下来就可以开始训练了，执行如下脚本：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">bash </span>train.sh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <blockquote>
                    <p>注意：在 Windows 下请同样使用 Bash 命令行工具如 Git Bash 来运行此命令。</p>
                  </blockquote>
                  <p>同样推荐使用 GPU 进行训练，训练过程中我们可以使用 TensorBoard 来看看 loss 和 mAP 的变化，运行 TensorBoard：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">tensorboard --logdir=<span class="string">'logs'</span> --port=<span class="number">6006</span> --host <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <blockquote>
                    <p>注意：请确保已经正确安装了本项目的所有依赖库，其中就包括 TensorBoard，安装成功之后便可以使用 tensorboard 命令。</p>
                  </blockquote>
                  <p>运行此命令后可以在 <a href="http://localhost:6006" target="_blank" rel="noopener">http://localhost:6006</a> 观察到训练过程中的 loss 变化。</p>
                  <p>loss_1 变化类似如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/qrowq.png" alt="loss 变化"></p>
                  <p>val_mAP 变化类似如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/pylwj.png" alt="mAP 变化"></p>
                  <p>可以看到 loss 从最初的非常高下降到了很低，准确率也逐渐接近 100%。</p>
                  <p>这是训练过程中的命令行的一些输出结果：</p>
                  <figure class="highlight gherkin">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">---- [Epoch 99/100, Batch 27/29] ----</span><br><span class="line">+------------+--------------+--------------+--------------+</span><br><span class="line">|<span class="string"> Metrics    </span>|<span class="string"> YOLO Layer 0 </span>|<span class="string"> YOLO Layer 1 </span>|<span class="string"> YOLO Layer 2 </span>|</span><br><span class="line">+------------+--------------+--------------+--------------+</span><br><span class="line">|<span class="string"> grid_size  </span>|<span class="string"> 14           </span>|<span class="string"> 28           </span>|<span class="string"> 56           </span>|</span><br><span class="line">|<span class="string"> loss       </span>|<span class="string"> 0.028268     </span>|<span class="string"> 0.046053     </span>|<span class="string"> 0.043745     </span>|</span><br><span class="line">|<span class="string"> x          </span>|<span class="string"> 0.002108     </span>|<span class="string"> 0.005267     </span>|<span class="string"> 0.008111     </span>|</span><br><span class="line">|<span class="string"> y          </span>|<span class="string"> 0.004561     </span>|<span class="string"> 0.002016     </span>|<span class="string"> 0.009047     </span>|</span><br><span class="line">|<span class="string"> w          </span>|<span class="string"> 0.001284     </span>|<span class="string"> 0.004618     </span>|<span class="string"> 0.000207     </span>|</span><br><span class="line">|<span class="string"> h          </span>|<span class="string"> 0.000594     </span>|<span class="string"> 0.000528     </span>|<span class="string"> 0.000946     </span>|</span><br><span class="line">|<span class="string"> conf       </span>|<span class="string"> 0.019700     </span>|<span class="string"> 0.033624     </span>|<span class="string"> 0.025432     </span>|</span><br><span class="line">|<span class="string"> cls        </span>|<span class="string"> 0.000022     </span>|<span class="string"> 0.000001     </span>|<span class="string"> 0.000002     </span>|</span><br><span class="line">|<span class="string"> cls_acc    </span>|<span class="string"> 100.00%      </span>|<span class="string"> 100.00%      </span>|<span class="string"> 100.00%      </span>|</span><br><span class="line">|<span class="string"> recall50   </span>|<span class="string"> 1.000000     </span>|<span class="string"> 1.000000     </span>|<span class="string"> 1.000000     </span>|</span><br><span class="line">|<span class="string"> recall75   </span>|<span class="string"> 1.000000     </span>|<span class="string"> 1.000000     </span>|<span class="string"> 1.000000     </span>|</span><br><span class="line">|<span class="string"> precision  </span>|<span class="string"> 1.000000     </span>|<span class="string"> 0.800000     </span>|<span class="string"> 0.666667     </span>|</span><br><span class="line">|<span class="string"> conf_obj   </span>|<span class="string"> 0.994271     </span>|<span class="string"> 0.999249     </span>|<span class="string"> 0.997762     </span>|</span><br><span class="line">|<span class="string"> conf_noobj </span>|<span class="string"> 0.000126     </span>|<span class="string"> 0.000158     </span>|<span class="string"> 0.000140     </span>|</span><br><span class="line">+------------+--------------+--------------+--------------+</span><br><span class="line">Total loss 0.11806630343198776</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里显示了训练过程中各个指标的变化情况，如 loss、recall、precision、confidence 等，分别代表训练过程的损失（越小越好）、召回率（能识别出的结果占应该识别出结果的比例，越高越好）、精确率（识别出的结果中正确的比率，越高越好）、置信度（模型有把握识别对的概率，越高越好），可以作为参考。</p>
                  <h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2>
                  <p>训练完毕之后会在 checkpoints 文件夹生成 pth 文件，这就是一些模型文件，和上一节的 best_model.pkl 是一样的原理，只不过表示形式略有不同，我们可直接使用这些模型来预测生成标注结果。</p>
                  <p>要运行测试，我们可以先在测试文件夹 <code>data/captcha/test</code> 放入一些验证码图片：</p>
                  <p>样例验证码如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/xwqzr.png" alt="captcha_435"></p>
                  <p>要运行测试，执行如下脚本：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">bash </span>detect.sh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>该脚本会读取测试文件夹所有图片，并将处理后的结果输出到 <code>data/captcha/result</code> 文件夹，控制台输出了一些验证码的识别结果。</p>
                  <p>同时在 <code>data/captcha/result</code> 生成了标注的结果，样例如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/8ax68.png" alt=""></p>
                  <p>可以看到，缺口就被准确识别出来了。</p>
                  <p>实际上，detect.sh 是执行了 detect.py 文件，在代码中有一个关键的输出结果如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">bbox = patches.Rectangle((x1 + box_w / <span class="number">2</span>, y1 + box_h / <span class="number">2</span>), box_w, box_h, linewidth=<span class="number">2</span>, edgecolor=color, facecolor=<span class="string">"none"</span>)</span><br><span class="line">print(<span class="string">'bbox'</span>, (x1, y1, box_w, box_h), <span class="string">'offset'</span>, x1)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 bbox 指的就是最终缺口的轮廓位置，同时 x1 就是指的轮廓最左侧距离整个验证码最左侧的横向偏移量，即 offset。通过这两个信息，我们就能得到缺口的关键位置了。</p>
                  <p>有了目标滑块位置之后，我们便可以进行一些模拟滑动操作从而实现通过验证码的检测了。</p>
                  <h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2>
                  <p>本节主要介绍了训练深度学习模型来识别滑动验证码缺口的整体流程，最终我们成功实现了模型训练过程，并得到了一个深度学习模型文件。</p>
                  <p>利用这个模型，我们可以输入一张滑动验证码，模型便会预测出其中的缺口的位置，包括偏移量、宽度等，最后可以通过缺口的信息绘制出对应的位置。</p>
                  <p>和上一节一样，本节介绍的内容也可以进一步优化：</p>
                  <ul>
                    <li>当前模型的预测过程是通过命令行执行的，但在实际使用的时候可能并不太方便，可以考虑将预测过程对接 API 服务器暴露出来，比如对接 Flask、Django、FastAPI 等把预测过程实现为一个支持 POST 请求的接口，接口可以接收一张验证码图片，返回验证码的文本信息，这样会使得模型更加方便易用。</li>
                  </ul>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/DeepLearningSlideCaptcha2。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/DeepLearningSlideCaptcha2。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-12-31 02:39:41" itemprop="dateCreated datePublished" datetime="2021-12-31T02:39:41+08:00">2021-12-31</time>
                </span>
                <span id="/36044.html" class="post-meta-item leancloud_visitors" data-flag-title="深度学习识别滑动验证码" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>7.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>7 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36046.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 个人随笔 <i class="label-arrow"></i>
                  </a>
                  <a href="/36046.html" class="post-title-link" itemprop="url">想想做事的终局</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>之前跟一位朋友聊天，他说了有一点让我触动很大，这里专门来写写。</p>
                  <p>就我个人来讲，我在我的这个年纪一直在尝试各种各样的事情，除了工作之外，我还尝试了多种副业，比如写公众号、写书、录课、做视频、写各种开源项目等等，其实整体说来，还是比较“杂”的。</p>
                  <p>他给了我一个建议，叫做“想想做事的终局”，我感觉挺有道理的。</p>
                  <p>下面是我的一些思考。</p>
                  <p>其实年轻多尝试没有什么坏事，比如在三十岁之前，我们可能并不清楚我们真正擅长的或喜欢的到底是什么，所以就得多尝试不同的方向，探索一些未知的领域。找到真正喜欢或者适合的事情之后，后面的几十年可以潜心放在这上面，深入去发展它。</p>
                  <p>当然很多时候，我们可能并不知道我们在做的这件事以后究竟会是怎样的，这里面有两个方面：</p>
                  <ul>
                    <li>验证这件事究竟合不合适、能不能做</li>
                    <li>思考这件事以后到底能做到什么地步</li>
                  </ul>
                  <p>这里针对这两点分别说下。</p>
                  <p>首先就是验证这件事究竟合不合适、能不能做。我们比较好的办法就是进行快速试错，比如一个项目，我们做一些 POC 来验证可行性，或者前期调研的时候通过调查问卷了解行情，这些都是十分重要的。另外我们也不能想当然，比如做一件事情之前，凭空一想就把自己否定了，那就会少掉很多机会。该行动还是要行动的，但前期也要尽量控制一些成本。</p>
                  <p>另外一个重要的就是想想这件事到底能做到什么地步，也就是终局在哪里。比如说，一件事，它本身的可扩展性、可复用性就很小，这个就得好好考虑下要不要投入大的成本一直做下去。如果一件事投入很多的精力，以后可做的事情非常多，或者能做的很大很大，甚至无限大，这种事情就值得多去投入些。比如说，我做一个开源项目，投入大量精力，最后的用户可能就是很有限的，而且场景也很有限，那这个以后就做不大。如果我写作、课程，如果我能把我学习和进步的都输出出来，不断积累，那以后的扩展的面就会有很多很多，这种相对来说就能做大。这就是一些事的终局。所以，平时我们也需要考虑下这件事的终局在哪里。</p>
                  <p>嗯，总之，找到适合做、喜欢做的事，同时这件事的终局也够大，那就是非常难得的，持续努力，结果会回报我们的。</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-12-29 10:50:22" itemprop="dateCreated datePublished" datetime="2021-12-29T10:50:22+08:00">2021-12-29</time>
                </span>
                <span id="/36046.html" class="post-meta-item leancloud_visitors" data-flag-title="想想做事的终局" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>879</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/33045.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/33045.html" class="post-title-link" itemprop="url">Pika 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Pika 是 Python 中用于连接和操作 RabbitMQ 的库，本节我们了解下 Pika 的安装方式。</p>
                  <h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
                  <ul>
                    <li>官方文档：<a href="https://pika.readthedocs.io" target="_blank" rel="noopener">https://pika.readthedocs.io</a></li>
                    <li>GitHub：<a href="https://github.com/pika/pika" target="_blank" rel="noopener">https://github.com/pika/pika</a></li>
                  </ul>
                  <h2 id="先置条件"><a href="#先置条件" class="headerlink" title="先置条件"></a>先置条件</h2>
                  <p>安装之前请先安装下 RabbitMQ，安装参考说明：<a href="https://setup.scrape.center/rabbitmq" target="_blank" rel="noopener">https://setup.scrape.center/rabbitmq</a>。</p>
                  <h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2>
                  <h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3>
                  <p>推荐使用 pip3 安装，命令如下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> pika</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>命令执行完毕之后即可完成安装。</p>
                  <h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2>
                  <p>安装完成之后，可以在 Python 命令行下测试。</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ python3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pika</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果没有错误报出，则证明库已经安装好了。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-12-03 07:39:41" itemprop="dateCreated datePublished" datetime="2021-12-03T07:39:41+08:00">2021-12-03</time>
                </span>
                <span id="/33045.html" class="post-meta-item leancloud_visitors" data-flag-title="Pika 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>319</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/33044.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/33044.html" class="post-title-link" itemprop="url">RabbitMQ 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>RabbmitMQ 是一个非常强大易用的消息队列，支持 Windows、Mac、Linux 等各个平台。</p>
                  <p>每个平台都有多种安装方式，这里进行简单归纳总结，具体的安装方式请移步官方文档说明。</p>
                  <h2 id="Windows-上的安装"><a href="#Windows-上的安装" class="headerlink" title="Windows 上的安装"></a>Windows 上的安装</h2>
                  <p>Windows 主要有两种安装方式，一种是通过 Chocolatey 工具安装，另一种是通过官方安装包安装。</p>
                  <p>详细说明请移步：<a href="https://rabbitmq.com/install-windows.html" target="_blank" rel="noopener">https://rabbitmq.com/install-windows.html</a> 查看。</p>
                  <h3 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h3>
                  <p>Chocolatey 是一个 Windows 上管理软件的工具，RabbitMQ 发布了很多 Chocolatey 安装包，具体说明可以参考：<a href="https://rabbitmq.com/install-windows.html#chocolatey" target="_blank" rel="noopener">https://rabbitmq.com/install-windows.html#chocolatey</a>。</p>
                  <h3 id="官方安装包"><a href="#官方安装包" class="headerlink" title="官方安装包"></a>官方安装包</h3>
                  <p>就是下载一个二进制安装文件，具体的最新下载地址请移步 <a href="https://rabbitmq.com/install-windows.html#installer" target="_blank" rel="noopener">https://rabbitmq.com/install-windows.html#installer</a> 查看。</p>
                  <h2 id="Linux-上的安装"><a href="#Linux-上的安装" class="headerlink" title="Linux 上的安装"></a>Linux 上的安装</h2>
                  <p>Linux 上的安装方式又分了多种了，根据发行平台的不同有如下安装说明。</p>
                  <h3 id="Debian-和-Ubuntu"><a href="#Debian-和-Ubuntu" class="headerlink" title="Debian 和 Ubuntu"></a>Debian 和 Ubuntu</h3>
                  <p>请移步：<a href="https://rabbitmq.com/install-debian.html" target="_blank" rel="noopener">https://rabbitmq.com/install-debian.html</a> 查看。</p>
                  <h3 id="RedHat-Enterprise-Linux-CentOS-Fedora-openSUSE"><a href="#RedHat-Enterprise-Linux-CentOS-Fedora-openSUSE" class="headerlink" title="RedHat Enterprise Linux, CentOS, Fedora, openSUSE"></a>RedHat Enterprise Linux, CentOS, Fedora, openSUSE</h3>
                  <p>请移步：<a href="https://rabbitmq.com/install-rpm.html" target="_blank" rel="noopener">https://rabbitmq.com/install-rpm.html</a> 查看。</p>
                  <h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2>
                  <p>Mac 就是主要用 Homebrew 来安装了，具体安装说明请移步：<a href="https://rabbitmq.com/install-homebrew.html" target="_blank" rel="noopener">https://rabbitmq.com/install-homebrew.html</a>。</p>
                  <h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2>
                  <p>更多平台的安装方式请移步：<a href="https://rabbitmq.com/download.html" target="_blank" rel="noopener">https://rabbitmq.com/download.html</a> 查看。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-12-03 07:39:41" itemprop="dateCreated datePublished" datetime="2021-12-03T07:39:41+08:00">2021-12-03</time>
                </span>
                <span id="/33044.html" class="post-meta-item leancloud_visitors" data-flag-title="RabbitMQ 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>738</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/33043.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/33043.html" class="post-title-link" itemprop="url">Selenium 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Selenium 是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等等操作，对于一些 JavaScript 渲染的页面来说，此种抓取方式非常有效，下面我们来看下 Selenium 的安装过程。</p>
                  <h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
                  <ul>
                    <li>官方网站：<a href="http://www.seleniumhq.org" target="_blank" rel="noopener">http://www.seleniumhq.org</a></li>
                    <li>GitHub：<a href="https://github.com/SeleniumHQ/selenium/tree/master/py" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/tree/master/py</a></li>
                    <li>PyPi：<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium</a></li>
                    <li>官方文档：<a href="http://selenium-python.readthedocs.io" target="_blank" rel="noopener">http://selenium-python.readthedocs.io</a></li>
                    <li>中文文档：<a href="http://selenium-python-zh.readthedocs.io" target="_blank" rel="noopener">http://selenium-python-zh.readthedocs.io</a></li>
                  </ul>
                  <h2 id="ChromeDriver-安装"><a href="#ChromeDriver-安装" class="headerlink" title="ChromeDriver 安装"></a>ChromeDriver 安装</h2>
                  <p>通常来说，我们需要配合 Chrome 浏览器使用 Selenium，所以我们还需要额外安装下 ChromeDriver 和 Chrome 浏览器。</p>
                  <p>安装参考：<a href="https://setup.scrape.center/chromedriver" target="_blank" rel="noopener">https://setup.scrape.center/chromedriver</a>。</p>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3>
                  <p>推荐直接使用 pip3 安装，执行如下命令即可：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> selenium</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="wheel-安装"><a href="#wheel-安装" class="headerlink" title="wheel 安装"></a>wheel 安装</h3>
                  <p>除了 pip 安装，也可以到 PyPi 下载对应的 wheel 文件进行安装，<a href="https://pypi.python.org/pypi/selenium/#downloads" target="_blank" rel="noopener">https://pypi.python.org/pypi/selenium/#downloads</a>, 如假设最新版本为 3.4.3，则下载 selenium-3.4.3-py2.py3-none-any.whl。</p>
                  <p>然后进入 wheel 文件目录，使用 pip 安装。</p>
                  <figure class="highlight css">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">pip3</span> <span class="selector-tag">install</span> <span class="selector-tag">selenium-3</span><span class="selector-class">.4</span><span class="selector-class">.3-py2</span><span class="selector-class">.py3-none-any</span><span class="selector-class">.whl</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2>
                  <p>进入 Python 命令行交互模式，导入一下 Selenium 包，如果没有报错，则证明安装成功。</p>
                  <figure class="highlight ruby">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ python3</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import selenium</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>当然也可以运行一个脚本：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果运行完毕之后弹出来了一个 Chrome 浏览器并加载了百度页面，2 秒之后就关闭了，那就证明没问题了。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-12-03 05:39:41" itemprop="dateCreated datePublished" datetime="2021-12-03T05:39:41+08:00">2021-12-03</time>
                </span>
                <span id="/33043.html" class="post-meta-item leancloud_visitors" data-flag-title="Selenium 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>998</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31116.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/31116.html" class="post-title-link" itemprop="url">《Python3网络爬虫开发实战（第二版）》终终终终于来了！！！！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>大家好！我是崔庆才。</p>
                  <p>今天告诉大家一个好消息：《Python3 网络爬虫开发实战（第二版）》上架了！！！！</p>
                  <p>没错，就是这本：</p>
                  <p><img src="https://cdn.cuiqingcai.com/bpxgw.png" alt=""></p>
                  <p>2018 年 5 月我的《Python3 网络爬虫开发实战》的第一版出版了，从上市到现在三年多销量约 10w 册，真的非常感谢各位读者的支持。后来，由于一些技术更迭，我开始策划编写本书的第二版。</p>
                  <p>2021 年 11 月，这本书历经各种反复修改、审稿等阶段，到今天终于上架了！</p>
                  <p>这几个月我收到了太多读者的询问，第二版什么时候出来，真的抱歉实在是让大家久等了。</p>
                  <p>没错，就是今天，它来了！</p>
                  <h2 id="第二版更新内容"><a href="#第二版更新内容" class="headerlink" title="第二版更新内容"></a>第二版更新内容</h2>
                  <p>大家第一个问题可能就会问，第二版比第一版  更新了哪些内容？</p>
                  <p>因为技术总是在不断发展和进步的，爬虫技术也是一样，它在爬虫和反爬虫不断斗争的过程中也在不断演进。比如现在越来越多的网页采取了各种防护措施，比如前端代码的压缩和混淆、API 的参数加密、WebDriver 的检测，要做到高效的数据爬取，我们就需要懂得一些 JavaScript 逆向分析相关技术。App 也是一样，App 的抓包防护、加壳保护、Native 化、风控检测使得越来越多的 App 数据难以爬取，所以我们也不得不了解一些逆向相关技术，如 Xposed、Frida、IDA Pro 等工具的使用。除此之外，近几年深度学习和人工智能发展得也是如火如荼，所以爬虫也可以和人工智能结合起来，比如基于深度学习的验证码识别、网页内容的智能化解析和提取等技术我们也可以进行学习和了解。另外，一些大规模爬虫的管理和运维技术也在不断发展，当前 Kubernetes、Docker、Prometheus 等云原生技术也非常火爆，基于 Kubernetes 等云原生技术的爬虫管理和运维解决方案也已经很受青睐。然而，之前第一版书对以上提到的这些新兴技术几乎没有提及。</p>
                  <p>除此之外，第一版书在讲解数据爬取的过程中引用了很多案例和服务，比如猫眼电影网站、淘宝网站、代理服务网站，然而几年过去了，有些案例网站和服务早已经改版或者停止维护，这就导致第一版书中的很多案例已经不能正常运行了。这其实是一个很大的问题，因为程序运行不通会大大降低学习的积极性和成就感，而且会浪费不少时间。另外，即使案例对应的爬虫代码及时更新了，那我们也不知道这些案例网站和服务什么时候会再次改版，因为这都是不可控的。所以，为了彻底解决这个问题，我花费了近半年的时间构建了一个爬虫案例平台（<a href="https://scrape.center" target="_blank" rel="noopener">https://scrape.center</a>），平台包含了几十个爬虫案例，包括服务端渲染（SSR）网站、单页面应用（SPA）网站、各类反爬网站、验证码网站、模拟登录网站、各类 App 等，覆盖了现在爬虫和反爬虫相关的大多数技术，整个平台都是我来维护的，书中几乎所有案例都是从案例平台来的，从而解决了页面改版的问题。</p>
                  <p>所以，本书相比第一版来说，更新的内容主要如下：</p>
                  <ul>
                    <li>
                      <p>绝大多数都迁移到了自建的案例平台，以后再也不用担心案例有过期或改版问题。</p>
                    </li>
                    <li>
                      <p>替换了原本第一章环境安装的章节，将环境配置的部分全部汇总并迁移到案例平台（<a href="https://setup.scrape.center" target="_blank" rel="noopener">https://setup.scrape.center</a>）并在书中以外链的形式附上，以确保环境的配置和安装说明能够被及时更新。</p>
                    </li>
                    <li>
                      <p>增加了一些新的请求库、解析库、存储库等的介绍，如 httpx、parsel、Elasticsearch 等库的介绍。</p>
                    </li>
                    <li>
                      <p>增加了异步爬虫的介绍，如协程的基本原理、aiohttp 的使用和爬取实战介绍。</p>
                    </li>
                    <li>
                      <p>增加了一些新兴自动化工具的介绍，如 Pyppeteer、Playwright 的介绍。</p>
                    </li>
                    <li>
                      <p>增加了深度学习相关内容，如图形验证码、滑动验证码的识别方案。</p>
                    </li>
                    <li>
                      <p>丰富了模拟登录章节的内容，如增加了 JWT 模拟登录的介绍和实战、大规模账号池的优化。</p>
                    </li>
                    <li>
                      <p>增加了 JavaScript 逆向的章节，包括网站加密和混淆技术、JavaScript 逆向调试技巧、JavaScript 的各种模拟执行方式、AST 还原混淆代码、WebAssembly 等相关技术的介绍。</p>
                    </li>
                    <li>
                      <p>丰富了 App 自动化爬取技术的章节，如新兴框架 Airtest 的介绍、手机群控和云手机技术的介绍。</p>
                    </li>
                    <li>
                      <p>增加了 Android 逆向章节，如反编译、反汇编、Hook、脱壳、so 文件分析和模拟执行等技术的介绍。</p>
                    </li>
                    <li>
                      <p>增加了网页智能化解析章节，包括列表页、详情页内容提取算法和分类算法。</p>
                    </li>
                    <li>
                      <p>丰富了 Scrapy 相关章节的介绍，如 Pyppeteer 的对接、RabbitMQ 的对接、Prometheus 的对接等。</p>
                    </li>
                    <li>
                      <p>增加了基于 Kubernetes、Docker、Prometheus、Grafana 等云原生技术爬虫管理和运维解决方案的介绍。</p>
                    </li>
                  </ul>
                  <p>以上就是第二版的主要更新内容。</p>
                  <h2 id="章节介绍"><a href="#章节介绍" class="headerlink" title="章节介绍"></a>章节介绍</h2>
                  <p>为了让大家更直接地了解到全书的内容，这里就直接放目录了：</p>
                  <p><img src="https://cdn.cuiqingcai.com/r21da.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/sjp39.png" alt=""></p>
                  <p>没错！全书一共 900 多页，量了下有 4.3 厘米厚，定价是 139.8 元。</p>
                  <h2 id="可以直接看第二版吗？"><a href="#可以直接看第二版吗？" class="headerlink" title="可以直接看第二版吗？"></a>可以直接看第二版吗？</h2>
                  <p>当然，有朋友也会担心，我需不需要先学习第一版，然后才能学第二版呢？</p>
                  <p>答案是：可以直接学第二版，第二版书爬虫的内容知识体系是完整的，一些旧的技术已经在第一版中移除，第二版的书籍是对所有爬虫知识体系的全新升级。</p>
                  <h2 id="没有基础可以学吗？"><a href="#没有基础可以学吗？" class="headerlink" title="没有基础可以学吗？"></a>没有基础可以学吗？</h2>
                  <p>有朋友也可能会问，没有爬虫或者 Python 基础可以学吗？</p>
                  <p>答案是：可以，本书就是专为零爬虫基础的朋友准备的，本书从最基础的环境配置、基础知识的讲解开始，循序渐进地对爬虫的各个知识点进行介绍，所以完全不用担心没有爬虫基础学不会的问题。如果没有 Python 基础，那也没关系（当然有会更好），书中也会提及 Python 环境的配置并附上一些 Python 入门学习资料（链接），同时也会通过各个 Python 代码片段来进行讲解，很多案例也很简单易懂，学爬虫的时候 Python 也就会逐渐掌握了。</p>
                  <h2 id="大咖推荐"><a href="#大咖推荐" class="headerlink" title="大咖推荐"></a>大咖推荐</h2>
                  <p>这本书同时还获得了 Python 之父的推荐（没错就是 Python 的创始人，Guido van Rossum）。另外我还有幸获得了微软亚洲互联网工程院副院长曾文峰、知名爬虫专家梁斌 penny、中国人民大学高瓴人工智能学院长聘副教授宋睿华的推荐。</p>
                  <p>下面是推荐语的内容：</p>
                  <p><img src="https://cdn.cuiqingcai.com/dpw4v.png" alt=""></p>
                  <h2 id="宣传彩页"><a href="#宣传彩页" class="headerlink" title="宣传彩页"></a>宣传彩页</h2>
                  <p>另外编辑还为本书制作了几张宣传彩页，是对整本书的一个宣传介绍，大家可以看下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/vliby.png" alt=""></p>
                  <h2 id="有没有电子版？"><a href="#有没有电子版？" class="headerlink" title="有没有电子版？"></a>有没有电子版？</h2>
                  <p>看到这里，大家可能也会问了，有没有电子版呢？可能有的朋友习惯用电子版书籍来学习，有的朋友可能在海外也不方便购买，所以想要电子版。</p>
                  <p>但还是很遗憾地说：没有电子版。</p>
                  <p>因为你知道的，如果出了电子版，那么马上就会有各种盗版袭来，网上也会造成各种恶意传播。</p>
                  <p>所以，为了保护版权，这本书是没有上电子版的。</p>
                  <h2 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h2>
                  <p>是的，最后就是大家最关心的部分了，到哪里能够买到呢？</p>
                  <p>上架之前，我与编辑经过各种沟通，原本是想给广大读者和粉丝们有个专属优惠的，但是这个比较难操作，所以最终决定，整本书现在全网统一 7 折销售了！</p>
                  <p>也就是说，原价 139.8 元，现在只需要 97.9 元就能买到了。</p>
                  <p>不过这个也是限时的，7 折优惠只到下周五，也就是 12 月 3 日，之后会恢复 84 折销售，也就是 117 元。</p>
                  <p>另外还有一个消息，前几天我不是签名了 1000 本书吗？所以，现在这个阶段，卖的全都是签名版，一共 1000 本，卖完即止，先到先得。</p>
                  <p>如果不想要签名版的朋友可以再等等，等签名版的卖完了就是非签名版的了。</p>
                  <p><img src="https://cdn.cuiqingcai.com/48dy1.png" alt=""></p>
                  <p>购买链接：<a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">https://item.jd.com/13527222.html</a></p>
                  <p>为了方便购买，我把这个链接转成了二维码，大家可以直接扫码购买：</p>
                  <p><img src="https://cdn.cuiqingcai.com/1rhg8.png" alt=""></p>
                  <p>谢谢大家支持！</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-11-26 02:50:22" itemprop="dateCreated datePublished" datetime="2021-11-26T02:50:22+08:00">2021-11-26</time>
                </span>
                <span id="/31116.html" class="post-meta-item leancloud_visitors" data-flag-title="《Python3网络爬虫开发实战（第二版）》终终终终于来了！！！！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31115.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/31115.html" class="post-title-link" itemprop="url">终于签完了，1000 本...</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>是的，今天我终于完成了我的新书《Python3 网络爬虫开发实战（第二版）》的签名，一共 1000 本，整个过程感觉着实不容易啊。</p>
                  <p>签完我就来写这篇文章了，感觉左右胳膊完全不是一个感觉。</p>
                  <h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2>
                  <p>先说下事情的来龙去脉吧，因为很多读者想要一本签名版的书籍，毕竟有需求就有市场。于是编辑和我商讨之后，让我对其中的一部分进行签名。</p>
                  <p>其实当时第一版出来的时候也签了一些，那会签的少，我记得只有三百多本。</p>
                  <p>遥想那会，还是 2018 年，那会第一版的书刚刚印刷出来，那会我是去河北的一个印厂签名的。印厂把新鲜出炉的扉页的那一沓拿给我，我一个个进行签名，我还有当年签名的照片：</p>
                  <p><img src="https://cdn.cuiqingcai.com/qx2b6.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/akvkm.png" alt=""></p>
                  <p>我去，我当年这么瘦的吗？</p>
                  <p>这里简单说下扉页这一沓是怎么回事，有朋友就会好奇问为啥不直接拿给你一张纸，而是一沓纸呢？这是因为印刷的时候是用的一张大纸，比如正反面一张大纸就能覆盖书的二三十页内容，然后印刷完毕之后，这张大纸就会被折叠，最后就得到了这小小的一沓。</p>
                  <p>所以，每一本书，我只需要在这一小沓纸上签名，最后印厂再拿回去进行锁线、装订那就得到完整的书了。</p>
                  <h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2>
                  <p>好了，再说回签名的事。</p>
                  <p>今年和往年的签名流程不一样了。</p>
                  <p>印厂还是在河北，然而由于疫情原因，北京疫情管控非常严格，进京必须要 2 日之内的核算证明。另外去的话还不能光我一人吧，加上编辑还有同行同事肯定至少也得三个人，就感觉比较麻烦。</p>
                  <p>于是我们就决定这次不去印厂签名了（所以就没法拍照片了）。</p>
                  <p>那怎么办呢？</p>
                  <p>我们就决定让印厂把书的扉页都拿给我，然后我签完了再运回印厂，印厂再进行组装。</p>
                  <p>于是乎，在周二的时候，我收到了整整两大箱子书扉页。</p>
                  <p><img src="https://cdn.cuiqingcai.com/2aiyp.png" alt=""></p>
                  <p>好家伙，这数量着实不少啊，而且特别重。</p>
                  <p>另外我住的地方其实是没有电梯的 6 楼，光搬上去就废了好大的劲。</p>
                  <p>后来，从周二开始，周二、三、四、五，我每天下班之后都签一点，每天两百多本。</p>
                  <p>差不多下班后要花将近两小时签名吧，我也没仔细计算，可能中间有少许休息时间，所以这几天光签名得花了得有七八小时？</p>
                  <h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2>
                  <p>然后一直到今晚上，哦不，应该是凌晨，终于是签完了。</p>
                  <p>感觉手都签麻了。</p>
                  <p>这是一开始的时候签的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/4cdv3.png" alt=""></p>
                  <p>这是最后的时候签的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/8721c.png" alt=""></p>
                  <p>哪个好看？一定是第二张好看对不对？！更加飘逸对不对？（逃</p>
                  <p>最后晒一下完整成果吧，整整两箱子，都签好啦！</p>
                  <p><img src="https://cdn.cuiqingcai.com/jxv8w.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/cqagj.png" alt=""></p>
                  <p>我联系了印厂，印厂周六会有师傅过来我家取。</p>
                  <p>等师傅取回印厂之后，印厂就会安排锁线、装订、裁切等各个环节，最后完整的书就有啦。</p>
                  <h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2>
                  <p>然后到这里，就会有朋友问了，现在书到底啥时候能买到啊？</p>
                  <p>其实非签名版的书已经印刷好啦，前天的时候编辑已经拿到了样书，今天还有给书的专门拍摄，这里给大家看看样子哈。</p>
                  <p><img src="https://cdn.cuiqingcai.com/iv89c.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/v4eei.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/qftp9.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/xgn45.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/rbxzi.png" alt=""></p>
                  <p>这是编辑发我的图，我其实还没拿到实体书。</p>
                  <p>然后我就问编辑，这书厚不厚啊？</p>
                  <p>编辑说，厚！</p>
                  <p>然后给我发了一张测量图：</p>
                  <p><img src="https://cdn.cuiqingcai.com/lrz2w.png" alt=""></p>
                  <p>好家伙，我直接好家伙，4.3 cm 厚，大家感受一下吧。</p>
                  <p>加上用的纸还算比较好的，好像说有两三斤重？</p>
                  <p>emm，具体到手之后再体验下吧。</p>
                  <p>印刷完了之后，接下来就是入库销售了。</p>
                  <p>然后具体的售卖时间，编辑说周末或下周一会知道入库时间是什么时候，但我预估下周应该大家就可以开始购买啦。</p>
                  <p>签名版的话可能会先预售，就是发货较晚的意思，因为我刚刚签完，组装还需要几天时间，到时候应该会在京东上直接销售签名版。</p>
                  <p>售价的话，应该会打 7 折，原价 139.8，所以打完折是 98 元。</p>
                  <p>嗯嗯！总之，大家马上就可以买到啦，实在让大家久等了，到时候我会在公号第一时间发布最新消息，非常感谢大家的支持！</p>
                  <p>撒花！</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-11-20 02:50:22" itemprop="dateCreated datePublished" datetime="2021-11-20T02:50:22+08:00">2021-11-20</time>
                </span>
                <span id="/31115.html" class="post-meta-item leancloud_visitors" data-flag-title="终于签完了，1000 本..." title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.4k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/36045.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 爬虫 <i class="label-arrow"></i>
                  </a>
                  <a href="/36045.html" class="post-title-link" itemprop="url">新兴爬虫利器 Playwright 的基本用法</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Playwright 是微软在 2020 年初开源的新一代自动化测试工具，它的功能类似于 Selenium、Pyppeteer 等，都可以驱动浏览器进行各种自动化操作。它的功能也非常强大，对市面上的主流浏览器都提供了支持，API 功能简洁又强大。虽然诞生比较晚，但是现在发展得非常火热。</p>
                  <h2 id="1-Playwright-的特点"><a href="#1-Playwright-的特点" class="headerlink" title="1. Playwright 的特点"></a>1. Playwright 的特点</h2>
                  <ul>
                    <li>Playwright 支持当前所有主流浏览器，包括 Chrome 和 Edge（基于 Chromium）、Firefox、Safari（基于 WebKit） ，提供完善的自动化控制的 API。</li>
                    <li>Playwright 支持移动端页面测试，使用设备模拟技术可以使我们在移动 Web 浏览器中测试响应式 Web 应用程序。</li>
                    <li>Playwright 支持所有浏览器的 Headless 模式和非 Headless 模式的测试。</li>
                    <li>Playwright 的安装和配置非常简单，安装过程中会自动安装对应的浏览器和驱动，不需要额外配置 WebDriver 等。</li>
                    <li>Playwright 提供了自动等待相关的 API，当页面加载的时候会自动等待对应的节点加载，大大简化了 API 编写复杂度。</li>
                  </ul>
                  <p>本节我们就来了解下 Playwright 的使用方法。</p>
                  <h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2>
                  <p>要使用 Playwright，需要 Python 3.7 版本及以上，请确保 Python 的版本符合要求。</p>
                  <p>要安装 Playwright，可以直接使用 pip3，命令如下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> playwright</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>安装完成之后需要进行一些初始化操作：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">playwright <span class="keyword">install</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候 Playwrigth 会安装 Chromium, Firefox and WebKit 浏览器并配置一些驱动，我们不必关心中间配置的过程，Playwright 会为我们配置好。</p>
                  <p>具体的安装说明可以参考：<a href="https://setup.scrape.center/playwright。" target="_blank" rel="noopener">https://setup.scrape.center/playwright。</a></p>
                  <p>安装完成之后，我们便可以使用 Playwright 启动 Chromium 或 Firefox 或 WebKit 浏览器来进行自动化操作了。</p>
                  <h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h2>
                  <p>Playwright 支持两种编写模式，一种是类似 Pyppetter 一样的异步模式，另一种是像 Selenium 一样的同步模式，我们可以根据实际需要选择使用不同的模式。</p>
                  <p>我们先来看一个基本同步模式的例子：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">        browser = browser_type.launch(headless=<span class="literal">False</span>)</span><br><span class="line">        page = browser.new_page()</span><br><span class="line">        page.goto(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">        page.screenshot(path=<span class="string">f'screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png'</span>)</span><br><span class="line">        print(page.title())</span><br><span class="line">        browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>首先我们导入了 sync_playwright 方法，然后直接调用了这个方法，该方法返回的是一个 PlaywrightContextManager 对象，可以理解是一个浏览器上下文管理器，我们将其赋值为变量 p。</p>
                  <p>接着我们调用了 PlaywrightContextManager 对象的 chromium、firefox、webkit 属性依次创建了一个 Chromium、Firefox 以及 Webkit 浏览器实例，接着用一个 for 循环依次执行了它们的 launch 方法，同时设置了 headless 参数为 False。</p>
                  <blockquote>
                    <p>注意：如果不设置为 False，默认是无头模式启动浏览器，我们看不到任何窗口。</p>
                  </blockquote>
                  <p>launch 方法返回的是一个 Browser 对象，我们将其赋值为 browser 变量。然后调用 browser 的 new_page 方法，相当于新建了一个选项卡，返回的是一个 Page 对象，将其赋值为 page，这整个过程其实和 Pyppeteer 非常类似。接着我们就可以调用 page 的一系列 API 来进行各种自动化操作了，比如调用 goto，就是加载某个页面，这里我们访问的是百度的首页。接着我们调用了 page 的 screenshot 方法，参数传一个文件名称，这样截图就会自动保存为该图片名称，这里名称中我们加入了 browser_type 的 name 属性，代表浏览器的类型，结果分别就是 chromium, firefox, webkit。另外我们还调用了 title 方法，该方法会返回页面的标题，即 HTML 中 title 节点中的文字，也就是选项卡上的文字，我们将该结果打印输出到控制台。最后操作完毕，调用 browser 的 close 方法关闭整个浏览器，运行结束。</p>
                  <p>运行一下，这时候我们可以看到有三个浏览器依次启动并加载了百度这个页面，分别是 Chromium、Firefox 和 Webkit 三个浏览器，页面加载完成之后，生成截图、控制台打印结果就退出了。</p>
                  <p>这时候当前目录便会生成三个截图文件，都是百度的首页，文件名中都带有了浏览器的名称，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/m6auk.png" alt=""></p>
                  <p>控制台运行结果如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">百度一下，你就知道</span><br><span class="line">百度一下，你就知道</span><br><span class="line">百度一下，你就知道</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>通过运行结果我们可以发现，我们非常方便地启动了三种浏览器并完成了自动化操作，并通过几个 API 就完成了截图和数据的获取，整个运行速度是非常快的，者就是 Playwright 最最基本的用法。</p>
                  <p>当然除了同步模式，Playwright 还提供异步的 API，如果我们项目里面使用了 asyncio，那就应该使用异步模式，写法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> playwright.async_api <span class="keyword">import</span> async_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> async_playwright() <span class="keyword">as</span> p:</span><br><span class="line">        <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">            browser = <span class="keyword">await</span> browser_type.launch()</span><br><span class="line">            page = <span class="keyword">await</span> browser.new_page()</span><br><span class="line">            <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">            <span class="keyword">await</span> page.screenshot(path=<span class="string">f'screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png'</span>)</span><br><span class="line">            print(<span class="keyword">await</span> page.title())</span><br><span class="line">            <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到整个写法和同步模式基本类似，导入的时候使用的是 async_playwright 方法，而不再是 sync_playwright 方法。写法上添加了 async/await 关键字的使用，最后的运行效果是一样的。</p>
                  <p>另外我们注意到，这例子中使用了 with as 语句，with 用于上下文对象的管理，它可以返回一个上下文管理器，也就对应一个 PlaywrightContextManager 对象，无论运行期间是否抛出异常，它能够帮助我们自动分配并且释放 Playwright 的资源。</p>
                  <h2 id="4-代码生成"><a href="#4-代码生成" class="headerlink" title="4. 代码生成"></a>4. 代码生成</h2>
                  <p>Playwright 还有一个强大的功能，那就是可以录制我们在浏览器中的操作并将代码自动生成出来，有了这个功能，我们甚至都不用写任何一行代码，这个功能可以通过 playwright 命令行调用 codegen 来实现，我们先来看看 codegen 命令都有什么参数，输入如下命令：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">playwright codegen <span class="comment">--help</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>结果类似如下：</p>
                  <figure class="highlight">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="attribute">Usage</span>: npx playwright codegen [options] [url]</span><br><span class="line"></span><br><span class="line">open page and generate code for user actions</span><br><span class="line"></span><br><span class="line"><span class="attribute">Options:</span></span><br><span class="line">  -o, --output &lt;file name&gt;     saves the generated script to a file</span><br><span class="line">  --target &lt;language&gt;          language to use, one of javascript, python, python-async, csharp (default: "python")</span><br><span class="line">  -b, --browser &lt;browserType&gt;  browser to use, one of cr, chromium, ff, firefox, wk, webkit (default: "chromium")</span><br><span class="line">  --channel &lt;channel&gt;          Chromium distribution channel, "chrome", "chrome-beta", "msedge-dev", etc</span><br><span class="line">  --color-scheme &lt;scheme&gt;      emulate preferred color scheme, "light" or "dark"</span><br><span class="line">  --device &lt;deviceName&gt;        emulate device, for example  "iPhone 11"</span><br><span class="line">  --geolocation &lt;coordinates&gt;  specify geolocation coordinates, for example "37.819722,-122.478611"</span><br><span class="line">  --load-storage &lt;filename&gt;    load context storage state from the file, previously saved with --save-storage</span><br><span class="line">  --lang &lt;language&gt;            specify language / locale, for example "en-GB"</span><br><span class="line">  --proxy-server &lt;proxy&gt;       specify proxy server, for example "http://myproxy:3128" or "socks5://myproxy:8080"</span><br><span class="line">  --save-storage &lt;filename&gt;    save context storage state at the end, for later use with --load-storage</span><br><span class="line">  --timezone &lt;time zone&gt;       time zone to emulate, for example "Europe/Rome"</span><br><span class="line">  --timeout &lt;timeout&gt;          timeout for Playwright actions in milliseconds (default: "10000")</span><br><span class="line">  --user-agent &lt;ua string&gt;     specify user agent string</span><br><span class="line">  --viewport-size &lt;size&gt;       specify browser viewport size in pixels, for example "1280, 720"</span><br><span class="line">  -h, --help                   display help for command</span><br><span class="line"></span><br><span class="line"><span class="attribute">Examples:</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">  $ codegen</span><br><span class="line">  $ codegen --target=python</span><br><span class="line">  $ codegen -b webkit https://example.com</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到这里有几个选项，比如 -o 代表输出的代码文件的名称；—target 代表使用的语言，默认是 python，即会生成同步模式的操作代码，如果传入 python-async 就会生成异步模式的代码；-b 代表的是使用的浏览器，默认是 Chromium，其他还有很多设置，比如 —device 可以模拟使用手机浏览器，比如 iPhone 11，—lang 代表设置浏览器的语言，—timeout 可以设置页面加载超时时间。</p>
                  <p>好，了解了这些用法，那我们就来尝试启动一个 Firefox 浏览器，然后将操作结果输出到 script.py 文件，命令如下：</p>
                  <figure class="highlight mipsasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">playwright codegen -o <span class="keyword">script.py </span>-<span class="keyword">b </span>firefox</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这时候就弹出了一个 Firefox 浏览器，同时右侧会输出一个脚本窗口，实时显示当前操作对应的代码。</p>
                  <p>我们可以在浏览器中做任何操作，比如打开百度，然后点击输入框并输入 nba，然后再点击搜索按钮，浏览器窗口如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/shz6p.png" alt=""></p>
                  <p>可以看见浏览器中还会高亮显示我们正在操作的页面节点，同时还显示了对应的选择器字符串 <code>input[name=&quot;wd&quot;]</code>，右侧的窗口如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/4z2ew.png" alt=""></p>
                  <p>在操作过程中，该窗口中的代码就实时变化，可以看到这里生成了我们一系列操作的对应代码，比如在搜索框中输入 nba，就对应如下代码：</p>
                  <figure class="highlight less">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="selector-tag">page</span><span class="selector-class">.fill</span>(<span class="string">"input[name=\"</span>wd\<span class="string">"]"</span>, <span class="string">"nba"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>操作完毕之后，关闭浏览器，Playwright 会生成一个 script.py 文件，内容如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(playwright)</span>:</span></span><br><span class="line">    browser = playwright.firefox.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    context = browser.new_context()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Open new page</span></span><br><span class="line">    page = context.new_page()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Go to https://www.baidu.com/</span></span><br><span class="line">    page.goto(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Click input[name="wd"]</span></span><br><span class="line">    page.click(<span class="string">"input[name=\"wd\"]"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fill input[name="wd"]</span></span><br><span class="line">    page.fill(<span class="string">"input[name=\"wd\"]"</span>, <span class="string">"nba"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Click text=百度一下</span></span><br><span class="line">    <span class="keyword">with</span> page.expect_navigation():</span><br><span class="line">        page.click(<span class="string">"text=百度一下"</span>)</span><br><span class="line"></span><br><span class="line">    context.close()</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> playwright:</span><br><span class="line">    run(playwright)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到这里生成的代码和我们之前写的示例代码几乎差不多，而且也是完全可以运行的，运行之后就可以看到它又可以复现我们刚才所做的操作了。</p>
                  <p>所以，有了这个功能，我们甚至都不用编写任何代码，只通过简单的可视化点击就能把代码生成出来，可谓是非常方便了！</p>
                  <p>另外这里有一个值得注意的点，仔细观察下生成的代码，和前面的例子不同的是，这里 new_page 方法并不是直接通过 browser 调用的，而是通过 context 变量调用的，这个 context 又是由 browser 通过调用 new_context 方法生成的。有读者可能就会问了，这个 context 究竟是做什么的呢？</p>
                  <p>其实这个 context 变量对应的是一个 BrowserContext 对象，BrowserContext 是一个类似隐身模式的独立上下文环境，其运行资源是单独隔离的，在做一些自动化测试过程中，每个测试用例我们都可以单独创建一个 BrowserContext 对象，这样可以保证每个测试用例之间互不干扰，具体的 API 可以参考 <a href="https://playwright.dev/python/docs/api/class-browsercontext" target="_blank" rel="noopener">https://playwright.dev/python/docs/api/class-browsercontext</a>。</p>
                  <h2 id="5-移动端浏览器支持"><a href="#5-移动端浏览器支持" class="headerlink" title="5. 移动端浏览器支持"></a>5. 移动端浏览器支持</h2>
                  <p>Playwright 另外一个特色功能就是可以支持移动端浏览器的模拟，比如模拟打开 iPhone 12 Pro Max 上的 Safari 浏览器，然后手动设置定位，并打开百度地图并截图。首先我们可以选定一个经纬度，比如故宫的经纬度是 39.913904, 116.39014，我们可以通过 geolocation 参数传递给 Webkit 浏览器并初始化。</p>
                  <p>示例代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    iphone_12_pro_max = p.devices[<span class="string">'iPhone 12 Pro Max'</span>]</span><br><span class="line">    browser = p.webkit.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    context = browser.new_context(</span><br><span class="line">        **iphone_12_pro_max,</span><br><span class="line">        locale=<span class="string">'zh-CN'</span>,</span><br><span class="line">        geolocation=&#123;<span class="string">'longitude'</span>: <span class="number">116.39014</span>, <span class="string">'latitude'</span>: <span class="number">39.913904</span>&#125;,</span><br><span class="line">        permissions=[<span class="string">'geolocation'</span>]</span><br><span class="line">    )</span><br><span class="line">    page = context.new_page()</span><br><span class="line">    page.goto(<span class="string">'https://amap.com'</span>)</span><br><span class="line">    page.wait_for_load_state(state=<span class="string">'networkidle'</span>)</span><br><span class="line">    page.screenshot(path=<span class="string">'location-iphone.png'</span>)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们先用 PlaywrightContextManager 对象的 devices 属性指定了一台移动设备，这里传入的是手机的型号，比如 iPhone 12 Pro Max，当然也可以传其他名称，比如 iPhone 8，Pixel 2 等。</p>
                  <p>前面我们已经了解了 BrowserContext 对象，BrowserContext 对象也可以用来模拟移动端浏览器，初始化一些移动设备信息、语言、权限、位置等信息，这里我们就用它来创建了一个移动端 BrowserContext 对象，通过 geolocation 参数传入了经纬度信息，通过 permissions 参数传入了赋予的权限信息，最后将得到的 BrowserContext 对象赋值为 context 变量。</p>
                  <p>接着我们就可以用 BrowserContext 对象来新建一个页面，还是调用 new_page 方法创建一个新的选项卡，然后跳转到高德地图，并调用了 wait_for_load_state 方法等待页面某个状态完成，这里我们传入的 state 是 networkidle，也就是网络空闲状态。因为在页面初始化和加载过程中，肯定是伴随有网络请求的，所以加载过程中肯定不算 networkidle 状态，所以这里我们传入 networkidle 就可以标识当前页面和数据加载完成的状态。加载完成之后，我们再调用 screenshot 方法获取当前页面截图，最后关闭浏览器。</p>
                  <p>运行下代码，可以发现这里就弹出了一个移动版浏览器，然后加载了高德地图，并定位到了故宫的位置，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/jkxf2.png" alt=""></p>
                  <p>输出的截图也是浏览器中显示的结果。</p>
                  <p>所以这样我们就成功实现了移动端浏览器的模拟和一些设置，其操作 API 和 PC 版浏览器是完全一样的。</p>
                  <h2 id="6-选择器"><a href="#6-选择器" class="headerlink" title="6. 选择器"></a>6. 选择器</h2>
                  <p>前面我们注意到 click 和 fill 等方法都传入了一个字符串，这些字符串有的符合 CSS 选择器的语法，有的又是 text= 开头的，感觉似乎没太有规律的样子，它到底支持怎样的匹配规则呢？下面我们来了解下。</p>
                  <p>传入的这个字符串，我们可以称之为 Element Selector，它不仅仅支持 CSS 选择器、XPath，Playwright 还扩展了一些方便好用的规则，比如直接根据文本内容筛选，根据节点层级结构筛选等等。</p>
                  <h3 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h3>
                  <p>文本选择支持直接使用 <code>text=</code> 这样的语法进行筛选，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"text=Log in"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就代表选择文本是 Log in 的节点，并点击。</p>
                  <h3 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h3>
                  <p>CSS 选择器之前也介绍过了，比如根据 id 或者 class 筛选：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"button"</span>)</span><br><span class="line">page.click(<span class="string">"#nav-bar .contact-us-item"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>根据特定的节点属性筛选：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"[data-test=login-button]"</span>)</span><br><span class="line">page.click(<span class="string">"[aria-label='Sign in']"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="CSS-选择器-文本"><a href="#CSS-选择器-文本" class="headerlink" title="CSS 选择器 + 文本"></a>CSS 选择器 + 文本</h3>
                  <p>我们还可以使用 CSS 选择器结合文本值进行海选，比较常用的就是 has-text 和 text，前者代表包含指定的字符串，后者代表字符串完全匹配，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"article:has-text('Playwright')"</span>)</span><br><span class="line">page.click(<span class="string">"#nav-bar :text('Contact us')"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第一个就是选择文本中包含 Playwright 的 article 节点，第二个就是选择 id 为 nav-bar 节点中文本值等于 Contact us 的节点。</p>
                  <h3 id="CSS-选择器-节点关系"><a href="#CSS-选择器-节点关系" class="headerlink" title="CSS 选择器 + 节点关系"></a>CSS 选择器 + 节点关系</h3>
                  <p>还可以结合节点关系来筛选节点，比如使用 has 来指定另外一个选择器，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">".item-description:has(.item-promo-banner)"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>比如这里选择的就是选择 class 为 item-description 的节点，且该节点还要包含 class 为 item-promo-banner 的子节点。</p>
                  <p>另外还有一些相对位置关系，比如 right-of 可以指定位于某个节点右侧的节点，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"input:right-of(:text('Username'))"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里选择的就是一个 input 节点，并且该 input 节点要位于文本值为 Username 的节点的右侧。</p>
                  <h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3>
                  <p>当然 XPath 也是支持的，不过 xpath 这个关键字需要我们自行制定，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(<span class="string">"xpath=//button"</span>)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里需要在开头指定 <code>xpath=</code> 字符串，代表后面是一个 XPath 表达式。</p>
                  <p>关于更多选择器的用法和最佳实践，可以参考官方文档：<a href="https://playwright.dev/python/docs/selectors。" target="_blank" rel="noopener">https://playwright.dev/python/docs/selectors。</a></p>
                  <h2 id="7-常用操作方法"><a href="#7-常用操作方法" class="headerlink" title="7. 常用操作方法"></a>7. 常用操作方法</h2>
                  <p>上面我们了解了浏览器的一些初始化设置和基本的操作实例，下面我们再对一些常用的操作 API 进行说明。</p>
                  <p>常见的一些 API 如点击 click，输入 fill 等操作，这些方法都是属于 Page 对象的，所以所有的方法都从 Page 对象的 API 文档查找就好了，文档地址：<a href="https://playwright.dev/python/docs/api/class-page。" target="_blank" rel="noopener">https://playwright.dev/python/docs/api/class-page。</a></p>
                  <p>下面介绍几个常见的 API 用法。</p>
                  <h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3>
                  <p>Page 对象提供了一个 on 方法，它可以用来监听页面中发生的各个事件，比如 close、console、load、request、response 等等。</p>
                  <p>比如这里我们可以监听 response 事件，response 事件可以在每次网络请求得到响应的时候触发，我们可以设置对应的回调方法获取到对应 Response 的全部信息，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">f'Statue <span class="subst">&#123;response.status&#125;</span>: <span class="subst">&#123;response.url&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.on(<span class="string">'response'</span>, on_response)</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们在创建 Page 对象之后，就开始监听 response 事件，同时将回调方法设置为 on_response，on_response 对象接收一个参数，然后把 Response 的状态码和链接都输出出来了。</p>
                  <p>运行之后，可以看到控制台输出结果如下：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/css/app.ea9d802a.css</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/js/app.5ef0d454.js</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/js/chunk-vendors.77daf991.js</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/css/chunk-19c920f8.2a6496e0.css</span></span><br><span class="line">...</span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/css/chunk-19c920f8.2a6496e0.css</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/js/chunk-19c920f8.c3a1129d.js</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/img/logo.a508a8f0.png</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/fonts/element-icons.535877f5.woff</span></span><br><span class="line">Statue <span class="number">301</span>: https:<span class="comment">//spa6.scrape.center/api/movie?limit=10&amp;offset=0&amp;token=NGMwMzFhNGEzMTFiMzJkOGE0ZTQ1YjUzMTc2OWNiYTI1Yzk0ZDM3MSwxNjIyOTE4NTE5</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//spa6.scrape.center/api/movie/?limit=10&amp;offset=0&amp;token=NGMwMzFhNGEzMTFiMzJkOGE0ZTQ1YjUzMTc2OWNiYTI1Yzk0ZDM3MSwxNjIyOTE4NTE5</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//p0.meituan.net/movie/da64660f82b98cdc1b8a3804e69609e041108.jpg@464w_644h_1e_1c</span></span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@464w_644h_1e_1c</span></span><br><span class="line">....</span><br><span class="line">Statue <span class="number">200</span>: https:<span class="comment">//p1.meituan.net/movie/b607fba7513e7f15eab170aac1e1400d878112.jpg@464w_644h_1e_1c</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <blockquote>
                    <p>注意：这里省略了部分重复的内容。</p>
                  </blockquote>
                  <p>可以看到，这里的输出结果其实正好对应浏览器 Network 面板中所有的请求和响应内容，和下图是一一对应的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/0dj23.png" alt=""></p>
                  <p>这个网站我们之前分析过，其真实的数据都是 Ajax 加载的，同时 Ajax 请求中还带有加密参数，不好轻易获取。</p>
                  <p>但有了这个方法，这里如果我们想要截获 Ajax 请求，岂不是就非常容易了？</p>
                  <p>改写一下判定条件，输出对应的 JSON 结果，改写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'/api/movie/'</span> <span class="keyword">in</span> response.url <span class="keyword">and</span> response.status == <span class="number">200</span>:</span><br><span class="line">        print(response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.on(<span class="string">'response'</span>, on_response)</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>控制台输入如下：</p>
                  <figure class="highlight 1c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;'count': <span class="number">100</span>, 'results': [&#123;'id': <span class="number">1</span>, 'name': '霸王别姬', 'alias': 'Farewell My Concubine', 'cover': 'https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd<span class="number">7896</span>cf<span class="number">6247</span>2.jpg@464w_644h_1e_1c', 'categories': ['剧情', '爱情'], 'published_at': '<span class="number">1993-07-26</span>', 'minute': <span class="number">171</span>, 'score': <span class="number">9.5</span>, 'regions': ['中国大陆', '中国香港']&#125;,</span><br><span class="line">...</span><br><span class="line">'published_at': None, 'minute': <span class="number">103</span>, 'score': <span class="number">9.0</span>, 'regions': ['美国']&#125;, &#123;'id': <span class="number">10</span>, 'name': '狮子王', 'alias': 'The Lion King', 'cover': 'https://p0.meituan.net/movie/27b76fe6cf<span class="number">3903</span>f3d<span class="number">7496</span>3f<span class="number">70786001</span>e<span class="number">143840</span>6.jpg@464w_644h_1e_1c', 'categories': ['动画', '歌舞', '冒险'], 'published_at': '<span class="number">1995-07-15</span>', 'minute': <span class="number">89</span>, 'score': <span class="number">9.0</span>, 'regions': ['美国']&#125;]&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>简直是得来全不费工夫，我们直接通过这个方法拦截了 Ajax 请求，直接把响应结果拿到了，即使这个 Ajax 请求有加密参数，我们也不用关心，因为我们直接截获了 Ajax 最后响应的结果，这对数据爬取来说实在是太方便了。</p>
                  <p>另外还有很多其他的事件监听，这里不再一一介绍了，可以查阅官方文档，参考类似的写法实现。</p>
                  <h3 id="获取页面源码"><a href="#获取页面源码" class="headerlink" title="获取页面源码"></a>获取页面源码</h3>
                  <p>要获取页面的 HTML 代码其实很简单，我们直接通过 content 方法获取即可，用法如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    html = page.content()</span><br><span class="line">    print(html)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果就是页面的 HTML 代码。获取了 HTML 代码之后，我们通过一些解析工具就可以提取想要的信息了。</p>
                  <h3 id="页面点击"><a href="#页面点击" class="headerlink" title="页面点击"></a>页面点击</h3>
                  <p>刚才我们通过示例也了解了页面点击的方法，那就是 click，这里详细说一下其使用方法。</p>
                  <p>页面点击的 API 定义如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.click(selector, **kwargs)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里可以看到必传的参数是 selector，其他的参数都是可选的。第一个 selector 就代表选择器，可以用来匹配想要点击的节点，如果传入的选择器匹配了多个节点，那么只会用第一个节点。</p>
                  <p>这个方法的内部执行逻辑如下：</p>
                  <ul>
                    <li>根据 selector 找到匹配的节点，如果没有找到，那就一直等待直到超时，超时时间可以由额外的 timeout 参数设置，默认是 30 秒。</li>
                    <li>等待对该节点的可操作性检查的结果，比如说如果某个按钮设置了不可点击，那它会等待该按钮变成了可点击的时候才去点击，除非通过 force 参数设置跳过可操作性检查步骤强制点击。</li>
                    <li>如果需要的话，就滚动下页面，将需要被点击的节点呈现出来。</li>
                    <li>调用 page 对象的 mouse 方法，点击节点中心的位置，如果指定了 position 参数，那就点击指定的位置。</li>
                  </ul>
                  <p>click 方法的一些比较重要的参数如下：</p>
                  <ul>
                    <li>click_count：点击次数，默认为 1。</li>
                    <li>timeout：等待要点击的节点的超时时间，默认是 30 秒。</li>
                    <li>position：需要传入一个字典，带有 x 和 y 属性，代表点击位置相对节点左上角的偏移位置。</li>
                    <li>force：即使不可点击，那也强制点击。默认是 False。</li>
                  </ul>
                  <p>具体的 API 设置参数可以参考官方文档：<a href="https://playwright.dev/python/docs/api/class-page/#pageclickselector-kwargs。" target="_blank" rel="noopener">https://playwright.dev/python/docs/api/class-page/#pageclickselector-kwargs。</a></p>
                  <h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3>
                  <p>文本输入对应的方法是 fill，API 定义如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.fill(selector, value, **kwargs)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个方法有两个必传参数，第一个参数也是 selector，第二个参数是 value，代表输入的内容，另外还可以通过 timeout 参数指定对应节点的最长等待时间。</p>
                  <h3 id="获取节点属性"><a href="#获取节点属性" class="headerlink" title="获取节点属性"></a>获取节点属性</h3>
                  <p>除了对节点进行操作，我们还可以获取节点的属性，方法就是 get_attribute，API 定义如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">page.get_attribute(selector, name, **kwargs)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这个方法有两个必传参数，第一个参数也是 selector，第二个参数是 name，代表要获取的属性名称，另外还可以通过 timeout 参数指定对应节点的最长等待时间。</p>
                  <p>示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    href = page.get_attribute(<span class="string">'a.name'</span>, <span class="string">'href'</span>)</span><br><span class="line">    print(href)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用了 get_attribute 方法，传入的 selector 是 <code>a.name</code>，选定了 class 为 name 的 a 节点，然后第二个参数传入了 href，获取超链接的内容，输出结果如下：</p>
                  <figure class="highlight gcode">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">/detail/ZWYz<span class="symbol">NCN0</span>ZXVxMGJ<span class="number">0</span>dWEjKC<span class="number">01</span><span class="symbol">N3</span>cxcTVv<span class="symbol">NS0</span>takA<span class="number">5</span>OHh<span class="number">5</span>Z<span class="number">2</span>ltbHlmeHMqLSFpLTAtbWIx</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到对应 href 属性就获取出来了，但这里只有一条结果，因为这里有个条件，那就是如果传入的选择器匹配了多个节点，那么只会用第一个节点。</p>
                  <p>那怎么获取所有的节点呢？</p>
                  <h3 id="获取多个节点"><a href="#获取多个节点" class="headerlink" title="获取多个节点"></a>获取多个节点</h3>
                  <p>获取所有节点可以使用 query_selector_all 方法，它可以返回节点列表，通过遍历获取到单个节点之后，我们可以接着调用单个节点的方法来进行一些操作和属性获取，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    elements = page.query_selector_all(<span class="string">'a.name'</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        print(element.get_attribute(<span class="string">'href'</span>))</span><br><span class="line">        print(element.text_content())</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们通过 query_selector_all 方法获取了所有匹配到的节点，每个节点对应的是一个 ElementHandle 对象，然后 ElementHandle 对象也有 get_attribute 方法来获取节点属性，另外还可以通过 text_content 方法获取节点文本。</p>
                  <p>运行结果如下：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx</span><br><span class="line">霸王别姬 - Farewell My Concubine</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIy</span><br><span class="line">这个杀手不太冷 - Léon</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIz</span><br><span class="line">肖申克的救赎 - The Shawshank Redemption</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI0</span><br><span class="line">泰坦尼克号 - Titanic</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI1</span><br><span class="line">罗马假日 - Roman Holiday</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI2</span><br><span class="line">唐伯虎点秋香 - Flirting Scholar</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI3</span><br><span class="line">乱世佳人 - Gone with the Wind</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI4</span><br><span class="line">喜剧之王 - The King of Comedy</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI5</span><br><span class="line">楚门的世界 - The Truman Show</span><br><span class="line"><span class="regexp">/detail/</span>ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIxMA==</span><br><span class="line">狮子王 - The Lion King</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="获取单个节点"><a href="#获取单个节点" class="headerlink" title="获取单个节点"></a>获取单个节点</h3>
                  <p>获取单个节点也有特定的方法，就是 query_selector，如果传入的选择器匹配到多个节点，那它只会返回第一个节点，示例如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">'https://spa6.scrape.center/'</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    element = page.query_selector(<span class="string">'a.name'</span>)</span><br><span class="line">    print(element.get_attribute(<span class="string">'href'</span>))</span><br><span class="line">    print(element.text_content())</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果如下：</p>
                  <figure class="highlight gcode">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">/detail/ZWYz<span class="symbol">NCN0</span>ZXVxMGJ<span class="number">0</span>dWEjKC<span class="number">01</span><span class="symbol">N3</span>cxcTVv<span class="symbol">NS0</span>takA<span class="number">5</span>OHh<span class="number">5</span>Z<span class="number">2</span>ltbHlmeHMqLSFpLTAtbWIx</span><br><span class="line">霸王别姬 - Farewell My Co<span class="symbol">ncubine</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>可以看到这里只输出了第一个匹配节点的信息。</p>
                  <h3 id="网络劫持"><a href="#网络劫持" class="headerlink" title="网络劫持"></a>网络劫持</h3>
                  <p>最后再介绍一个实用的方法 route，利用 route 方法，我们可以实现一些网络劫持和修改操作，比如修改 request 的属性，修改 response 响应结果等。</p>
                  <p>看一个实例：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cancel_request</span><span class="params">(route, request)</span>:</span></span><br><span class="line">        route.abort()</span><br><span class="line"></span><br><span class="line">    page.route(re.compile(<span class="string">r"(\.png)|(\.jpg)"</span>), cancel_request)</span><br><span class="line">    page.goto(<span class="string">"https://spa6.scrape.center/"</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">'networkidle'</span>)</span><br><span class="line">    page.screenshot(path=<span class="string">'no_picture.png'</span>)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们调用了 route 方法，第一个参数通过正则表达式传入了匹配的 URL 路径，这里代表的是任何包含 <code>.png</code> 或 <code>.jpg</code> 的链接，遇到这样的请求，会回调 cancel_request 方法处理，cancel_request 方法可以接收两个参数，一个是 route，代表一个 CallableRoute 对象，另外一个是 request，代表 Request 对象。这里我们直接调用了 route 的 abort 方法，取消了这次请求，所以最终导致的结果就是图片的加载全部取消了。</p>
                  <p>观察下运行结果，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/eyisw.png" alt=""></p>
                  <p>可以看到图片全都加载失败了。</p>
                  <p>这个设置有什么用呢？其实是有用的，因为图片资源都是二进制文件，而我们在做爬取过程中可能并不想关心其具体的二进制文件的内容，可能只关心图片的 URL 是什么，所以在浏览器中是否把图片加载出来就不重要了。所以如此设置之后，我们可以提高整个页面的加载速度，提高爬取效率。</p>
                  <p>另外，利用这个功能，我们还可以将一些响应内容进行修改，比如直接修改 Response 的结果为自定义的文本文件内容。</p>
                  <p>首先这里定义一个 HTML 文本文件，命名为 custom_response.html，内容如下：</p>
                  <figure class="highlight html">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hack Response<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hack Response<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>代码编写如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_response</span><span class="params">(route, request)</span>:</span></span><br><span class="line">        route.fulfill(path=<span class="string">"./custom_response.html"</span>)</span><br><span class="line"></span><br><span class="line">    page.route(<span class="string">'/'</span>, modify_response)</span><br><span class="line">    page.goto(<span class="string">"https://spa6.scrape.center/"</span>)</span><br><span class="line">    browser.close()</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里我们使用 route 的 fulfill 方法指定了一个本地文件，就是刚才我们定义的 HTML 文件，运行结果如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/di2dp.png" alt=""></p>
                  <p>可以看到，Response 的运行结果就被我们修改了，URL 还是不变的，但是结果已经成了我们修改的 HTML 代码。</p>
                  <p>所以通过 route 方法，我们可以灵活地控制请求和响应的内容，从而在某些场景下达成某些目的。</p>
                  <h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2>
                  <p>本节介绍了 Playwright 的基本用法，其 API 强大又易于使用，同时具备很多 Selenium、Pyppeteer 不具备的更好用的 API，是新一代 JavaScript 渲染页面的爬取利器。</p>
                  <p>本节代码：<a href="https://github.com/Python3WebSpider/PlaywrightTest。" target="_blank" rel="noopener">https://github.com/Python3WebSpider/PlaywrightTest。</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-11-13 07:39:41" itemprop="dateCreated datePublished" datetime="2021-11-13T07:39:41+08:00">2021-11-13</time>
                </span>
                <span id="/36045.html" class="post-meta-item leancloud_visitors" data-flag-title="新兴爬虫利器 Playwright 的基本用法" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>18k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>16 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31114.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Other <i class="label-arrow"></i>
                  </a>
                  <a href="/31114.html" class="post-title-link" itemprop="url">2核4G 8M服务器70元+社区返现，社区&腾讯云双十一云产品活动来啦！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>以往各大云服务商在双十一大促都会推出很多活动，例如前几年会有 1核2G1M 69 元这类新用户活动。没想到今年腾讯云活动相当猛，<strong>2核CPU+4G内存+8M带宽首年</strong> 才 <strong>70</strong> 块钱！如果按 <strong>3</strong> 年买，也只是 <strong>198</strong> 元，要知道平时买这样的服务器，怎么说也要 1000+ 元。</p>
                  <p>如果你不懂如何操作云服务器，可以观看【社区公开课】视频-<a href="https://chuanjiabing.com/thread/289" target="_blank" rel="noopener">工程师必知必会的 Linux 云服务器</a></p>
                  <p><img src="https://img.weishidong.com/20211109213354.png" alt="活动主会场"></p>
                  <p>除此之外，腾讯云那边联系到社区一起办活动，给了一部分奖励，大家从<strong>社区链接购买</strong>他们本次活动产品的可以<strong>找社区小助手返现金</strong>，具体活动规则如下：</p>
                  <p>1、腾讯云<strong>新用户</strong> （个人或企业）购买金额大于 <strong>100</strong> 元，社区将按购买金额的 5% 进行返现；<br>2、腾讯云<strong>新用户</strong> （个人或企业）购买金额大于 <strong>50</strong> 、小于 <strong>100</strong> 元，社区一次性返现 5 元；<br>3、腾讯云<strong>新用户</strong> （个人或企业）购买金额大于 <strong>1000</strong> 元，社区将按购买金额的 10% 进行返现；<br>4、腾讯云<strong>老用户</strong> （个人或企业）购买金额大于 <strong>300</strong> 元，社区将按购买金额的 5% 进行返现；</p>
                  <p>5、如果购买多个产品，请在<strong>同一个订单</strong>中结算（即一次性购买）；</p>
                  <p>社区专属活动链接（可<a href="https://cloud.tencent.com/act/double11?spread_hash_key=92518f4cf8e4cb326251fe0f7537bc23&amp;cps_key=f31586a82039422aee085aac372348bd" target="_blank" rel="noopener">点击此处跳转</a>也可复制下方地址）：</p>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">https:<span class="regexp">//</span>cloud.tencent.com<span class="regexp">/act/</span>double11?spread_hash_key=<span class="number">92518</span>f4cf8e4cb326251fe0f7537bc23&amp;cps_key=f31586a82039422aee085aac372348bd</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p><img src="https://discuz-1306601599.file.myqcloud.com/public/attachments/2021/11/05/a5eb2049efa0c0e07b51e375eb60cb2e724c312cimage.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDMbbKmytXu0oLbaHjvpSothFXYIlxrUqu%26q-sign-time%3D1636464735%3B1636551195%26q-key-time%3D1636464735%3B1636551195%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D7c334240a857b3048469afb00be005bea070651d&amp;" alt="attachmentId-956"></p>
                  <p>活动截止时间：活动截止日期为 2021-11-30 日 12:00:00；</p>
                  <p>奖励是否叠加：不叠加；</p>
                  <p>返现发放时间：预计 30 个工作日内；</p>
                  <p>返现发放方式：个人微信/支付宝打款、企业对公打款；</p>
                  <p><strong>⚠️ 活动参与要求</strong> ：必须是穿甲兵技术社区用户；通过<strong>社区提供的链接</strong>前往腾讯云双十一活动主会场，购买主会场中推荐的腾讯云产品；活动 COOKIE 持续 <strong>30</strong> 分钟，点击后<strong>如果还在观察活动、未购买的朋友，在购买前请再点击一次社区专属活动链接</strong> ，以免后续在后台查询不到订单信息，也就拿不到返现。</p>
                  <p>参与活动的朋友，请联系穿<strong>甲兵小助手</strong> (微信 <strong>elasticworm</strong> )计算返现；</p>
                  <p>社区补贴活动刚开始 2 天，已经有 <strong>150</strong> 多人参加了，他们都联系了小助手要补贴，火热火热的！<strong>错过了这次大促活动，以后买服务器可贵了</strong>！</p>
                  <p><img src="https://img.weishidong.com/20211109213742.png" alt="参与名单"></p>
                  <p>除了云服务器活动给力之外，新用户注册 .com 域名首年也只需要 1 元!</p>
                  <p>腾讯云还为大家准备了代金券，简直省到家了</p>
                  <p><img src="https://img.weishidong.com/20211109213359.png" alt="代金券"></p>
                  <p>⚠️注意：社区云产品规则、适用范围等请阅读腾讯云相关文档；</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-11-10 02:50:22" itemprop="dateCreated datePublished" datetime="2021-11-10T02:50:22+08:00">2021-11-10</time>
                </span>
                <span id="/31114.html" class="post-meta-item leancloud_visitors" data-flag-title="2核4G 8M服务器70元+社区返现，社区&腾讯云双十一云产品活动来啦！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31113.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/31113.html" class="post-title-link" itemprop="url">《Python3网络爬虫开发实战（第二版）》封面确定好了！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>前些天我发起了一个投票，让大家帮忙为 《Python3 网络爬虫开发实战（第二版）》选几个封面，大家也纷纷出谋划策。</p>
                  <p>其实第二版和第一版整体差别不大，这次设计主要就是换个封面的图片，然后加一个第二版的标识就好了。</p>
                  <p>之前第一版的封面是这样的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/zys0q.png" alt=""></p>
                  <p>但这个蜘蛛我觉得还有改进的空间，于是就想换一个。</p>
                  <p>然后我就自己设计了一个，然后同时设计师也设计了一个，最后出来这么几个版本：</p>
                  <p><img src="https://cdn.cuiqingcai.com/a2x5c.png" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/kqtte.png" alt=""></p>
                  <p>当时就是拿不定主意，然后就发起了一个投票活动，邀请群里的各个小伙伴们来投票。</p>
                  <p>大家参与也很积极，三百多个人参与了投票，结果是这样的：</p>
                  <p><img src="https://cdn.cuiqingcai.com/fkn2a.png" alt=""></p>
                  <p>当时选项一就是刚才设计的第一张图片，选项二和三就是刚才设计的第二张图片，只是背景元素稍微换了换。</p>
                  <p>结果大家几乎清一色的都投了选项三。</p>
                  <p>但其实我对这个选项的蜘蛛不太满意，它长这样：</p>
                  <p><img src="https://cdn.cuiqingcai.com/zo0cw.png" alt=""></p>
                  <p>我就感觉，这怎么跟闹着玩似的？而且腿也太细了吧，也没点过渡和弯折，比较奇怪。但是第一个设计的根据大家的反馈，说蜘蛛的形态比较吓人，还有的人说看起来不像蜘蛛，像章鱼，我也是醉了。</p>
                  <p>反正上面这俩图我都越想越不满意，总体上还是因为轮廓的原因吧。</p>
                  <p>然后我就像自己再找一些蜘蛛轮廓，准备再做一个。</p>
                  <p>怎么做呢？</p>
                  <p>如果找到好看的轮廓，其实就是生成一个词云图就好了。</p>
                  <p>我找啊找，又搜到了几个不错的轮廓，接下来就是把这个轮廓生成词云图了。</p>
                  <p>大家可能会想，这个词云图生成也太麻烦了吧，有对应的关键字，还要符合对应的轮廓，还要同时好看，这搞起来有点难啊，目前市面上我问了下找设计师搞个词云图也得 500 块钱呢。</p>
                  <p>当然，其实 Python 也有对应的词云图生成库，但功能我觉得还是没有那么精细化。</p>
                  <p>难道要自己画？</p>
                  <p>其实不用这么麻烦，我找到了一个网站，叫做微词云，这个还是比较简单好用的，我们只需要输入关键词和每个词的频率，还能自定义想要的轮廓，它就能自动生成词云图了，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/ipl5j.png" alt=""></p>
                  <p>这就是确定的一个新轮廓，这个蜘蛛是不是看起来就舒服多了？看起来既不吓人，又没那么奇怪。</p>
                  <p>最后我找了好多小伙伴也看了看最终的效果，大家都觉得这个放在封面上挺不错的。</p>
                  <p>嗯！最后就是它了！经过几天的修改，最后的效果如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/nsuvb.png" alt=""></p>
                  <p>同时在第一版封面上还加上了 Python 之父推荐的相关字样，另外「第 2 版」三个字就直接标识到了图书标题的下面。</p>
                  <p>最后的完整全封如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/61xmn.png" alt=""></p>
                  <p>背面是四位专家的推荐语。</p>
                  <p>定价是 139.8 元，没错，这本书最后 900 多页，139.8 元，其实这个价格在这个页码基础上已经算很合算了。</p>
                  <p>书现在是什么状态呢？</p>
                  <p>现在稿子已经送到印检部啦，印前检查没问题就直接印刷啦：</p>
                  <p><img src="https://cdn.cuiqingcai.com/dslyu.png" alt=""></p>
                  <p>等印刷出来之后我还会去印厂签上千本名，到时候就会有签名版的书搞活动送给大家哈。</p>
                  <p>请大家耐心等待几天，书很快就可以跟大家见面啦～</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-30 23:50:22" itemprop="dateCreated datePublished" datetime="2021-10-30T23:50:22+08:00">2021-10-30</time>
                </span>
                <span id="/31113.html" class="post-meta-item leancloud_visitors" data-flag-title="《Python3网络爬虫开发实战（第二版）》封面确定好了！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31111.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> Python <i class="label-arrow"></i>
                  </a>
                  <a href="/31111.html" class="post-title-link" itemprop="url">我的新书《Python3网络爬虫开发实战（第二版）》获得 Python 之父的推荐了！</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>别急，这书现在还没上市哈，但很快了。</p>
                  <p>最近朋友们一直在催：<strong>你的第二版爬虫书怎么还不出来啊，我都等了好几年了！你不是前几个月就完稿了吗？咋这么慢。</strong></p>
                  <p>别急，这下是真的很快就要上市了。</p>
                  <p>为啥我的第二版书“难产”了呢？原因有好多：</p>
                  <ul>
                    <li>
                      <p>一个就是工作原因，之前第一版书是读研期间写的，工作之后发现书中的一些案例已经过期了，于是就决定写第二版。但工作毕竟是工作，工作的内容还是需要放在第一位的，所以第二版书的内容基本都是利用下班之后或者周末的时间写出来的，所以进度很慢。</p>
                    </li>
                    <li>
                      <p>另外一个就是为了解决案例过期的问题，之前耗费了很多精力自己制作了爬虫案例平台，<a href="https://scrape.center/" target="_blank" rel="noopener">https://scrape.center/</a>，里面做了几十个爬虫案例，书中对这些案例进行了配合讲解，这就解决了一些案例过期的问题，也能更好地帮助读者进行练习，前前后后这个案例平台做了也有小半年的时间。</p>
                    </li>
                  </ul>
                  <p>等书籍完稿之后，其实还有不少的事情，比如审稿、修改、封面设计、推荐语等等，总之步骤是很繁琐的，改天再写个文章专门介绍下写书这件事。</p>
                  <p>单独说说推荐语。</p>
                  <p>推荐语就是印在书的背面的各位专家对本书的评价和推荐内容，一般就是几句话加上专家的 Title。就在推荐语这一块上，我还憋了个“大招”，那就是让 Python 之父 Guido van Rossum 给我写个推荐语。</p>
                  <p>Python 之父想必大家应该知道是谁吧？就是 Guido van Rossum，Python 就是他在 1989 年编写出来的。</p>
                  <p><img src="https://cdn.cuiqingcai.com/1ekff.png" alt=""></p>
                  <p>有人说，你还真敢想，还想让 Python 之父给你这本“名不见经传”的书写推荐语？闹呢？人家怎么可能会理你？</p>
                  <p>其实想想确实不可思议的，但我还是想试试，如果真的能拿到 Python 之父的推荐，那简直是荣幸之至！</p>
                  <p>另外由于我在微软工作，Python 之父 Guido 2020 年也宣布加入微软。所以，我和他也多少是同一个公司的了（但显然职位差距过大）。</p>
                  <p>所以，没准还是有机会的呢？</p>
                  <p>好，那么问题来了，我这书都是中文写的，Python 之父是看不懂中文的，咋办呢？难道我要把全书都翻译一遍吗？</p>
                  <p>是的，还真得是这样，我不能给个中文内容或者啥也不给就干巴巴地要求他帮我写推荐语吧？这也太滑稽了。</p>
                  <p>在此之前，有好几个月时间整本书的内容还在审稿和修改，等稿子审完的时候差不多就九月份了，然后九月份左右，我就拿到了编辑那边给到的全书审核完毕的 Word 文档，但还没正式排版。看了看，这个 Word 文档一共有 1000 多页，好家伙，我真的不敢相信我写了这么多。</p>
                  <p>但也没办法，那也得翻译一遍。</p>
                  <p>如果我全部手工翻译也太麻烦了，于是我就从网上找了一些工具，比如 Word 全文翻译工具，其背后就是对接了 Google 翻译，但这些工具还有上传大小限制，于是我就又把各个章节进行了拆分，一部分一部分地翻译完了再合并起来。</p>
                  <p>当然大家知道，Google 翻译肯定质量不能保证的吧，比如一些说法和名词就翻译不太准确，我就得进行手工审查和修改。所以我又花了好多天时间对全文进行检查和修改，包括不准确的标题、表述、名词等等。然后我还对整个目录索引重新规整了一遍。</p>
                  <p>总之整个翻译准备过程差不多也花了半个月的时间，最后翻译完了英文版差不多 1600 页，如图所示，比如目录最后一节就是 1561 页了：</p>
                  <p><img src="https://cdn.cuiqingcai.com/nybvt.png" alt="全书翻译"></p>
                  <p>但是，这个其实还不够，如果把这个书丢过去，人家没时间看怎么办？我总得好好介绍下整本书的情况吧。</p>
                  <p>于是我又把书的介绍和前言又翻译了一遍，内容包括：写书的初衷、整本书的介绍、整体章节的规划，这样的话能帮助 Guido 更好地理解整本书的脉络和内容。</p>
                  <p>于是又有了如下的内容：</p>
                  <p><img src="https://cdn.cuiqingcai.com/k6dnm.png" alt="书的介绍"></p>
                  <p>好像还是不够，万一 Guido 觉得写推荐语很麻烦怎么办？如果我能给他提供几个 Draft Candidate 候选是不是更有帮助一些？这样他可以找些灵感或者稍微修改下就好了，于是我又草拟了一些候选推荐语，整理了一个文档。</p>
                  <p>嗯，好像就准备差不多了，一共三个东西：</p>
                  <ul>
                    <li>
                      <p>全书的翻译内容</p>
                    </li>
                    <li>
                      <p>书的内容介绍</p>
                    </li>
                    <li>
                      <p>候选推荐语</p>
                    </li>
                  </ul>
                  <p>接下来就是联系 Guido 了，心中一阵忐忑。</p>
                  <p>为了更正式一点，我发了一封邮件给 Guido，邮件整体的内容就是：先表示下对他的感谢和敬佩，然后介绍下自己的基本情况和书的基本情况，比如我是做什么的，第一版书在中国的销量等等，接着开门见山地说想要请他帮忙写一段推荐语。然后后面就附上我的书的一些详细信息，比如我整理的全文翻译书稿、内容介绍、候选推荐语等。</p>
                  <p>内容如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/8koka.png" alt=""></p>
                  <p>我怀着十分忐忑而又激动的心情，按下了发送键。</p>
                  <p>接下来就是漫长的等待。</p>
                  <p>我每天早上醒来都会看看邮件有没有收到 Guido 的回信。</p>
                  <p>没回。</p>
                  <p>还是没回。</p>
                  <p>还是还是没回。</p>
                  <p>还是还是还是没回。</p>
                  <p>好像要凉了。</p>
                  <p>好像凉了。</p>
                  <p>好像真凉了。</p>
                  <p>真的凉了。</p>
                  <p>可能真的是太忙或者没看到我的邮件吧。</p>
                  <p>后来，我就联系了我们部门的总 Director（这里就不透露具体信息了），看看他能不能帮我 connect 一下 Guido，他爽快地答应了。</p>
                  <p>不太清楚我的 Director 怎么联系的，他说单独找了下 Guido，可能是发信或者内部联系。</p>
                  <p>然后第二天，他就告诉我，得到 Guido 回复了！Guido 说确实近期比较忙，也很希望能有一个 Draft Candidate 推荐语提供给他，他可以结合着书的内容来改写一下会更好。</p>
                  <p>我的 Director 人也非常好，他也给我出了很多建议，还帮我修改了下之前我写的 Draft Candidate 推荐语给他，转发了我的邮件还帮我又介绍了下。</p>
                  <p>最后，Guido 给了最终的推荐语！！</p>
                  <p><img src="https://cdn.cuiqingcai.com/1copz.png" alt="Guido 的回信，遮盖了部分邮件内容"></p>
                  <p>收到这封邮件的时候我真的开心地要跳起来了，太开心了！我的书得终于拿到了 Python 之父的推荐啦！</p>
                  <p>正文如下：</p>
                  <blockquote>
                    <p>I am happy to see that Python is so widely used in the Chinese IT community. I hope this book will help more people understand Python and web crawling/scraping. *</p>
                    <p>—Guido van Rossum, creator of Python, Distinguished Engineer, Microsoft</p>
                  </blockquote>
                  <p>大意就是，我非常高兴 Python 能够在中国社区得到这么广泛的应用，希望本书能够帮助更多的朋友学习 Python 和网络爬虫。</p>
                  <p>嗯，整个过程比较漫长，但真的非常开心最终有了一个好的结果，真的非常荣幸能获得 Python 之父的推荐，同时也非常感谢我的 Director 帮我联系和出建议。</p>
                  <p>得到 Guido 的推荐语之后，后面的流程就很快了，还有其他各位专家的推荐语和序我也都联系好了，真的非常感谢各位专家的推荐，书中都会一一表示感谢。</p>
                  <p>现在内容也审核完毕了，最后把推荐语添加到封面上就投入印刷了！</p>
                  <p>请大家再耐心等待一小段时间，很快《Python3 网络爬虫开发实战（第二版）》就要跟大家见面啦～</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-17 23:50:22" itemprop="dateCreated datePublished" datetime="2021-10-17T23:50:22+08:00">2021-10-17</time>
                </span>
                <span id="/31111.html" class="post-meta-item leancloud_visitors" data-flag-title="我的新书《Python3网络爬虫开发实战（第二版）》获得 Python 之父的推荐了！" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31112.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 个人随笔 <i class="label-arrow"></i>
                  </a>
                  <a href="/31112.html" class="post-title-link" itemprop="url">焦虑的一个原因：没有明确的短期计划和目标</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>大家有没有这样的一个经历：</p>
                  <p>周末和节假日出去疯玩了几天，期间没有任何学习或总结，到了周一前或者到了晚上的时候，会不会感觉到有点焦虑？比如就会想：我怎么今天又玩了一天，我还有什么什么事还没做呢，还有什么什么东西还没学呢，今天都没有什么进步，诸如此类的吧，然后就产生了一种焦虑感，想去做点什么事情找补一下。</p>
                  <p>我也有这样的情况。</p>
                  <p>我觉得我可能是一个自我 Push 比较强的人。比如有一天，我觉得自己做的东西没什么意义，或者疯玩了一天也没有学习和进步，到了一天结束的时候就会感到有些焦虑。我就想通过一些事情找补点什么回来，于是可能就想熬夜看点或者学习点东西。但实际上，有时候我也不知道应该看点什么，但总觉得需要学点或者看点什么，以“欺骗”自己的大脑今天我学习了，进步了，然后焦虑就会缓解一些。当然也有时候确实也知道自己每天还有什么事情没有完成，做完了焦虑就缓解了。</p>
                  <p>但长期以来，我感觉这样其实是不健康的，我也一直在思考我应该做点什么来解决这个问题。</p>
                  <p>经历了一些思考和尝试之后，我发现了其中的一个原因：当我给自己没有制定明确的计划和目标的时候，这种焦虑就会很频繁发生。</p>
                  <p>这个计划和目标分为长期的和短期的，长期目标和规划比较大、比较远或者说比较空洞，而短期目标和规划就是为了长期目标而制定的具体的执行方案，更能使我们焦虑的，就是短期目标和规划的缺失。</p>
                  <p>假如我没有为自己制定短期的计划，到了周末不上班的时候，就会突然不知道自己应该做些什么，至少在那一天我不知道应该做些什么。由于没有当天的规划，所以那天可能就漫无目的地休闲娱乐，比如说赖床、躺尸、刷手机（比如微博、知乎、朋友圈、抖音等）、玩游戏等等，当然也有时候无聊了就约朋友出去玩，但时间就这么一点点过去了。等到晚上到来，我就会发现，这一天怎么这么快就过去了？我好像今天也没有干什么事情，我就会焦虑，觉得今天也没有做有意义的事情，觉得我拥有的能够达成我的长期目标的时间和机会又变少了。因为长期计划会隐藏在我的潜意识里，我想达成某个大的目标，但经历了无所事事的一天之后，就会觉得我又浪费了一天，就会感觉到我能达成长期目标的几率仿佛又变小了，焦虑感就油然而生了。</p>
                  <p>为了验证我的这个想法，我就有意识地进行一些测试，比如在某一段时间我就不给自己制定短期和具体计划，任凭想到啥做啥，然后就发现那个时间段焦虑感很强。然后我就又尝试梳理自己的一些目标和具体每天应该做的一些事情，每天按照我的计划去执行，每天完成了既定计划之后，就会感觉很踏实。甚至完成了既定计划之后还能超额再做点什么的时候，就会感觉成就感爆棚。</p>
                  <p>嗯，总之，经过我的一些尝试之后，就感觉 —— 为自己制定短期的目标和规划真的很有帮助，这个短期的目标和规划时间段可能在一个月或者几周，先想这个月或者几周应该去做些什么，然后细化到每天应该去做些什么，这个一定要列详细，不要空洞，然后最好还能标记好优先级。就比如说，我规划一个月可能要学一门课程，那么我就分配一下，我哪一天需要具体学从第几节到第几节的内容，记录到我的 Todo List 里面。我是用的「滴答清单」这款软件，在里面我就给我每天需要做的事情做好分配，这样每天我就知道自己需要做什么了。</p>
                  <p>但这时候有朋友可能就说，难道你周末规划的也全是学习和工作吗？娱乐、放松呢？这个当然也是有的。我觉得人不能把自己逼的太紧了，每天都紧绷着做各种各样的事情，弦会断的。所以，有时候我就会给自己规划有些时间段就是可以放松和玩的，比如周五晚上就玩游戏、周六上午就赖床多睡会、周末也会规划时间出去玩等等。</p>
                  <p>所以，做好了规划，不论是学习、工作还是放松、娱乐，这都是在自己的期望和规划之中。比如我就规划了某个时间段去放空自己玩两天，那两天就全身心放松玩两天，那也不会有什么焦虑，因为这就在我的期望之内，我知道玩完这两天，我后面的一些规划时间和事情仍然可以正常完成我做达成的短期和长期目标，焦虑感自然就不会产生了。</p>
                  <p>嗯，就是这样。如果你也遇到了文章一开始我提到的问题，不妨尝试给自己制定一个详细的短期目标和规划吧。</p>
                  <p>更多精彩内容，请关注我的公众号「进击的 Coder」和「崔庆才丨静觅」。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-17 23:50:22" itemprop="dateCreated datePublished" datetime="2021-10-17T23:50:22+08:00">2021-10-17</time>
                </span>
                <span id="/31112.html" class="post-meta-item leancloud_visitors" data-flag-title="焦虑的一个原因：没有明确的短期计划和目标" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.7k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31099.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31099.html" class="post-title-link" itemprop="url">Docker-Compose 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
                  <p>如果你还不了解 YML 文件配置，可以先阅读 <a href="https://www.runoob.com/w3cnote/yaml-intro.html" target="_blank" rel="noopener">YAML 入门教程</a>。</p>
                  <p>Compose 使用的三个步骤：</p>
                  <ul>
                    <li>使用 Dockerfile 定义应用程序的环境。</li>
                    <li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
                    <li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
                  </ul>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <p>当前，最新的 Docker 已经把 Compose 作为 Docker 的命令一部分了，可以直接安装 Docker：<a href="https://setup.scrape.center/docker" target="_blank" rel="noopener">https://setup.scrape.center/docker</a>。</p>
                  <p>另外如果要单独安装 Docker-Compose，可以参考 <a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-compose.html</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:45:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:45:45+08:00">2021-10-04</time>
                </span>
                <span id="/31099.html" class="post-meta-item leancloud_visitors" data-flag-title="Docker-Compose 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>416</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31101.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31101.html" class="post-title-link" itemprop="url">Helm 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Helm 是 Kubernetes 的包管理器。</p>
                  <h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
                  <ul>
                    <li>官网：<a href="https://helm.sh/" target="_blank" rel="noopener">https://helm.sh/</a></li>
                    <li>中文文档：<a href="https://helm.sh/zh/docs/" target="_blank" rel="noopener">https://helm.sh/zh/docs/</a></li>
                  </ul>
                  <p>该指南展示了如何安装 Helm CLI。Helm 可以用源码或构建的二进制版本安装。</p>
                  <p>下面的内容来自：<a href="https://helm.sh/zh/docs/intro/install/" target="_blank" rel="noopener">https://helm.sh/zh/docs/intro/install/</a>，最新内容以该链接为准。</p>
                  <h2 id="用-Helm-项目安装"><a href="#用-Helm-项目安装" class="headerlink" title="用 Helm 项目安装"></a>用 Helm 项目安装</h2>
                  <p>Helm 项目提供了两种获取和安装 Helm 的方式。这是官方提供的获取 Helm 发布版本的方法。另外， Helm 社区提供了通过不同包管理器安装 Helm 的方法。这些方法可以在下面的官方方法之后看到。</p>
                  <h3 id="用二进制版本安装"><a href="#用二进制版本安装" class="headerlink" title="用二进制版本安装"></a>用二进制版本安装</h3>
                  <p>每个 Helm <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener">版本</a>都提供了各种操作系统的二进制版本，这些版本可以手动下载和安装。</p>
                  <ol>
                    <li>下载 <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener">需要的版本</a></li>
                    <li>解压(<code>tar -zxvf helm-v3.0.0-linux-amd64.tar.gz</code>)</li>
                    <li>在解压目中找到<code>helm</code>程序，移动到需要的目录中(<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li>
                  </ol>
                  <p>然后就可以执行客户端程序并 <a href="https://helm.sh/zh/docs/intro/quickstart/#初始化" target="_blank" rel="noopener">添加稳定仓库</a>: <code>helm help</code>.</p>
                  <p><strong>注意</strong> 针对 Linux AMD64，Helm 的自动测试只有在 CircleCi 构建和发布时才会执行。测试其他操作系统是社区针对系统问题请求 Helm 的责任。</p>
                  <h3 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h3>
                  <p>Helm 现在有个安装脚本可以自动拉取最新的 Helm 版本并在 <a href="https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3" target="_blank" rel="noopener">本地安装</a>。</p>
                  <p>您可以获取这个脚本并在本地执行。它良好的文档会让您在执行之前知道脚本都做了什么。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ curl -fsSL -o get_helm.sh https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helm&#x2F;helm&#x2F;main&#x2F;scripts&#x2F;get-helm-3</span><br><span class="line">$ chmod 700 get_helm.sh</span><br><span class="line">$ .&#x2F;get_helm.sh</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果想直接执行安装，运行<code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash</code>。</p>
                  <h2 id="通过包管理器安装"><a href="#通过包管理器安装" class="headerlink" title="通过包管理器安装"></a>通过包管理器安装</h2>
                  <p>Helm 社区提供了通过操作系统包管理器安装 Helm 的方式。但 Helm 项目不支持且不认为是可信的第三方。</p>
                  <h3 id="使用-Homebrew-macOS"><a href="#使用-Homebrew-macOS" class="headerlink" title="使用 Homebrew (macOS)"></a>使用 Homebrew (macOS)</h3>
                  <p>Helm 社区成员贡献了一种在 Homebrew 构建 Helm 的方案，这个方案通常是最新的。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">brew install helm</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>(注意：还有一个 emacs-helm 的方案，当然这是另一个项目了。)</p>
                  <h3 id="使用-Chocolatey-Windows"><a href="#使用-Chocolatey-Windows" class="headerlink" title="使用 Chocolatey (Windows)"></a>使用 Chocolatey (Windows)</h3>
                  <p>Helm 社区成员贡献了一个 <a href="https://chocolatey.org/packages/kubernetes-helm" target="_blank" rel="noopener">Helm 包</a>在 <a href="https://chocolatey.org/" target="_blank" rel="noopener">Chocolatey</a>中构建， 包通常是最新的。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">choco install kubernetes-helm</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="使用-Apt-Debian-Ubuntu"><a href="#使用-Apt-Debian-Ubuntu" class="headerlink" title="使用 Apt (Debian/Ubuntu)"></a>使用 Apt (Debian/Ubuntu)</h3>
                  <p>Helm 社区成员贡献了针对 Apt 的一个 <a href="https://helm.baltorepo.com/stable/debian/" target="_blank" rel="noopener">Helm 包</a>，包通常是最新的。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">curl https:&#x2F;&#x2F;baltocdn.com&#x2F;helm&#x2F;signing.asc | sudo apt-key add -</span><br><span class="line">sudo apt-get install apt-transport-https --yes</span><br><span class="line">echo &quot;deb https:&#x2F;&#x2F;baltocdn.com&#x2F;helm&#x2F;stable&#x2F;debian&#x2F; all main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;helm-stable-debian.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install helm</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="使用-Snap"><a href="#使用-Snap" class="headerlink" title="使用 Snap"></a>使用 Snap</h3>
                  <p><a href="https://github.com/snapcrafters" target="_blank" rel="noopener">Snapcrafters</a>社区维护了 <a href="https://snapcraft.io/helm" target="_blank" rel="noopener">Helm 包</a>的 Snap 版本：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sudo snap install helm --classic</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="使用-pkg-FreeBSD"><a href="#使用-pkg-FreeBSD" class="headerlink" title="使用 pkg (FreeBSD)"></a>使用 pkg (FreeBSD)</h3>
                  <p>FreeBSD 社区成员贡献了一个 <a href="https://www.freshports.org/sysutils/helm" target="_blank" rel="noopener">Helm 页面</a>来构建 <a href="https://man.freebsd.org/ports" target="_blank" rel="noopener">FreeBSD 端口集</a>。通常都是最新的包。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pkg install helm</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="开发版本构建"><a href="#开发版本构建" class="headerlink" title="开发版本构建"></a>开发版本构建</h3>
                  <p>另外您可以下载和安装 Helm 的开发版本。</p>
                  <h3 id="使用-Canary-构建"><a href="#使用-Canary-构建" class="headerlink" title="使用 Canary 构建"></a>使用 Canary 构建</h3>
                  <p>“Canary”版本是从 Helm 最新的 master 分支构建。这些不是官方版本，可能不稳定。但是这提供测试边缘特性的条件。</p>
                  <p>Canary Helm 二进制包存储在 <a href="https://get.helm.sh/" target="_blank" rel="noopener">get.helm.sh</a>。以下是一般构建的链接：</p>
                  <ul>
                    <li><a href="https://get.helm.sh/helm-canary-linux-amd64.tar.gz" target="_blank" rel="noopener">Linux AMD64</a></li>
                    <li><a href="https://get.helm.sh/helm-canary-darwin-amd64.tar.gz" target="_blank" rel="noopener">macOS AMD64</a></li>
                    <li><a href="https://get.helm.sh/helm-canary-windows-amd64.zip" target="_blank" rel="noopener">实验性 Windows AMD64</a></li>
                  </ul>
                  <h3 id="使用源码-Source-Linux-macOS"><a href="#使用源码-Source-Linux-macOS" class="headerlink" title="使用源码 Source (Linux, macOS)"></a>使用源码 Source (Linux, macOS)</h3>
                  <p>从源码构建 Helm 的工作要稍微多一点，但如果你想测试最新（预发布）的 Helm 版本，这是最好的方式。</p>
                  <p>您必须有可用的 Go 环境。</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;helm&#x2F;helm.git</span><br><span class="line">$ cd helm</span><br><span class="line">$ make</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果需要，会拉取依赖并缓存，然后验证配置。然后会编译<code>helm</code>并放在<code>bin/helm</code>。</p>
                  <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
                  <p>大多数情况下，安装只需要简单地获取一个构建好的<code>helm</code>二进制包。本文档为想使用 Helm 做更复杂事情的人提供额外示例。</p>
                  <p>一旦你成功安装了 Helm 客户端，就可以继续使用 Helm 管理 chart 和 <a href="https://helm.sh/zh/docs/intro/quickstart/#初始化" target="_blank" rel="noopener">添加稳定的仓库</a>。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:45:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:45:45+08:00">2021-10-04</time>
                </span>
                <span id="/31101.html" class="post-meta-item leancloud_visitors" data-flag-title="Helm 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>2.1k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31100.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31100.html" class="post-title-link" itemprop="url">Kubernetes 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Kubernetes，又被简称作 K8s（K 和 s 中间含有 8 个字母），它是用于编排容器化应用程序的云原生系统。Kubernetes 诞生自 Google，现在已经由 CNCF （云原生计算基金会）维护更新。Kubernetes 是目前最受欢迎的集群管理方案之一，可以非常容易地实现容器的管理编排。</p>
                  <p>刚刚我们提到，Kubernetes 是一个容器编排系统，对于“编排”二字，可能不太容易理解其中的含义。为了对它有更好的理解，我们先回过头来看看容器的定位是什么以及容器解决了什么问题，不能解决什么问题，然后我们再来了解下 Kubernetes 能够弥补容器哪些缺失的内容。</p>
                  <p>好，首先来看容器。最常见的容器技术就是 Docker 了，容器它提供了相比传统虚拟化技术更轻量级的机制来创建隔离的应用程序的运行环境。比如对于某个应用程序，我们使用容器运行时，不必担心它与宿主机之间产生资源冲突，不必担心多个容器之间产生资源冲突。同时借助于容器技术，我们还能更好地保证开发环境和生产环境的运行一致性。另外由于每个容器都是独立的，因此可以将多个容器运行在同一台宿主机上，以提高宿主机资源利用率，从而也进一步降低了成本。总之，使用容器带来的好处很多，可以为我们带来极大的便利。</p>
                  <p>不过单单依靠容器技术并不能解决所有的问题，也可以说容器技术也引入了新的问题，比如说：</p>
                  <ul>
                    <li>如果容器突然运行异常了怎么办？</li>
                    <li>如果容器所在的宿主机突然运行异常了怎么办？</li>
                    <li>如果有多个容器，他们之间怎么有效地传输数据？</li>
                    <li>如果单个容器达到了瓶颈，如何平稳且有效地进行扩容？</li>
                    <li>如果生产环境是由多台主机组成的，我们怎样更好地决定使用哪台主机来运行哪个容器？</li>
                  </ul>
                  <p>以上列举了一些单纯依靠容器技术或者单纯依靠 Docker 不能解决的问题，而 Kubernetes 作为容器编排平台，提供了一个可弹性运行的分布式系统框架，各个容器可以运行在 Kubernetes 平台上，容器的管理、调度、部署、扩容等各个操作都可以经由 Kubernetes 来有效实现。比如说，Kubernetes 可以管理单个容器的声明周期，并且可以根据需要来扩展和释放资源，如果某个容器意外关闭，Kubernetes 可以根据对应的策略选择重启该容器，以保证服务的正常运行。再比如说，Kubernetes 是一个分布式的平台，当容器所在的主机突然发生异常，Kubernetes 可以将异常主机上运行的容器转移到其他正常的主机上运行，另外 Kubernetes 还可以根据容器运行所需要占用的资源自动选择合适的主机来运行。总之，Kubernetes 对容器的调度和管理提供了非常强大的支持，可以帮我们解决上述的诸多问题。</p>
                  <h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2>
                  <ul>
                    <li>官方文档：<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">https://kubernetes.io/docs/home/</a></li>
                  </ul>
                  <h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2>
                  <p>安装 Kubernetes 有好多方式，比如 Minicube、Docker 自带、自建集群、云服务商提供。</p>
                  <h2 id="Minicube"><a href="#Minicube" class="headerlink" title="Minicube"></a>Minicube</h2>
                  <p>参考：<a href="https://kubernetes.io/docs/tutorials/hello-minikube/" target="_blank" rel="noopener">https://kubernetes.io/docs/tutorials/hello-minikube/</a></p>
                  <h2 id="Docker-自带"><a href="#Docker-自带" class="headerlink" title="Docker 自带"></a>Docker 自带</h2>
                  <p>现在 Docker for Windows 和 Docker for Mac 已经自带了 Kubernetes 的集群功能，只需要打开对应开关即可，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/2hm7d.png" alt="image-20211004003229922"></p>
                  <p>这里只需要把 Enable Kubernetes 勾选即可。</p>
                  <h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2>
                  <p>搭建 Kubernetes 集群是比较麻烦的，参考链接：</p>
                  <ul>
                    <li><a href="https://segmentfault.com/a/1190000040107263" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040107263</a></li>
                    <li><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/high-availability/</a></li>
                    <li><a href="https://www.kubernetes.org.cn/7315.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/7315.html</a></li>
                  </ul>
                  <h2 id="云服务商"><a href="#云服务商" class="headerlink" title="云服务商"></a>云服务商</h2>
                  <p>很多云服务商已经提供了 Kubernetes，请移步对应云服务商的功能支持说明，参考链接：</p>
                  <ul>
                    <li>Azure：<a href="https://azure.microsoft.com/en-us/services/kubernetes-service/" target="_blank" rel="noopener">https://azure.microsoft.com/en-us/services/kubernetes-service/</a></li>
                    <li>Google：<a href="https://cloud.google.com/kubernetes-engine" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine</a></li>
                    <li>Amazon：<a href="https://aws.amazon.com/cn/eks/" target="_blank" rel="noopener">https://aws.amazon.com/cn/eks/</a></li>
                    <li>腾讯云：<a href="https://cloud.tencent.com/product/tke" target="_blank" rel="noopener">https://cloud.tencent.com/product/tke</a></li>
                    <li>阿里云：<a href="https://cn.aliyun.com/product/kubernetes" target="_blank" rel="noopener">https://cn.aliyun.com/product/kubernetes</a></li>
                    <li>华为云：<a href="https://support.huaweicloud.com/kubernetes.html" target="_blank" rel="noopener">https://support.huaweicloud.com/kubernetes.html</a></li>
                    <li>百度云：<a href="https://cloud.baidu.com/product/cce.html" target="_blank" rel="noopener">https://cloud.baidu.com/product/cce.html</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:45:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:45:45+08:00">2021-10-04</time>
                </span>
                <span id="/31100.html" class="post-meta-item leancloud_visitors" data-flag-title="Kubernetes 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>1.9k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>2 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31098.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31098.html" class="post-title-link" itemprop="url">Splash 负载均衡配置</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>用 Splash 做页面抓取时，如果爬取的量非常大，任务非常多，用一个 Splash 服务来处理的话，未免压力太大了，此时可以考虑搭建一个负载均衡器来把压力分散到各个服务器上。这相当于多台机器多个服务共同参与任务的处理，可以减小单个 Splash 服务的压力。</p>
                  <h2 id="配置-Splash-服务"><a href="#配置-Splash-服务" class="headerlink" title="配置 Splash 服务"></a>配置 Splash 服务</h2>
                  <p>要搭建 Splash 负载均衡，首先要有多个 Splash 服务。假如这里在 4 台远程主机的 8050 端口上都开启了 Splash 服务，它们的服务地址分别为 41.159.27.223:8050、41.159.27.221:8050、41.159.27.9:8050 和 41.159.117.119:8050，这 4 个服务完全一致，都是通过 Docker 的 Splash 镜像开启的。访问其中任何一个服务时，都可以使用 Splash 服务。</p>
                  <p>具体的 Splash 搭建流程可以参考：<a href="https://setup.scrape.center/splash" target="_blank" rel="noopener">https://setup.scrape.center/splash</a>。</p>
                  <h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2>
                  <p>接下来，可以选用任意一台带有公网 IP 的主机来配置负载均衡。首先，在这台主机上装好 Nginx，然后修改 Nginx 的配置文件 nginx.conf，添加如下内容：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">http &#123;</span><br><span class="line">    upstream splash &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.223</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.221</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.9</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.117</span><span class="number">.119</span>:<span class="number">8050</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">8050</span>;</span><br><span class="line">        location / &#123;proxy_pass http://splash;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们通过 <code>upstream</code> 字段定义了一个名字叫作 <code>splash</code> 的服务集群配置。其中 <code>least_conn</code> 代表最少链接负载均衡，它适合处理请求处理时间长短不一造成服务器过载的情况。</p>
                  <p>当然，我们也可以不指定配置，具体如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">upstream splash &#123;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.223</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.221</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.9</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.117</span><span class="number">.119</span>:<span class="number">8050</span>;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样默认以轮询策略实现负载均衡，每个服务器的压力相同。此策略适合服务器配置相当、无状态且短平快的服务使用。</p>
                  <p>另外，我们还可以指定权重，配置如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">upstream splash &#123;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.223</span>:<span class="number">8050</span> weight=<span class="number">4</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.221</span>:<span class="number">8050</span> weight=<span class="number">2</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.9</span>:<span class="number">8050</span> weight=<span class="number">2</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.117</span><span class="number">.119</span>:<span class="number">8050</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 <code>weight</code> 参数指定各个服务的权重，权重越高，分配到处理的请求越多。假如不同的服务器配置差别比较大的话，可以使用此种配置。</p>
                  <p>最后，还有一种 IP 散列负载均衡，配置如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">upstream splash &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.223</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.221</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.27</span><span class="number">.9</span>:<span class="number">8050</span>;</span><br><span class="line">    server <span class="number">41.159</span><span class="number">.117</span><span class="number">.119</span>:<span class="number">8050</span>;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>服务器根据请求客户端的 IP 地址进行散列计算，确保使用同一个服务器响应请求，这种策略适合有状态的服务，比如用户登录后访问某个页面的情形。对于 Splash 来说，不需要应用此设置。</p>
                  <p>我们可以根据不同的情形选用不同的配置，配置完成后重启一下 Nginx 服务：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sudo nginx -s reload</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样直接访问 Nginx 所在服务器的 8050 端口，即可实现负载均衡了。</p>
                  <h2 id="配置认证"><a href="#配置认证" class="headerlink" title="配置认证"></a>配置认证</h2>
                  <p>现在 Splash 是可以公开访问的，如果不想让其公开访问，还可以配置认证，这仍然借助于 Nginx。可以在 <code>server</code> 的 <code>location</code> 字段中添加 <code>auth_basic</code> 和 <code>auth_basic_user_file</code> 字段，具体配置如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">http &#123;</span><br><span class="line">    upstream splash &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.223</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.221</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.27</span><span class="number">.9</span>:<span class="number">8050</span>;</span><br><span class="line">        server <span class="number">41.159</span><span class="number">.117</span><span class="number">.119</span>:<span class="number">8050</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">8050</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://splash;</span><br><span class="line">            auth_basic <span class="string">"Restricted"</span>;</span><br><span class="line">            auth_basic_user_file /etc/nginx/conf.d/.htpasswd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里使用的用户名和密码配置放置在 /etc/nginx/conf.d 目录下，我们需要使用 <code>htpasswd</code> 命令创建。例如，创建一个用户名为 <code>admin</code> 的文件，相关命令如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">htpasswd -c .htpasswd admin</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来，就会提示我们输入密码。输入两次之后，就会生成密码文件，其内容如下：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">cat .htpasswd</span><br><span class="line">admin:5ZBxQr0rCqwbc</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>配置完成后重启一下 Nginx 服务，运行如下命令：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sudo nginx -s reload</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样访问认证就成功配置好了。</p>
                  <h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>
                  <p>最后，我们可以用代码来测试一下负载均衡的配置，看看到底是不是每次请求会切换 IP。利用 <a href="http://httpbin.org/get" target="_blank" rel="noopener">http://httpbin.org/get</a> 测试即可，实现代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lua = <span class="string">'''</span></span><br><span class="line"><span class="string">function main(splash, args)</span></span><br><span class="line"><span class="string">  local treat = require("treat")</span></span><br><span class="line"><span class="string">  local response = splash:http_get("http://httpbin.org/get")</span></span><br><span class="line"><span class="string">  return treat.as_string(response.body)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://splash:8050/execute?lua_source='</span> + quote(lua)</span><br><span class="line">response = requests.get(url, auth=(<span class="string">'admin'</span>, <span class="string">'admin'</span>))</span><br><span class="line">ip = re.search(<span class="string">'(\d+\.\d+\.\d+\.\d+)'</span>, response.text).group(<span class="number">1</span>)</span><br><span class="line">print(ip)</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这里 URL 中的 <code>splash</code> 字符串请自行替换成自己的 Nginx 服务器 IP。这里我修改了 Hosts，设置了 <code>splash</code> 为 Nginx 服务器 IP。</p>
                  <p>多次运行代码之后，可以发现每次请求的 IP 都会变化，比如第一次的结果：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">41.159.27.223</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>第二次的结果：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">41.159.27.9</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这就说明负载均衡已经成功实现了，配置负载均衡后，可以多个 Splash 服务共同合作，减轻单个服务的负载，这还是比较有用的。</p>
                  <p>当然，我们也可以借助于 Kubernetes + Docker 来实现负载均衡，管理起来更加简单方便，感兴趣可以搜索相关内容试验一下。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:45:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:45:45+08:00">2021-10-04</time>
                </span>
                <span id="/31098.html" class="post-meta-item leancloud_visitors" data-flag-title="Splash 负载均衡配置" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31102.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31102.html" class="post-title-link" itemprop="url">Tesserocr 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>爬虫过程中难免会遇到各种各样的验证码，而大多数验证码还是图形验证码，这时候我们可以直接用 OCR 来识别。</p>
                  <h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2>
                  <p>OCR，即 Optical Character Recognition，光学字符识别。是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。那么对于图形验证码来说，它都是一些不规则的字符，但是这些字符确实是由字符稍加扭曲变换得到的内容。</p>
                  <p>例如这样的验证码，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/obr8k.jpg" alt=""></p>
                  <p><img src="https://cdn.cuiqingcai.com/wywci.jpg" alt=""></p>
                  <p>对于这种验证码，我们便可以使用 OCR 技术来将其转化为电子文本，然后爬虫将识别结果提交给服务器，便可以达到自动识别验证码的过程。</p>
                  <p>Tesserocr 是 Python 的一个 OCR 识别库，但其实是对 Tesseract 做的一层 Python API 封装，所以它的核心是 Tesseract，所以在安装 Tesserocr 之前我们需要先安装 Tesseract，本节我们来了解下它们的安装方式。</p>
                  <h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
                  <ul>
                    <li>Tesserocr GitHub：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a></li>
                    <li>Tesserocr PyPi：<a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">https://pypi.python.org/pypi/tesserocr</a></li>
                    <li>Tesseract 下载地址：<a href="http://digi.bib.uni-mannheim.de/tesseract" target="_blank" rel="noopener">http://digi.bib.uni-mannheim.de/tesseract</a></li>
                    <li>Tesseract GitHub：<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></li>
                    <li>Tesseract 语言包：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li>
                    <li>Tesseract 文档：<a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></li>
                  </ul>
                  <h2 id="Windows-下的安装"><a href="#Windows-下的安装" class="headerlink" title="Windows 下的安装"></a>Windows 下的安装</h2>
                  <blockquote>
                    <p>本小节内容来自于：<a href="https://segmentfault.com/a/1190000039929696" target="_blank" rel="noopener">https://segmentfault.com/a/1190000039929696</a>，可以移步此链接查看原文。</p>
                  </blockquote>
                  <p>另外也可以查看其他博文，如：<a href="https://cloud.tencent.com/developer/article/1616037" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1616037</a> 来安装和排查。</p>
                  <blockquote>
                    <p>为了增大成功安装的几率，推荐使用 Python 3.7 版本。</p>
                  </blockquote>
                  <p>在 Windows 下，首先需要下载 Tesseract，它为 Tesserocr 提供了支持，下载链接为：<a href="http://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">http://digi.bib.uni-mannheim.de/tesseract/</a>。</p>
                  <p>点击进入之后可以看到有各种 exe 的下载列表，在这里可以选择下载 4.0 版本 tesseract-ocr-setup-4.00.00dev.exe，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/o6k97.png" alt=""></p>
                  <p>其中文件名中带有 dev 的为开发版本，不带 dev 的为稳定版本。</p>
                  <p>下载完成之后双击安装即可，在安装过程中可以勾选上 Additional language data 选项，安装 OCR 识别支持的语言包，这样 OCR 便可以识别多国语言。</p>
                  <p>复制你的安装路径，我的安装路径 D:\Python\Tesseract-OCR，界面如下：</p>
                  <p><img src="https://cdn.cuiqingcai.com/vqr3e.png" alt=""></p>
                  <p>打开我的电脑系统属性-&gt;高级-&gt;环境变量，把该路径配置到环境变量：</p>
                  <p><img src="https://cdn.cuiqingcai.com/gf5ml.png" alt=""></p>
                  <p>然后将下载好的字库放到 Tesseract-OCR 项目的 tessdata 文件夹里面。</p>
                  <p>接下来再安装 Tesserocr 即可，直接使用 Pip 安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> tesserocr pillow</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外如果安装过程中出现错误，请移步官方安装说明排查问题：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a>。</p>
                  <h2 id="Linux-下的安装"><a href="#Linux-下的安装" class="headerlink" title="Linux 下的安装"></a>Linux 下的安装</h2>
                  <p>对于 Linux 来说，不同系统已经有了不同的发行包了，它可能叫做 tesseract-ocr 或者 tesseract，直接用对应的命令安装即可。</p>
                  <h3 id="Ubuntu、Debian、Deepin"><a href="#Ubuntu、Debian、Deepin" class="headerlink" title="Ubuntu、Debian、Deepin"></a>Ubuntu、Debian、Deepin</h3>
                  <p>安装命令如下：</p>
                  <figure class="highlight q">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">sudo apt-<span class="built_in">get</span> install -y tesseract-ocr libtesseract-<span class="built_in">dev</span> libleptonica-<span class="built_in">dev</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="CentOS、RedHat"><a href="#CentOS、RedHat" class="headerlink" title="CentOS、RedHat"></a>CentOS、RedHat</h3>
                  <p>安装命令如下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">yum <span class="keyword">install</span> -y tesseract</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>不同发行版本运行如上命令即可完成 Tesseract 的安装。</p>
                  <p>安装完成之后便可以调用 tesseract 命令了。</p>
                  <p>我们查看一下其支持的语言：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">tesseract <span class="comment">--list-langs</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果示例：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">List of available languages (<span class="number">3</span>):</span><br><span class="line">eng</span><br><span class="line">osd</span><br><span class="line">equ</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>结果显示其只支持几种语言，如果我们想要安装多国语言还需要安装语言包，官方叫做 tessdata。</p>
                  <p>tessdata 的下载链接为：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a>。</p>
                  <p>利用 Git 命令将其下载下来并迁移到相关目录即可，不同的版本迁移命令如下：</p>
                  <h3 id="Ubuntu、Debian、Deepin-1"><a href="#Ubuntu、Debian、Deepin-1" class="headerlink" title="Ubuntu、Debian、Deepin"></a>Ubuntu、Debian、Deepin</h3>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tesseract-ocr/</span>tessdata.git</span><br><span class="line">sudo mv tessdata<span class="regexp">/* /u</span>sr<span class="regexp">/share/</span>tesseract-ocr<span class="regexp">/tessdata</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h3 id="CentOS、RedHat-1"><a href="#CentOS、RedHat-1" class="headerlink" title="CentOS、RedHat"></a>CentOS、RedHat</h3>
                  <figure class="highlight awk">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tesseract-ocr/</span>tessdata.git</span><br><span class="line">sudo mv tessdata<span class="regexp">/* /u</span>sr<span class="regexp">/share/</span>tesseract<span class="regexp">/tessdata</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样就可以将下载下来的语言包全部安装了。</p>
                  <p>这时我们重新运行列出所有语言的命令：</p>
                  <figure class="highlight ada">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">tesseract <span class="comment">--list-langs</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>结果如下：</p>
                  <figure class="highlight armasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="symbol">List</span> of available languages (<span class="number">107</span>):</span><br><span class="line"><span class="symbol">afr</span></span><br><span class="line"><span class="symbol">amh</span></span><br><span class="line"><span class="symbol">ara</span></span><br><span class="line"><span class="symbol">asm</span></span><br><span class="line"><span class="symbol">aze</span></span><br><span class="line"><span class="symbol">aze_cyrl</span></span><br><span class="line"><span class="keyword">bel</span></span><br><span class="line"><span class="keyword">ben</span></span><br><span class="line"><span class="keyword">bod</span></span><br><span class="line"><span class="keyword">bos</span></span><br><span class="line"><span class="keyword">bul</span></span><br><span class="line"><span class="keyword">cat</span></span><br><span class="line"><span class="keyword">ceb</span></span><br><span class="line"><span class="keyword">ces</span></span><br><span class="line"><span class="keyword">chi_sim</span></span><br><span class="line"><span class="keyword">chi_tra</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>即可发现其列出的语言就多了非常多，比如 chi_sim 就代表简体中文，这就证明语言包安装成功了。</p>
                  <p>接下来再安装 Tesserocr 即可，直接使用 Pip 安装：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> tesserocr pillow</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <h2 id="Mac-下的安装"><a href="#Mac-下的安装" class="headerlink" title="Mac 下的安装"></a>Mac 下的安装</h2>
                  <p>Mac 下首先使用 Homebrew 安装 Imagemagick 和 Tesseract 库：</p>
                  <figure class="highlight mipsasm">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>imagemagick</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>tesseract --all-languages</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>接下来再安装 Tesserocr 即可：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> tesserocr pillow</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>这样我们便完成了 Tesserocr 的安装。</p>
                  <h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2>
                  <p>接下来我们可以使用 Tesseract 和 Tesserocr 来分别进行测试。</p>
                  <p>下面我们以如下的图片为样例进行测试，如图所示：</p>
                  <p><img src="https://cdn.cuiqingcai.com/sk256.jpg" alt=""></p>
                  <p>图片链接为：<a href="https://raw.githubusercontent.com/Python3WebSpider/TestTess/master/image.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/Python3WebSpider/TestTess/master/image.png</a>，可以直接保存或下载。</p>
                  <p>我们首先用命令行进行测试，将图片下载保存为 image.png，然后用 Tesseract 命令行测试，命令如下：</p>
                  <figure class="highlight applescript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">tesseract image.png <span class="literal">result</span> -l eng &amp;&amp; cat <span class="literal">result</span>.txt</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果：</p>
                  <figure class="highlight angelscript">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Tesseract Open Source OCR Engine v3<span class="number">.05</span><span class="number">.01</span> with Leptonica</span><br><span class="line">Python3WebSpider</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>我们调用了 tesseract 命令，第一个参数为图片名称，第二个参数 result 为结果保存的目标文件名称，-l 指定使用的语言包，在此使用 eng 英文，然后再用 cat 命令将结果输出。</p>
                  <p>第二行的运行结果便是图片的识别结果，Python3WebSpider。</p>
                  <p>我们可以看到这时已经成功将图片文字转为电子文本了。</p>
                  <p>然后我们还可以利用 Python 代码来测试，这里就需要借助于 Tesserocr 库了，测试代码如下：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">image = Image.open(<span class="string">'image.png'</span>)</span><br><span class="line">print(tesserocr.image_to_text(image))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>在这里我们首先利用 Image 读取了图片文件，然后调用了 tesserocr 的 image_to_text() 方法，再将将其识别结果输出。</p>
                  <p>运行结果：</p>
                  <figure class="highlight gcode">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Pytho<span class="symbol">n3</span>WebSpider</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>另外我们还可以直接调用 file_to_text() 方法，也可以达到同样的效果：</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line">print(tesserocr.file_to_text(<span class="string">'image.png'</span>))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>运行结果：</p>
                  <figure class="highlight gcode">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Pytho<span class="symbol">n3</span>WebSpider</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果成功输出结果，则证明 Tesseract 和 Tesserocr 都已经安装成功。</p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:45:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:45:45+08:00">2021-10-04</time>
                </span>
                <span id="/31102.html" class="post-meta-item leancloud_visitors" data-flag-title="Tesserocr 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>3.5k</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>3 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31096.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31096.html" class="post-title-link" itemprop="url">Frida 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>Frida 是一个基于 Python 和 JavaScript 的 Hook 与调试框架，是一款易用的跨平台 Hook 工具，无 论 Java 层的逻辑，还是 Native 层的逻辑，它都可以 Hook。Frida 可以把代码插入原生 App 的内存空 间，然后动态地监视和修改其行为，支持 Windows、Mac、Linux、Android、iOS 全平台。</p>
                  <h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
                  <ul>
                    <li>官网：<a href="https://frida.re/" target="_blank" rel="noopener">https://frida.re/</a></li>
                    <li>GitHub：<a href="https://github.com/frida/frida" target="_blank" rel="noopener">https://github.com/frida/frida</a></li>
                  </ul>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3>
                  <p>推荐使用 pip3 安装，命令如下：</p>
                  <figure class="highlight cmake">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">pip3 <span class="keyword">install</span> frida frida-tools</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>命令执行完毕之后即可完成安装。</p>
                  <h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2>
                  <p>安装完成之后，可以在 Python 命令行下测试。</p>
                  <figure class="highlight python">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">$ python3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> frida</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>
                  <p>如果没有错误报出，则证明库已经安装好了。</p>
                  <p>更多安装说明参考：<a href="https://frida.re/docs/installation/" target="_blank" rel="noopener">https://frida.re/docs/installation/</a></p>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:44:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:44:45+08:00">2021-10-04</time>
                </span>
                <span id="/31096.html" class="post-meta-item leancloud_visitors" data-flag-title="Frida 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>410</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <article itemscope itemtype="http://schema.org/Article" class="post-block index" lang="zh-CN">
              <link itemprop="mainEntityOfPage" href="https://cuiqingcai.com/31097.html">
              <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
                <meta itemprop="image" content="/images/avatar.png">
                <meta itemprop="name" content="崔庆才">
                <meta itemprop="description" content="静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。">
              </span>
              <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
                <meta itemprop="name" content="静觅">
              </span>
              <header class="post-header">
                <h2 class="post-title" itemprop="name headline">
                  <a class="label"> 安装配置 <i class="label-arrow"></i>
                  </a>
                  <a href="/31097.html" class="post-title-link" itemprop="url">IDA Pro 的安装</a>
                </h2>
              </header>
              <div class="post-body" itemprop="articleBody">
                <div class="thumb">
                  <img itemprop="contentUrl" class="random">
                </div>
                <div class="excerpt">
                  <p>
                  <p>IDA Pro 的英文全称是 Interactive Disassembler Professional，即交互式反汇编器专业版，大家也称 之为 IDA。它由一家总部位于比利时的 Hex-Rayd 公司开发，功能十分强大，是目前流行的反汇编软 件之一，也是安全分析人士必备的一款软件。</p>
                  <p>IDA Pro 最重要的功能便是可以将二进制文件中的机器代码(如 010101)转化成汇编代码，甚至 可以进一步根据汇编代码的执行逻辑还原出高级语言(如 C/C++)编写的代码，从而大大提高代码的 可读性。IDA Pro 不仅仅局限于分析 Android 中的 so 文件，它可以处理和分析几乎所有的二进制文件， Windows、DOS、Unix、Linux、Mac、Java、.NET 等平台的二进制文件都不在话下。另外，IDA Pro 提 供了图形界面和强大的调试功能，利用它我们可以直观地实时调试和分析二进制文件。除了这些，IDA Pro 还提供开放式的插件架构，我们可以编写自定义的插件轻松扩展其功能。</p>
                  <p>总之，IDA Pro 是一款极其强大的反汇编软件，已经成为业界安全分析必不可少的一个工具，更多介绍可以查看 IDA Pro 的官网。</p>
                  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>
                  <p>IDA Pro 是收费的，但是有不少大佬已经破解了，可以移步相关资源查看：<a href="https://bbs.pediy.com/thread-263559.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-263559.htm</a>。</p>
                  <p>其他的安装教程：</p>
                  <ul>
                    <li><a href="https://blog.csdn.net/qq_34732729/article/details/109184623" target="_blank" rel="noopener">https://blog.csdn.net/qq_34732729/article/details/109184623</a></li>
                    <li><a href="https://www.bilibili.com/video/BV1uA411V7LK/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1uA411V7LK/</a></li>
                  </ul>
                  </p>
                </div>
              </div>
              <div class="post-meta">
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-user"></i>
                  </span>
                  <span class="post-meta-item-text">作者</span>
                  <span><a href="/authors/崔庆才" class="author" itemprop="url" rel="index">崔庆才</a></span>
                </span>
                <span class="post-meta-item">
                  <span class="post-meta-item-icon">
                    <i class="far fa-calendar"></i>
                  </span>
                  <span class="post-meta-item-text">发表于</span>
                  <time title="创建时间：2021-10-04 03:44:45" itemprop="dateCreated datePublished" datetime="2021-10-04T03:44:45+08:00">2021-10-04</time>
                </span>
                <span id="/31097.html" class="post-meta-item leancloud_visitors" data-flag-title="IDA Pro 的安装" title="阅读次数">
                  <span class="post-meta-item-icon">
                    <i class="fa fa-eye"></i>
                  </span>
                  <span class="post-meta-item-text">阅读次数：</span>
                  <span class="leancloud-visitors-count"></span>
                </span>
                <span class="post-meta-item" title="本文字数">
                  <span class="post-meta-item-icon">
                    <i class="far fa-file-word"></i>
                  </span>
                  <span class="post-meta-item-text">本文字数：</span>
                  <span>667</span>
                </span>
                <span class="post-meta-item" title="阅读时长">
                  <span class="post-meta-item-icon">
                    <i class="far fa-clock"></i>
                  </span>
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                  <span>1 分钟</span>
                </span>
              </div>
            </article>
            <script>
              document.querySelectorAll('.random').forEach(item => item.src = "https://picsum.photos/id/" + Math.floor(Math.random() * Math.floor(300)) + "/200/133")

            </script>
            <nav class="pagination">
              <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
            </nav>
          </div>
          <script>
            window.addEventListener('tabs:register', () =>
            {
              let
              {
                activeClass
              } = CONFIG.comments;
              if (CONFIG.comments.storage)
              {
                activeClass = localStorage.getItem('comments_active') || activeClass;
              }
              if (activeClass)
              {
                let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
                if (activeTab)
                {
                  activeTab.click();
                }
              }
            });
            if (CONFIG.comments.storage)
            {
              window.addEventListener('tabs:click', event =>
              {
                if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
                let commentClass = event.target.classList[1];
                localStorage.setItem('comments_active', commentClass);
              });
            }

          </script>
        </div>
        <div class="toggle sidebar-toggle">
          <span class="toggle-line toggle-line-first"></span>
          <span class="toggle-line toggle-line-middle"></span>
          <span class="toggle-line toggle-line-last"></span>
        </div>
        <aside class="sidebar">
          <div class="sidebar-inner">
            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc"> 文章目录 </li>
              <li class="sidebar-nav-overview"> 站点概览 </li>
            </ul>
            <!--noindex-->
            <div class="post-toc-wrap sidebar-panel">
            </div>
            <!--/noindex-->
            <div class="site-overview-wrap sidebar-panel">
              <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <img class="site-author-image" itemprop="image" alt="崔庆才" src="/images/avatar.png">
                <p class="site-author-name" itemprop="name">崔庆才</p>
                <div class="site-description" itemprop="description">静觅丨崔庆才的个人站点专业为您提供爬虫教程,爬虫,Python,Python爬虫,Python爬虫教程,爬虫书的相关信息，想要了解更多详情，请联系我们。</div>
              </div>
              <div class="site-state-wrap motion-element">
                <nav class="site-state">
                  <div class="site-state-item site-state-posts">
                    <a href="/archives/">
                      <span class="site-state-item-count">710</span>
                      <span class="site-state-item-name">日志</span>
                    </a>
                  </div>
                  <div class="site-state-item site-state-categories">
                    <a href="/categories/">
                      <span class="site-state-item-count">43</span>
                      <span class="site-state-item-name">分类</span></a>
                  </div>
                  <div class="site-state-item site-state-tags">
                    <a href="/tags/">
                      <span class="site-state-item-count">260</span>
                      <span class="site-state-item-name">标签</span></a>
                  </div>
                </nav>
              </div>
              <div class="links-of-author motion-element">
                <span class="links-of-author-item">
                  <a href="https://github.com/Germey" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Germey" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
                </span>
                <span class="links-of-author-item">
                  <a href="mailto:cqc@cuiqingcai.com.com" title="邮件 → mailto:cqc@cuiqingcai.com.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮件</a>
                </span>
                <span class="links-of-author-item">
                  <a href="https://weibo.com/cuiqingcai" title="微博 → https:&#x2F;&#x2F;weibo.com&#x2F;cuiqingcai" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>微博</a>
                </span>
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/Germey" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Germey" rel="noopener" target="_blank"><i class="fa fa-magic fa-fw"></i>知乎</a>
                </span>
              </div>
            </div>
            <div style=" width: 100%;" class="sidebar-panel sidebar-panel-image sidebar-panel-active">
              <a href="https://item.jd.com/13527222.html" target="_blank" rel="noopener">
                <img src="https://cdn.cuiqingcai.com/ei5og.jpg" style=" width: 100%;">
              </a>
            </div>
            <div class="sidebar-panel sidebar-panel-categories sidebar-panel-active">
              <h4 class="name"> 分类 </h4>
              <div class="content">
                <ul class="category-list">
                  <li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><span class="category-list-count">23</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Claude/">Claude</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Gemini/">Gemini</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Google-SERP/">Google SERP</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">14</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">26</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">14</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Luma/">Luma</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Midjourney/">Midjourney</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Nano-Banana/">Nano Banana</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Net/">Net</a><span class="category-list-count">4</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Nexior/">Nexior</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a><span class="category-list-count">40</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">27</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Paper/">Paper</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Producer/">Producer</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">303</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/SeeDance/">SeeDance</a><span class="category-list-count">5</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/SeeDream/">SeeDream</a><span class="category-list-count">3</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Sora/">Sora</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">2</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/Veo/">Veo</a><span class="category-list-count">3</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/nano-banana/">nano-banana</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E5%B1%95%E7%A4%BA/">个人展示</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E8%AE%B0/">个人日记</a><span class="category-list-count">9</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/">个人记录</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/">个人随笔</a><span class="category-list-count">21</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">安装配置</a><span class="category-list-count">59</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/">技术杂谈</a><span class="category-list-count">96</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a><span class="category-list-count">4</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E7%AC%94%E8%AE%B0/">生活笔记</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A6%8F%E5%88%A9%E4%B8%93%E5%8C%BA/">福利专区</a><span class="category-list-count">6</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E8%81%8C%E4%BD%8D%E6%8E%A8%E8%8D%90/">职位推荐</a><span class="category-list-count">1</span></li>
                  <li class="category-list-item"><a class="category-list-link" href="/categories/%E8%89%BA%E6%9C%AF%E4%BA%8C%E7%BB%B4%E7%A0%81/">艺术二维码</a><span class="category-list-count">1</span></li>
                </ul>
              </div>
            </div>
            <div class="sidebar-panel sidebar-panel-friends sidebar-panel-active">
              <h4 class="name"> 友情链接 </h4>
              <ul class="friends">
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/j2dub.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.findhao.net/" target="_blank" rel="noopener">FindHao</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/6apxu.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.51dev.com/" target="_blank" rel="noopener">IT技术社区</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/bqlbs.png">
                  </span>
                  <span class="link">
                    <a href="http://www.urselect.com/" target="_blank" rel="noopener">优社电商</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/8s88c.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.yuanrenxue.com/" target="_blank" rel="noopener">猿人学</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/2wgg5.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.yunlifang.cn/" target="_blank" rel="noopener">云立方</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="http://qianxunclub.com/favicon.png">
                  </span>
                  <span class="link">
                    <a href="http://qianxunclub.com/" target="_blank" rel="noopener">千寻啊千寻</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/0044u.jpg">
                  </span>
                  <span class="link">
                    <a href="http://kodcloud.com/" target="_blank" rel="noopener">可道云</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/ygnpn.jpg">
                  </span>
                  <span class="link">
                    <a href="http://www.kunkundashen.cn/" target="_blank" rel="noopener">坤坤大神</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/x714o.jpg">
                  </span>
                  <span class="link">
                    <a href="http://www.hubwiz.com/" target="_blank" rel="noopener">汇智网</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/44hxf.png">
                  </span>
                  <span class="link">
                    <a href="http://redstonewill.com/" target="_blank" rel="noopener">红色石头</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/wkaus.jpg">
                  </span>
                  <span class="link">
                    <a href="https://zhaoshuai.me/" target="_blank" rel="noopener">碎念</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/pgo0r.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.chenwenguan.com/" target="_blank" rel="noopener">陈文管的博客</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/kk82a.jpg">
                  </span>
                  <span class="link">
                    <a href="https://www.lxlinux.net/" target="_blank" rel="noopener">良许Linux教程网</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/lj0t2.jpg">
                  </span>
                  <span class="link">
                    <a href="https://tanqingbo.cn/" target="_blank" rel="noopener">IT码农</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/i8cdr.png">
                  </span>
                  <span class="link">
                    <a href="https://junyiseo.com/" target="_blank" rel="noopener">均益个人博客</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://cdn.cuiqingcai.com/chwv2.png">
                  </span>
                  <span class="link">
                    <a href="https://brucedone.com/" target="_blank" rel="noopener">大鱼的鱼塘</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://www.91vps.com/favicon.ico">
                  </span>
                  <span class="link">
                    <a href="http://www.91vps.com/" target="_blank" rel="noopener">91VPS</a>
                  </span>
                </li>
                <li class="friend">
                  <span class="logo">
                    <img src="https://webpage.qidian.qq.com/qidian/chatv3-gray/favicon.ico">
                  </span>
                  <span class="link">
                    <a href="https://www.qg.net/" target="_blank" rel="noopener">青果网络</a>
                  </span>
                </li>
              </ul>
            </div>
            <div class="sidebar-panel sidebar-panel-tags sidebar-panel-active">
              <h4 class="name"> 标签云 </h4>
              <div class="content">
                <a href="/tags/2022/" style="font-size: 20px;">2022</a> <a href="/tags/2048/" style="font-size: 10px;">2048</a> <a href="/tags/ACE-Data/" style="font-size: 13px;">ACE Data</a> <a href="/tags/ADSL/" style="font-size: 10px;">ADSL</a> <a href="/tags/AI%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">AI编程</a> <a href="/tags/API/" style="font-size: 19px;">API</a> <a href="/tags/Ajax/" style="font-size: 12px;">Ajax</a> <a href="/tags/Audios/" style="font-size: 11px;">Audios</a> <a href="/tags/Bootstrap/" style="font-size: 11px;">Bootstrap</a> <a href="/tags/Bug/" style="font-size: 10px;">Bug</a> <a href="/tags/CDN/" style="font-size: 10px;">CDN</a> <a href="/tags/CQC/" style="font-size: 10px;">CQC</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/CSS-%E5%8F%8D%E7%88%AC%E8%99%AB/" style="font-size: 10px;">CSS 反爬虫</a> <a href="/tags/CV/" style="font-size: 10px;">CV</a> <a href="/tags/ChatGPT/" style="font-size: 10px;">ChatGPT</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Eclipse/" style="font-size: 11px;">Eclipse</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/Flux/" style="font-size: 10px;">Flux</a> <a href="/tags/Gemini/" style="font-size: 10px;">Gemini</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub/" style="font-size: 13px;">GitHub</a> <a href="/tags/Google-SERP/" style="font-size: 11px;">Google SERP</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hailuo/" style="font-size: 10px;">Hailuo</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hook/" style="font-size: 10px;">Hook</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/IT/" style="font-size: 10px;">IT</a> <a href="/tags/Images/" style="font-size: 11px;">Images</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JavaScript/" style="font-size: 14px;">JavaScript</a> <a href="/tags/K8s/" style="font-size: 10px;">K8s</a> <a href="/tags/LOGO/" style="font-size: 10px;">LOGO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Luma/" style="font-size: 10px;">Luma</a> <a href="/tags/MIUI/" style="font-size: 10px;">MIUI</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Midjourney/" style="font-size: 12px;">Midjourney</a> <a href="/tags/MongoDB/" style="font-size: 11px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/NBA/" style="font-size: 10px;">NBA</a> <a href="/tags/Nano-Banana/" style="font-size: 11px;">Nano Banana</a> <a href="/tags/Nexior/" style="font-size: 10px;">Nexior</a> <a href="/tags/OCR/" style="font-size: 10px;">OCR</a> <a href="/tags/OpenCV/" style="font-size: 10px;">OpenCV</a> <a href="/tags/PHP/" style="font-size: 11px;">PHP</a> <a href="/tags/PPT/" style="font-size: 10px;">PPT</a> <a href="/tags/PS/" style="font-size: 10px;">PS</a> <a href="/tags/Pathlib/" style="font-size: 10px;">Pathlib</a> <a href="/tags/PhantomJS/" style="font-size: 10px;">PhantomJS</a> <a href="/tags/Playwright/" style="font-size: 10px;">Playwright</a> <a href="/tags/Producer/" style="font-size: 11px;">Producer</a> <a href="/tags/Python/" style="font-size: 16px;">Python</a> <a href="/tags/Python-%E7%88%AC%E8%99%AB/" style="font-size: 17px;">Python 爬虫</a> <a href="/tags/Python3/" style="font-size: 11px;">Python3</a> <a href="/tags/Python3%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/" style="font-size: 12px;">Python3爬虫教程</a> <a href="/tags/Pythonic/" style="font-size: 10px;">Pythonic</a> <a href="/tags/Python%E7%88%AC%E8%99%AB/" style="font-size: 18px;">Python爬虫</a> <a href="/tags/Python%E7%88%AC%E8%99%AB%E4%B9%A6/" style="font-size: 12px;">Python爬虫书</a> <a href="/tags/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/" style="font-size: 15px;">Python爬虫教程</a> <a href="/tags/QQ/" style="font-size: 10px;">QQ</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/ReCAPTCHA/" style="font-size: 10px;">ReCAPTCHA</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Riffusion/" style="font-size: 11px;">Riffusion</a> <a href="/tags/SAE/" style="font-size: 10px;">SAE</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/SVG/" style="font-size: 10px;">SVG</a> <a href="/tags/Scrapy-redis/" style="font-size: 10px;">Scrapy-redis</a> <a href="/tags/Scrapy%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">Scrapy分布式</a> <a href="/tags/SeeDance/" style="font-size: 14px;">SeeDance</a> <a href="/tags/SeeDream/" style="font-size: 12px;">SeeDream</a> <a href="/tags/Selenium/" style="font-size: 11px;">Selenium</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/Sora/" style="font-size: 10px;">Sora</a> <a href="/tags/Sora2/" style="font-size: 11px;">Sora2</a> <a href="/tags/Suno/" style="font-size: 11px;">Suno</a> <a href="/tags/TKE/" style="font-size: 10px;">TKE</a> <a href="/tags/TXT/" style="font-size: 10px;">TXT</a> <a href="/tags/Terminal/" style="font-size: 10px;">Terminal</a> <a href="/tags/Ubuntu/" style="font-size: 11px;">Ubuntu</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/Veo/" style="font-size: 13px;">Veo</a> <a href="/tags/Vercel/" style="font-size: 10px;">Vercel</a> <a href="/tags/Videos/" style="font-size: 12px;">Videos</a> <a href="/tags/Vs-Code/" style="font-size: 10px;">Vs Code</a> <a href="/tags/Vue/" style="font-size: 11px;">Vue</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/Web%E7%BD%91%E9%A1%B5/" style="font-size: 10px;">Web网页</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/Winpcap/" style="font-size: 10px;">Winpcap</a>
              </div>
              <script>
                const tagsColors = ['#00a67c', '#5cb85c', '#d9534f', '#567e95', '#b37333', '#f4843d', '#15a287']
                const tagsElements = document.querySelectorAll('.sidebar-panel-tags .content a')
                tagsElements.forEach((item) =>
                {
                  item.style.backgroundColor = tagsColors[Math.floor(Math.random() * tagsColors.length)]
                })

              </script>
            </div>
          </div>
        </aside>
        <div id="sidebar-dimmer"></div>
      </div>
    </main>
    <footer class="footer">
      <div class="footer-inner">
        <div class="copyright">
          <span class="author" itemprop="copyrightHolder">崔庆才丨静觅</span> &copy; <span itemprop="copyrightYear">2026</span>
          <span class="with-love">
            <i class="fa fa-heart"></i>
          </span>
          <a href="https://cuiqingcai.com/sitemap.xml" style="display:none" title="爬虫教程" target="_blank"><strong>爬虫教程</strong></a>
          <a href="https://cuiqingcai.com/sitemap.html" style="display:none" title="爬虫教程" target="_blank"><strong>爬虫教程</strong></a>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-chart-area"></i>
          </span>
          <span title="站点总字数">3.5m</span>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-coffee"></i>
          </span>
          <span title="站点阅读时长">52:30</span>
        </div>
        <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 </div>
        <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备18015597号-1 </a>
        </div>
        <script>
          (function ()
          {
            function leancloudSelector(url)
            {
              url = encodeURI(url);
              return document.getElementById(url).querySelector('.leancloud-visitors-count');
            }

            function addCount(Counter)
            {
              var visitors = document.querySelector('.leancloud_visitors');
              var url = decodeURI(visitors.id);
              var title = visitors.dataset.flagTitle;
              Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify(
              {
                url
              }))).then(response => response.json()).then((
              {
                results
              }) =>
              {
                if (results.length > 0)
                {
                  var counter = results[0];
                  leancloudSelector(url).innerText = counter.time + 1;
                  Counter('put', '/classes/Counter/' + counter.objectId,
                  {
                    time:
                    {
                      '__op': 'Increment',
                      'amount': 1
                    }
                  }).catch(error =>
                  {
                    console.error('Failed to save visitor count', error);
                  });
                }
                else
                {
                  Counter('post', '/classes/Counter',
                  {
                    title,
                    url,
                    time: 1
                  }).then(response => response.json()).then(() =>
                  {
                    leancloudSelector(url).innerText = 1;
                  }).catch(error =>
                  {
                    console.error('Failed to create', error);
                  });
                }
              }).catch(error =>
              {
                console.error('LeanCloud Counter Error', error);
              });
            }

            function showTime(Counter)
            {
              var visitors = document.querySelectorAll('.leancloud_visitors');
              var entries = [...visitors].map(element =>
              {
                return decodeURI(element.id);
              });
              Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify(
              {
                url:
                {
                  '$in': entries
                }
              }))).then(response => response.json()).then((
              {
                results
              }) =>
              {
                for (let url of entries)
                {
                  let target = results.find(item => item.url === url);
                  leancloudSelector(url).innerText = target ? target.time : 0;
                }
              }).catch(error =>
              {
                console.error('LeanCloud Counter Error', error);
              });
            }
            let
            {
              app_id,
              app_key,
              server_url
            } = {
              "enable": true,
              "app_id": "6X5dRQ0pnPWJgYy8SXOg0uID-gzGzoHsz",
              "app_key": "ziLDVEy73ne5HtFTiGstzHMS",
              "server_url": "https://6x5drq0p.lc-cn-n1-shared.com",
              "security": false
            };

            function fetchData(api_server)
            {
              var Counter = (method, url, data) =>
              {
                return fetch(`${api_server}/1.1${url}`,
                {
                  method,
                  headers:
                  {
                    'X-LC-Id': app_id,
                    'X-LC-Key': app_key,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(data)
                });
              };
              if (CONFIG.page.isPost)
              {
                if (CONFIG.hostname !== location.hostname) return;
                addCount(Counter);
              }
              else if (document.querySelectorAll('.post-title-link').length >= 1)
              {
                showTime(Counter);
              }
            }
            let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;
            if (api_server)
            {
              fetchData(api_server);
            }
            else
            {
              fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id).then(response => response.json()).then((
              {
                api_server
              }) =>
              {
                fetchData('https://' + api_server);
              });
            }
          })();

        </script>
      </div>
      <div class="footer-stat">
        <span id="cnzz_stat_icon_1279355174"></span>
        <script type="text/javascript">
          document.write(unescape("%3Cspan id='cnzz_stat_icon_1279355174'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279355174%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));

        </script>
      </div>
    </footer>
  </div>
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/.js"></script>
  <script src="/js/schemes/pisces.js"></script>
  <script src="/.js"></script>
  <script src="/js/next-boot.js"></script>
  <script src="/.js"></script>
  <script>
    (function ()
    {
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x = document.getElementsByTagName("link");
      //Find the last canonical URL
      if (x.length > 0)
      {
        for (i = 0; i < x.length; i++)
        {
          if (x[i].rel.toLowerCase() == 'canonical' && x[i].href)
          {
            canonicalURL = x[i].href;
          }
        }
      }
      //Get protocol
      if (!canonicalURL)
      {
        curProtocol = window.location.protocol.split(':')[0];
      }
      else
      {
        curProtocol = canonicalURL.split(':')[0];
      }
      //Get current URL if the canonical URL does not exist
      if (!canonicalURL) canonicalURL = window.location.href;
      //Assign script content. Replace current URL with the canonical URL
      ! function ()
      {
        var e = /([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,
          r = canonicalURL,
          t = document.referrer;
        if (!e.test(r))
        {
          var n = (String(curProtocol).toLowerCase() === 'https') ? "https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif" : "//api.share.baidu.com/s.gif";
          t ? (n += "?r=" + encodeURIComponent(document.referrer), r && (n += "&l=" + r)) : r && (n += "?l=" + r);
          var i = new Image;
          i.src = n
        }
      }(window);
    })();

  </script>
  <script src="/js/local-search.js"></script>
  <script src="/.js"></script>
</body>

</html>
